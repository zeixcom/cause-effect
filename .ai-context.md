# AI Context for Cause & Effect

## What is Cause & Effect?

Cause & Effect is a modern reactive state management library for JavaScript/TypeScript that implements the signals pattern. It provides fine-grained reactivity with automatic dependency tracking, making it easy to build responsive applications with predictable state updates.

## Core Architecture

### Signal Types
- **Signal**: Base interface with `.get()` method for value access
- **State**: Mutable signals for primitive values (numbers, strings, booleans)
- **Store**: Mutable signals for objects with individually reactive properties
- **Computed**: Read-only derived signals with automatic memoization
- **Effect**: Side effect handlers that react to signal changes

### Key Principles
1. **Functional Programming**: Immutable by default, pure functions
2. **Type Safety**: Full TypeScript support with strict type constraints
3. **Performance**: Minimal re-computations through dependency tracking
4. **Async Support**: Built-in cancellation with AbortSignal
5. **Tree-shaking**: Optimized for minimal bundle size

## Project Structure

```
cause-effect/
├── src/
│   ├── signal.ts      # Base signal types and utilities
│   ├── state.ts       # Mutable state signals (createState)
│   ├── store.ts       # Object stores with reactive properties
│   ├── computed.ts    # Computed/derived signals (createComputed)
│   ├── effect.ts      # Effect system (createEffect)
│   ├── system.ts      # Core reactivity (watchers, batching, subscriptions)
│   ├── resolve.ts     # Helper for extracting signal values
│   ├── match.ts       # Pattern matching utility
│   ├── diff.ts        # Object comparison utilities
│   ├── errors.ts      # Custom error classes
│   └── util.ts        # Utilities and constants
├── index.ts           # Main export file
├── types/index.d.ts   # TypeScript declarations
└── package.json       # NPM package configuration
```

## API Patterns

### Signal Creation
```typescript
// State signals for primitives
const count = createState(42)
const name = createState("Alice")

// Store signals for objects  
const user = createStore({ name: "Alice", age: 30 })

// Computed signals for derived values
const doubled = createComputed(() => count.get() * 2)
```

### Reactivity
```typescript
// Effects react to signal changes
createEffect(() => {
  console.log(`Count: ${count.get()}`)
})

// Async effects with automatic cancellation
createEffect(async (abort) => {
  const response = await fetch('/api', { signal: abort })
  return response.json()
})
```

### Value Access Patterns
```typescript
// All signals use .get() for value access
const value = signal.get()

// Mutable signals have .set() and .update()
state.set(newValue)
state.update(current => current + 1)

// Store properties are individually reactive
user.name.set("Bob")          // Only name watchers trigger
user.age.update(age => age + 1)  // Only age watchers trigger
```

## Coding Conventions

### TypeScript Style
- Generic constraints: `T extends {}` to exclude null/undefined
- Use `const` for immutable values
- Function overloads for complex type scenarios
- JSDoc comments on all public APIs
- Pure function annotations: `/*#__PURE__*/` for tree-shaking

### Naming Conventions
- Factory functions: `create*` prefix (createState, createStore, createComputed)
- Type predicates: `is*` prefix (isSignal, isState, isComputed)
- Type constants: `TYPE_*` format (TYPE_STATE, TYPE_STORE, TYPE_COMPUTED)
- Utility constants: UPPER_CASE (UNSET)

### Error Handling
- Custom error classes in `src/errors.ts`
- Descriptive error messages with context
- Input validation at public API boundaries
- Use `UNSET` symbol for uninitialized/pending states

## Performance Considerations

### Optimization Patterns
- Dependency tracking with `Set<Watcher>` for O(1) operations
- Batched updates to minimize effect re-runs
- Shallow equality checks with `isEqual()` utility
- Memoization in computed signals prevents unnecessary recalculations
- Tree-shaking friendly with pure function annotations

### Memory Management
- Automatic cleanup of watchers when effects are disposed
- WeakMap usage for object-to-signal mappings where appropriate
- AbortSignal integration for canceling async operations

## Common Implementation Patterns

### State Management
```typescript
// Simple state
const loading = createState(false)
const error = createState('') // Empty string means no error

// Complex state with stores
const appState = createStore({
  user: { id: 1, name: "Alice" },
  settings: { theme: "dark", notifications: true }
})
```

### Async Operations
```typescript
// Computed with async data fetching
const userData = createComputed(async (abort) => {
  const response = await fetch(`/users/${userId.get()}`, { signal: abort })
  if (!response.ok) throw new Error('Failed to fetch user')
  return response.json()
})

// Handle loading/error states
createEffect(() => {
  match(resolve({ userData }), {
    ok: ({ userData }) => console.log('User:', userData),
    nil: () => console.log('Loading...'),
    err: (errors) => console.error('Error:', errors[0])
  })
})
```

### Helper Functions Usage
```typescript
// Extract values from multiple signals
const result = resolve({ name, age, email })

// Pattern matching for discriminated unions
match(result, {
  ok: (values) => console.log('Success:', values),
  nil: () => console.log('Some values pending'),
  err: (errors) => console.error('Errors:', errors)
})

// Object diffing
const changes = diff(oldUser, newUser)
console.log('Changed:', changes.change)
console.log('Added:', changes.add)
console.log('Removed:', changes.remove)
```

## Build and Development

### Tools
- **Runtime**: Bun (also works with Node.js)
- **Build**: Bun build with TypeScript compilation
- **Testing**: Bun test runner
- **Linting**: Biome for code formatting and linting

### Package Configuration
- ES modules only (`"type": "module"`)
- Dual exports: TypeScript source and compiled JavaScript
- Tree-shaking friendly with proper sideEffects configuration
- TypeScript declarations generated automatically

## Key Design Decisions

### Why Signals?
- Fine-grained reactivity (update only what changed)
- Explicit dependency tracking (no hidden dependencies)
- Composable and testable
- Framework agnostic

### Why TypeScript-First?
- Better developer experience with autocomplete
- Compile-time error catching
- Self-documenting APIs
- Better refactoring support

### Why Functional Approach?
- Predictable behavior
- Easier testing
- Better composition
- Minimal API surface

When working with this codebase, focus on maintaining the established patterns, ensuring type safety, and optimizing for performance while keeping the API simple and predictable.
