# AI Context for Cause & Effect

## What is Cause & Effect?

Cause & Effect is a modern reactive state management library for JavaScript/TypeScript that implements the signals pattern. It provides fine-grained reactivity with automatic dependency tracking, making it easy to build responsive applications with predictable state updates.

## Core Architecture

### Graph-Based Reactivity (`src/graph.ts`)

The reactive engine is a linked graph of source and sink nodes connected by `Edge` entries:
- **Sources** (StateNode) maintain a linked list of sink edges
- **Sinks** (MemoNode, TaskNode, EffectNode) maintain a linked list of source edges
- `link()` creates edges between sources and sinks during `.get()` calls
- `propagate()` flags sinks as dirty when sources change
- `flush()` processes queued effects after propagation
- `trimSources()` removes stale edges after recomputation

### Node Types
```
StateNode<T>  — source-only with equality + guard (State, Sensor)
MemoNode<T>   — source + sink (Memo, Store, List, Collection)
TaskNode<T>   — source + sink + async (Task)
EffectNode    — sink + owner (Effect)
Scope         — owner-only (createScope)
```

### Signal Types
- **State** (`createState`): Mutable signals for primitive values and objects
- **Sensor** (`createSensor`): Read-only signals for external input streams with automatic state updates. Use `SKIP_EQUALITY` for mutable object observation.
- **Memo** (`createMemo`): Synchronous derived computations with memoization and reducer capabilities
- **Task** (`createTask`): Async derived computations with automatic abort/cancellation
- **Store** (`createStore`): Mutable object signals with individually reactive properties via Proxy
- **List** (`createList`): Mutable array signals with stable keys and reactive items
- **Collection** (`createCollection`): Reactive collections — either externally-driven with watched lifecycle, or derived from List/Collection with item-level memoization
- **Effect** (`createEffect`): Side effect handlers that react to signal changes

### Key Principles
1. **Functional API**: All signals created via `create*()` factory functions (no classes)
2. **Type Safety**: Full TypeScript support with strict type constraints (`T extends {}`)
3. **Performance**: Flag-based dirty checking, linked-list edge traversal, batched flushing
4. **Async Support**: Built-in cancellation with AbortSignal in Tasks
5. **Tree-shaking**: Optimized for minimal bundle size with `/*#__PURE__*/` annotations

## Project Structure

```
cause-effect/
├── src/
│   ├── graph.ts           # Core reactive engine (nodes, edges, link, propagate, flush, batch)
│   ├── nodes/
│   │   ├── state.ts       # createState — mutable state signals
│   │   ├── sensor.ts      # createSensor — external input tracking (also covers mutable object observation)
│   │   ├── memo.ts        # createMemo — synchronous derived computations
│   │   ├── task.ts        # createTask — async derived computations
│   │   ├── effect.ts      # createEffect, match — side effects
│   │   ├── store.ts       # createStore — reactive object stores
│   │   ├── list.ts        # createList — reactive arrays with stable keys
│   │   └── collection.ts  # createCollection — externally-driven and derived collections
│   ├── util.ts            # Utility functions and type checks
│   └── ...
├── index.ts           # Entry point / main export file
├── test/
│   ├── state.test.ts
│   ├── memo.test.ts
│   ├── task.test.ts
│   ├── effect.test.ts
│   ├── store.test.ts
│   ├── list.test.ts
│   └── collection.test.ts
└── package.json
```

## API Patterns

### Signal Creation
```typescript
// State for primitives and objects
const count = createState(42)
const name = createState('Alice')

// Sensor for external input
const mousePos = createSensor<{ x: number; y: number }>((set) => {
  const handler = (e: MouseEvent) => set({ x: e.clientX, y: e.clientY })
  window.addEventListener('mousemove', handler)
  return () => window.removeEventListener('mousemove', handler)
})

// Sensor for mutable object observation (SKIP_EQUALITY)
const element = createSensor<HTMLElement>((set) => {
  const node = document.getElementById('box')!
  set(node)
  const obs = new MutationObserver(() => set(node))
  obs.observe(node, { attributes: true })
  return () => obs.disconnect()
}, { value: node, equals: SKIP_EQUALITY })

// Store for objects with reactive properties
const user = createStore({ name: 'Alice', age: 30 })

// List with stable keys for arrays
const items = createList(['apple', 'banana', 'cherry'])
const users = createList(
  [{ id: 'alice', name: 'Alice' }],
  { keyConfig: user => user.id }
)

// Memo for synchronous derived values
const doubled = createMemo(() => count.get() * 2)

// Memo with reducer capabilities (access to previous value)
const counter = createMemo(prev => {
  const action = actions.get()
  return action === 'increment' ? prev + 1 : prev - 1
}, { value: 0 })

// Task for async derived values with cancellation
const userData = createTask(async (prev, abort) => {
  const id = userId.get()
  if (!id) return prev
  const response = await fetch(`/users/${id}`, { signal: abort })
  return response.json()
})

// Collection for derived transformations
const doubled = numbers.deriveCollection((value: number) => value * 2)
const enriched = users.deriveCollection(async (user, abort) => {
  const res = await fetch(`/api/${user.id}`, { signal: abort })
  return { ...user, details: await res.json() }
})

// Collection for externally-driven data
const feed = createCollection<{ id: string; text: string }>((applyChanges) => {
  const ws = new WebSocket('/feed')
  ws.onmessage = (e) => applyChanges(JSON.parse(e.data))
  return () => ws.close()
}, { keyConfig: item => item.id })
```

### Reactivity
```typescript
// Effects run when dependencies change
const dispose = createEffect(() => {
  console.log(`Count: ${count.get()}`)
})

// Effects can return cleanup functions
createEffect(() => {
  const timer = setInterval(() => console.log(count.get()), 1000)
  return () => clearInterval(timer)
})

// match() for ergonomic signal value extraction inside effects
createEffect(() => {
  match([userData], {
    ok: ([data]) => updateUI(data),
    nil: () => showLoading(),
    err: errors => showError(errors[0].message)
  })
})
```

### Value Access Patterns
```typescript
// All signals use .get() for value access
const value = signal.get()

// State has .set() and .update()
state.set(newValue)
state.update(current => current + 1)

// Store properties are individually reactive via Proxy
user.name.set('Bob')             // Only name watchers trigger
user.age.update(age => age + 1)  // Only age watchers trigger

// List with stable keys
const items = createList(['apple', 'banana'], { keyConfig: 'fruit' })
const appleSignal = items.byKey('fruit0')
const firstKey = items.keyAt(0)
const appleIndex = items.indexOfKey('fruit0')
items.splice(1, 0, 'cherry')
items.sort()

// Collections via deriveCollection
const processed = items.deriveCollection(item => item.toUpperCase())
```

## Coding Conventions

### TypeScript Style
- Generic constraints: `T extends {}` to exclude null/undefined
- Use `const` for immutable values
- Function overloads for complex type scenarios (e.g., `createCollection`, `deriveCollection`)
- JSDoc comments on all public APIs
- Pure function annotations: `/*#__PURE__*/` for tree-shaking

### Naming Conventions
- Factory functions: `create*` prefix (createState, createMemo, createEffect, createStore, createList, createCollection, createSensor)
- Type predicates: `is*` prefix (isState, isMemo, isTask, isStore, isList, isCollection, isSensor)
- Type constants: `TYPE_*` format (TYPE_STATE, TYPE_STORE, TYPE_SENSOR, TYPE_COLLECTION)
- Callback types: `*Callback` suffix (MemoCallback, TaskCallback, EffectCallback, SensorCallback, CollectionCallback, DeriveCollectionCallback)

### Error Handling
- Custom error classes in `src/errors.ts`: CircularDependencyError, NullishSignalValueError, InvalidSignalValueError, InvalidCallbackError, RequiredOwnerError, UnsetSignalValueError
- Descriptive error messages with `[TypeName]` prefix
- Input validation via `validateSignalValue()` and `validateCallback()`
- Optional type guards via `guard` option in SignalOptions

## Performance Considerations

### Optimization Patterns
- Linked-list edges for O(1) link/unlink operations
- Flag-based dirty checking: FLAG_CLEAN, FLAG_CHECK, FLAG_DIRTY, FLAG_RUNNING
- Batched updates via `batch()` to minimize effect re-runs
- Lazy evaluation: Memos only recompute when accessed and dirty
- Automatic abort of in-flight Tasks when sources change

### Memory Management
- `trimSources()` removes stale edges after each recomputation
- `unlink()` calls `source.stop()` when last sink disconnects (auto-cleanup for Sensor/Collection/Store/List)
- AbortSignal integration for canceling async operations
- `createScope()` for hierarchical cleanup of nested effects

## Resource Management

**Sensor and Collection** use a start callback that returns a Cleanup function:
```typescript
const sensor = createSensor<T>((set) => {
  // setup input tracking, call set(value) to update
  return () => { /* cleanup */ }
})

const feed = createCollection<T>((applyChanges) => {
  // setup external data source, call applyChanges(diffResult) on changes
  return () => { /* cleanup */ }
}, { keyConfig: item => item.id })
```

**Store and List** use an optional `watched` callback in options:
```typescript
const store = createStore(initialValue, {
  watched: () => {
    // setup resources
    return () => { /* cleanup */ }
  }
})
```

Resources activate on first sink link and cleanup when last sink unlinks.

## Build and Development

### Tools
- **Runtime**: Bun (also works with Node.js)
- **Build**: Bun build with TypeScript compilation
- **Testing**: Bun test runner (`bun test`)
- **Linting**: Biome for code formatting and linting

### Package Configuration
- ES modules only (`"type": "module"`)
- TypeScript declarations generated automatically
- Tree-shaking friendly with proper sideEffects configuration
