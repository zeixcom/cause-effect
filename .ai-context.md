# AI Context for Cause & Effect

## What is Cause & Effect?

Cause & Effect is a modern reactive state management library for JavaScript/TypeScript that implements the signals pattern. It provides fine-grained reactivity with automatic dependency tracking, making it easy to build responsive applications with predictable state updates.

## Core Architecture

### Signal Types
- **Signal**: Base interface with `.get()` method for value access
- **State**: Mutable signals for primitive values (numbers, strings, booleans)
- **Ref**: Signal wrappers for external objects that change outside the reactive system (DOM elements, Map, Set, Date, third-party objects)
- **Computed**: Read-only derived signals with automatic memoization, reducer capabilities and async handling
- **Store**: Mutable signals for objects with individually reactive properties
- **List**: Mutable signals for arrays with individually reactive items
- **Collection**: Interface for reactive array-like collections (implemented by DerivedCollection)
- **Effect**: Side effect handlers that react to signal changes

### Key Principles
1. **Functional Programming**: Immutable by default, pure functions
2. **Type Safety**: Full TypeScript support with strict type constraints
3. **Performance**: Minimal re-computations through dependency tracking
4. **Async Support**: Built-in cancellation with AbortSignal
5. **Tree-shaking**: Optimized for minimal bundle size

## Project Structure

```
cause-effect/
├── src/
│   ├── classes/
│   │   ├── state.ts       # Mutable state signals (State)
│   │   ├── ref.ts         # Signal wrapper for external objects (Ref)
│   │   ├── store.ts       # Object stores with reactive properties
│   │   ├── list.ts        # Array stores with stable keys (List)
│   │   ├── collection.ts  # Collection interface and DerivedCollection
│   │   └── computed.ts    # Computed/derived signals (Memo and Task)
|   ├── signal.ts      # Base signal types and utilities
│   ├── effect.ts      # Effect system (createEffect)
│   ├── system.ts      # Core reactivity (watchers, batching, subscriptions)
│   ├── resolve.ts     # Helper for extracting signal values
│   ├── match.ts       # Pattern matching utility
│   ├── diff.ts        # Object comparison utilities
│   ├── errors.ts      # Custom error classes
│   └── util.ts        # Utilities and constants
├── index.ts           # Main export file
├── types/index.d.ts   # TypeScript declarations
└── package.json       # NPM package configuration
```

## API Patterns

### Signal Creation
```typescript
// State signals for primitives
const count = new State(42)
const name = new State('Alice')
const actions = new State<'increment' | 'decrement' | 'reset'>('reset')

// Ref signals for external objects
const elementRef = new Ref(document.getElementById('status'))
const cacheRef = new Ref(new Map([['key', 'value']]))

// Store signals for objects  
const user = createStore({ name: 'Alice', age: 30 })

// List with stable keys for arrays
const items = new List(['apple', 'banana', 'cherry'])
const users = new List([{ id: 'alice', name: 'Alice' }], user => user.id)

// Computed signals for derived values
const doubled = new Memo(() => count.get() * 2)

// Computed with reducer capabilities (access to previous value)
const counter = new Memo((prev) => {
  const action = actions.get()
  switch (action) {
    case 'increment': return prev + 1
    case 'decrement': return prev - 1
    case 'reset': return 0
    default: return prev
  }
}, 0) // Initial value

// Async computed with access to previous value
const userData = new Task(async (prev, abort) => {
  const id = userId.get()
  if (!id) return prev // Keep previous data if no user ID
  const response = await fetch(`/users/${id}`, { signal: abort })
  return response.json()
})
```

### Reactivity
```typescript
// Effects react to signal changes
createEffect(() => {
  console.log(`Count: ${count.get()}`)
})

// Async effects with automatic cancellation
createEffect(async (abort) => {
  const response = await fetch('/api', { signal: abort })
  return response.json()
})
```

### Value Access Patterns
```typescript
// All signals use .get() for value access
const value = signal.get()

// Mutable signals have .set() and .update()
state.set(newValue)
state.update(current => current + 1)

// Store properties are individually reactive
user.name.set("Bob")          // Only name watchers trigger
user.age.update(age => age + 1)  // Only age watchers trigger

// List with stable keys for arrays
const items = new List(['apple', 'banana'], 'fruit')
const appleSignal = items.byKey('fruit0')  // Access by stable key
const firstKey = items.keyAt(0)            // Get key at position
const appleIndex = items.indexOfKey('fruit0') // Get position of key
items.splice(1, 0, 'cherry')               // Insert at position 1
items.sort()                               // Sort while preserving keys
```

## Coding Conventions

### TypeScript Style
- Generic constraints: `T extends {}` to exclude null/undefined
- Use `const` for immutable values
- Function overloads for complex type scenarios
- JSDoc comments on all public APIs
- Pure function annotations: `/*#__PURE__*/` for tree-shaking

### Naming Conventions
- Factory functions: `create*` prefix (createEffect, createStore, createComputed)
- Type predicates: `is*` prefix (isSignal, isState, isComputed)
- Type constants: `TYPE_*` format (TYPE_STATE, TYPE_STORE, TYPE_COMPUTED)
- Utility constants: UPPER_CASE (UNSET)

### Error Handling
- Custom error classes in `src/errors.ts`
- Descriptive error messages with context
- Input validation at public API boundaries
- Use `UNSET` symbol for uninitialized/pending states

## Performance Considerations

### Optimization Patterns
- Dependency tracking with `Set<Watcher>` for O(1) operations
- Batched updates to minimize effect re-runs
- Shallow equality checks with `isEqual()` utility
- Memoization in computed signals prevents unnecessary recalculations
- Tree-shaking friendly with pure function annotations

### Memory Management
- Automatic cleanup of watchers when effects are disposed
- WeakMap usage for object-to-signal mappings where appropriate
- AbortSignal integration for canceling async operations

## Common Implementation Patterns

### State Management
```typescript
// Simple state
const loading = new State(false)
const error = new State('') // Empty string means no error

// Nested state with stores
const appState = createStore({
  user: { id: 1, name: "Alice" },
  settings: { theme: "dark", notifications: true }
})

// Lists with stable keys for arrays
const todoList = new List([
  { id: 'task1', text: 'Learn signals', completed: false },
  { id: 'task2', text: 'Build app', completed: false }
], todo => todo.id) // Use ID as stable key

// Access todos by stable key for consistent references
const firstTodo = todoList.byKey('task1')
firstTodo?.completed.set(true) // Mark completed

// Collections for read-only derived data
const completedTodos = new DerivedCollection(todoList, todo => 
  todo.completed ? { ...todo, status: 'done' } : null
).filter(Boolean) // Remove null values

// Async collections for enhanced data
const todoWithDetails = new DerivedCollection(todoList, async (todo, abort) => {
  const response = await fetch(`/todos/${todo.id}/details`, { signal: abort })
  return { ...todo, details: await response.json() }
})

// Element collections for DOM reactivity
const buttons = createElementCollection(document.body, 'button')
const inputs = createElementCollection(form, 'input[type="text"]')
```

### Derived State
```typescript
// Reducer pattern for state machines
const appState = new Memo((prev) => {
  const event = events.get()
  switch (prev) {
    case 'idle':
      return event === 'start' ? 'loading' : 'idle'
    case 'loading':
      return event === 'success' ? 'loaded' : event === 'error' ? 'error' : 'loading'
    case 'loaded':
      return event === 'refresh' ? 'loading' : 'loaded'
    case 'error':
      return event === 'retry' ? 'loading' : 'error'
    default:
      return 'idle'
  }
}, 'idle') // Initial state
```

### Async Operations
```typescript
// Computed with async data fetching
const userData = new Task(async (prev, abort) => {
  const id = userId.get()
  if (!id) return prev // Retain previous data when no ID
  const response = await fetch(`/users/${id}`, { signal: abort })
  if (!response.ok) throw new Error('Failed to fetch user')
  return response.json()
})
```

### Error Handling
```typescript
// Handle loading/error states
createEffect(() => {
  match(resolve({ userData }), {
    ok: ({ userData }) => console.log('User:', userData),
    nil: () => console.log('Loading...'),
    err: (errors) => console.error('Error:', errors[0])
  })
})
```

### Helper Functions Usage
```typescript
// Extract values from multiple signals
const result = resolve({ name, age, email })

// Pattern matching for discriminated unions
match(result, {
  ok: (values) => console.log('Success:', values),
  nil: () => console.log('Some values pending'),
  err: (errors) => console.error('Errors:', errors)
})

// Object diffing
const changes = diff(oldUser, newUser)
console.log('Changed:', changes.change)
console.log('Added:', changes.add)
console.log('Removed:', changes.remove)

// Collection transformations
const processedItems = items.deriveCollection(item => ({
  ...item,
  processed: true,
  timestamp: Date.now()
}))

// Chained collections for data pipelines
const finalResults = processedItems.deriveCollection(item => 
  item.processed ? { summary: `${item.name} at ${item.timestamp}` } : null
).filter(Boolean)

// Ref signal manual notifications
elementRef.notify() // Notify when DOM element changes externally
cacheRef.notify()   // Notify when Map/Set changes externally

// Resource management with watch callbacks
const endpoint = new State('https://api.example.com', {
  watched: () => {
    console.log('Setting up API client...')
    const resource = createResource(endpoint.get())
  }, 
  unwatched: () => {
    console.log('Cleaning up API client...')
    resource.cleanup()
  }
})

```

## Build and Development

### Tools
- **Runtime**: Bun (also works with Node.js)
- **Build**: Bun build with TypeScript compilation
- **Testing**: Bun test runner
- **Linting**: Biome for code formatting and linting

### Package Configuration
- ES modules only (`"type": "module"`)
- Dual exports: TypeScript source and compiled JavaScript
- Tree-shaking friendly with proper sideEffects configuration
- TypeScript declarations generated automatically

## Key Design Decisions

### Why Signals?
- Fine-grained reactivity (update only what changed)
- Explicit dependency tracking (no hidden dependencies)
- Composable and testable
- Framework agnostic

### Why TypeScript-First?
- Better developer experience with autocomplete
- Compile-time error catching
- Self-documenting APIs
- Better refactoring support

### Why Functional Approach?
- Predictable behavior
- Easier testing
- Better composition
- Minimal API surface

When working with this codebase, focus on maintaining the established patterns, ensuring type safety, and optimizing for performance while keeping the API simple and predictable.
