# AI Context for Cause & Effect

## What is Cause & Effect?

Cause & Effect is a modern reactive state management library for JavaScript/TypeScript that implements the signals pattern. It provides fine-grained reactivity with automatic dependency tracking, making it easy to build responsive applications with predictable state updates.

## Core Architecture

### Graph-Based Reactivity (`src/graph.ts`)

The reactive engine is a linked graph of source and sink nodes connected by `Edge` entries:
- **Sources** (RefNode, StateNode) maintain a linked list of sink edges
- **Sinks** (MemoNode, TaskNode, EffectNode) maintain a linked list of source edges
- `link()` creates edges between sources and sinks during `.get()` calls
- `propagate()` flags sinks as dirty when sources change
- `flush()` processes queued effects after propagation
- `trimSources()` removes stale edges after recomputation

### Node Types
```
RefNode<T>    — source-only (Ref, Store, List, Collection structural changes)
StateNode<T>  — source with equality + guard (State, Sensor)
MemoNode<T>   — source + sink (Memo)
TaskNode<T>   — source + sink + async (Task)
EffectNode    — sink + owner (Effect)
Scope         — owner-only (createScope)
```

### Signal Types
- **State** (`createState`): Mutable signals for primitive values and objects
- **Ref** (`createRef`): Read-only signals for external objects with observation setup/teardown
- **Sensor** (`createSensor`): Read-only signals for external input streams with automatic state updates
- **Memo** (`createMemo`): Synchronous derived computations with memoization and reducer capabilities
- **Task** (`createTask`): Async derived computations with automatic abort/cancellation
- **Store** (`createStore`): Mutable object signals with individually reactive properties via Proxy
- **List** (`createList`): Mutable array signals with stable keys and reactive items
- **Collection** (`createCollection`): Read-only derived collections with item-level memoization
- **Effect** (`createEffect`): Side effect handlers that react to signal changes

### Key Principles
1. **Functional API**: All signals created via `create*()` factory functions (no classes)
2. **Type Safety**: Full TypeScript support with strict type constraints (`T extends {}`)
3. **Performance**: Flag-based dirty checking, linked-list edge traversal, batched flushing
4. **Async Support**: Built-in cancellation with AbortSignal in Tasks
5. **Tree-shaking**: Optimized for minimal bundle size with `/*#__PURE__*/` annotations

## Project Structure

```
cause-effect/
├── src/
│   ├── graph.ts           # Core reactive engine (nodes, edges, link, propagate, flush, batch)
│   ├── nodes/
│   │   ├── state.ts       # createState — mutable state signals
│   │   ├── ref.ts         # createRef — reactive references to external objects
│   │   ├── sensor.ts      # createSensor — external input tracking
│   │   ├── memo.ts        # createMemo — synchronous derived computations
│   │   ├── task.ts        # createTask — async derived computations
│   │   ├── effect.ts      # createEffect, match — side effects
│   │   ├── store.ts       # createStore — reactive object stores
│   │   ├── list.ts        # createList — reactive arrays with stable keys
│   │   └── collection.ts  # createCollection — derived collections
│   ├── util.ts            # Utility functions and type checks
│   └── ...
├── next.ts            # Entry point for graph-based API
├── test/
│   ├── state.next.test.ts
│   ├── memo.next.test.ts
│   ├── task.next.test.ts
│   ├── effect.next.test.ts
│   ├── store.next.test.ts
│   ├── list.next.test.ts
│   └── collection.next.test.ts
└── package.json
```

## API Patterns

### Signal Creation
```typescript
// State for primitives and objects
const count = createState(42)
const name = createState('Alice')

// Ref for external objects (returns Memo<T>)
const el = createRef(document.getElementById('box'), (notify) => {
  const observer = new MutationObserver(() => notify())
  observer.observe(el.get(), { attributes: true })
  return () => observer.disconnect()
})

// Sensor for external input (returns Memo<T>)
const mousePos = createSensor<{ x: number; y: number }>((set) => {
  const handler = (e: MouseEvent) => set({ x: e.clientX, y: e.clientY })
  window.addEventListener('mousemove', handler)
  return () => window.removeEventListener('mousemove', handler)
})

// Store for objects with reactive properties
const user = createStore({ name: 'Alice', age: 30 })

// List with stable keys for arrays
const items = createList(['apple', 'banana', 'cherry'])
const users = createList(
  [{ id: 'alice', name: 'Alice' }],
  { keyConfig: user => user.id }
)

// Memo for synchronous derived values
const doubled = createMemo(() => count.get() * 2)

// Memo with reducer capabilities (access to previous value)
const counter = createMemo(prev => {
  const action = actions.get()
  return action === 'increment' ? prev + 1 : prev - 1
}, { value: 0 })

// Task for async derived values with cancellation
const userData = createTask(async (prev, abort) => {
  const id = userId.get()
  if (!id) return prev
  const response = await fetch(`/users/${id}`, { signal: abort })
  return response.json()
})

// Collection for derived transformations
const doubled = createCollection(numbers, (value: number) => value * 2)
const enriched = createCollection(users, async (user, abort) => {
  const res = await fetch(`/api/${user.id}`, { signal: abort })
  return { ...user, details: await res.json() }
})
```

### Reactivity
```typescript
// Effects run when dependencies change
const dispose = createEffect(() => {
  console.log(`Count: ${count.get()}`)
})

// Effects can return cleanup functions
createEffect(() => {
  const timer = setInterval(() => console.log(count.get()), 1000)
  return () => clearInterval(timer)
})

// match() for ergonomic signal value extraction inside effects
createEffect(() => {
  match([userData], {
    ok: ([data]) => updateUI(data),
    nil: () => showLoading(),
    err: errors => showError(errors[0].message)
  })
})
```

### Value Access Patterns
```typescript
// All signals use .get() for value access
const value = signal.get()

// State has .set() and .update()
state.set(newValue)
state.update(current => current + 1)

// Store properties are individually reactive via Proxy
user.name.set('Bob')             // Only name watchers trigger
user.age.update(age => age + 1)  // Only age watchers trigger

// List with stable keys
const items = createList(['apple', 'banana'], { keyConfig: 'fruit' })
const appleSignal = items.byKey('fruit0')
const firstKey = items.keyAt(0)
const appleIndex = items.indexOfKey('fruit0')
items.splice(1, 0, 'cherry')
items.sort()

// Collections via deriveCollection
const processed = items.deriveCollection(item => item.toUpperCase())
```

## Coding Conventions

### TypeScript Style
- Generic constraints: `T extends {}` to exclude null/undefined
- Use `const` for immutable values
- Function overloads for complex type scenarios (e.g., `createCollection`, `deriveCollection`)
- JSDoc comments on all public APIs
- Pure function annotations: `/*#__PURE__*/` for tree-shaking

### Naming Conventions
- Factory functions: `create*` prefix (createState, createMemo, createEffect, createStore, createList, createCollection)
- Type predicates: `is*` prefix (isState, isMemo, isTask, isStore, isList, isCollection)
- Type constants: `TYPE_*` format (TYPE_STATE, TYPE_STORE)
- Callback types: `*Callback` suffix (MemoCallback, TaskCallback, EffectCallback, RefCallback, SensorCallback, CollectionCallback)

### Error Handling
- Custom error classes in `src/graph.ts`: CircularDependencyError, NullishSignalValueError, InvalidSignalValueError, InvalidCallbackError
- Descriptive error messages with `[TypeName]` prefix
- Input validation via `validateSignalValue()` and `validateCallback()`
- Optional type guards via `guard` option in SignalOptions

## Performance Considerations

### Optimization Patterns
- Linked-list edges for O(1) link/unlink operations
- Flag-based dirty checking: FLAG_CLEAN, FLAG_CHECK, FLAG_DIRTY, FLAG_RUNNING
- Batched updates via `batch()` to minimize effect re-runs
- Lazy evaluation: Memos only recompute when accessed and dirty
- Automatic abort of in-flight Tasks when sources change

### Memory Management
- `trimSources()` removes stale edges after each recomputation
- `unlink()` calls `source.stop()` when last sink disconnects (auto-cleanup for Ref/Sensor/Store/List)
- AbortSignal integration for canceling async operations
- `createScope()` for hierarchical cleanup of nested effects

## Resource Management

**Ref and Sensor** use a start callback that returns a Cleanup function:
```typescript
const ref = createRef(value, (notify) => {
  // setup observation
  return () => { /* cleanup */ }
})

const sensor = createSensor<T>((set) => {
  // setup input tracking, call set() with new values
  return () => { /* cleanup */ }
})
```

**Store and List** use an optional `watched` callback in options:
```typescript
const store = createStore(initialValue, {
  watched: () => {
    // setup resources
    return () => { /* cleanup */ }
  }
})
```

Resources activate on first sink link and cleanup when last sink unlinks.

## Build and Development

### Tools
- **Runtime**: Bun (also works with Node.js)
- **Build**: Bun build with TypeScript compilation
- **Testing**: Bun test runner (`bun test`)
- **Linting**: Biome for code formatting and linting

### Package Configuration
- ES modules only (`"type": "module"`)
- TypeScript declarations generated automatically
- Tree-shaking friendly with proper sideEffects configuration
