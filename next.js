var f="State",h="Memo",p="Task",x$=0;var g=2;var M=null,T=null,$$=[],_=0,G$=!1,O=($,J)=>$===J,E$=($)=>typeof $==="function",S$=($,J)=>{let Q=J.sourcesTail;if(Q){let X=J.sources;while(X){if(X===$)return!0;if(X===Q)break;X=X.nextSource}}return!1},R=($,J)=>{let Q=J.sourcesTail;if(Q?.source===$)return;let X=null,H=J.flags&4;if(H){if(X=Q?Q.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let B=$.sinksTail;if(B?.sink===J&&(!H||S$(B,J)))return;let N={source:$,sink:J,nextSource:X,prevSink:B,nextSink:null};if(J.sourcesTail=$.sinksTail=N,Q)Q.nextSource=N;else J.sources=N;if(B)B.nextSink=N;else $.sinks=N},h$=($)=>{let{source:J,nextSource:Q,nextSink:X,prevSink:H}=$;if(X)X.prevSink=H;else J.sinksTail=H;if(H)H.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return Q},t=($)=>{let J=$.sourcesTail,Q=J?J.nextSource:$.sources;while(Q)Q=h$(Q);if(J)J.nextSource=null;else $.sources=null},C=($,J=2)=>{let Q=$.flags;if("sinks"in $){if((Q&3)>=J)return;if($.flags=Q|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)C(X.sink,1)}else{if(Q&2)return;$.flags=2,$$.push($)}},s=($,J)=>{if($.equals($.value,J))return;$.value=J;for(let Q=$.sinks;Q;Q=Q.nextSink)C(Q.sink);if(_===0)V()},w=($,J)=>{if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]},J$=($)=>{if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null},p$=($)=>{let J=M;M=$,$.sourcesTail=null,$.flags=4;let Q=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,Q=!0}catch(X){Q=!0,$.error=X instanceof Error?X:Error(String(X))}finally{M=J,t($)}if(Q){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&1)X.sink.flags|=2}$.flags=0},g$=($)=>{$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let Q=M;M=$,$.sourcesTail=null,$.flags=4;let X;try{X=$.fn($.value,J.signal)}catch(H){$.controller=void 0,$.error=H instanceof Error?H:Error(String(H));return}finally{M=Q,t($)}X.then((H)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(H,$.value)){$.value=H,$.error=void 0;for(let B=$.sinks;B;B=B.nextSink)C(B.sink);if(_===0)V()}},(H)=>{if(J.signal.aborted)return;$.controller=void 0;let B=H instanceof Error?H:Error(String(H));if(!$.error||B.name!==$.error.name||B.message!==$.error.message){$.error=B;for(let N=$.sinks;N;N=N.nextSink)C(N.sink);if(_===0)V()}}),$.flags=0},N$=($)=>{J$($);let J=M,Q=T;M=T=$,$.sourcesTail=null,$.flags=4;try{let X=$.fn();if(typeof X==="function")w($,X)}finally{M=J,T=Q,t($)}$.flags=0},y=($)=>{if($.flags&1)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)y(J.source);if($.flags&2)break}if($.flags&4)throw new o("controller"in $?"Task":("value"in $)?"Memo":"Effect");if($.flags&2)if("controller"in $)g$($);else if("value"in $)p$($);else N$($);else $.flags=0},V=()=>{if(G$)return;G$=!0;try{for(let $=0;$<$$.length;$++){let J=$$[$];if(J.flags&2)y(J)}$$.length=0}finally{G$=!1}},l=($)=>{_++;try{$()}finally{if(_--,_===0)V()}},y$=($)=>{let J=T,Q={cleanup:null};T=Q;try{let X=$();if(typeof X==="function")w(Q,X);let H=()=>J$(Q);if(J)w(J,H);return H}finally{T=J}},m$=($)=>typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);function I($,J,Q){if(J==null)throw new M$($);if(Q&&!Q(J))throw new q$($,J)}function v($,J){if(J==null)throw new i($)}function x($,J,Q=E$){if(!Q(J))throw new F$($,J)}class o extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class M$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class i extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class q$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${m$(J)} is invalid`);this.name="InvalidSignalValueError"}}class F$ extends TypeError{constructor($,J){super(`[${$}] Callback ${m$(J)} is invalid`);this.name="InvalidCallbackError"}}class Q$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}var C$=($)=>typeof $==="string",D$=($)=>typeof $==="number",A$=($)=>typeof $==="symbol",E=($)=>typeof $==="function",X$=($)=>E($)&&$.constructor.name==="AsyncFunction",k=($)=>E($)&&$.constructor.name!=="AsyncFunction",j$=($)=>$!=null&&typeof $==="object",K=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,b=($)=>K($,"Object"),L$=($)=>b($)||Array.isArray($);var r=($,J)=>{I(f,$,J?.guard);let Q={value:$,sinks:null,sinksTail:null,equals:J?.equals??O,guard:J?.guard};return{[Symbol.toStringTag]:f,get(){if(M)R(Q,M);return Q.value},set(H){I(f,H,Q.guard),s(Q,H)},update(H){x(f,H);let B=H(Q.value);I(f,B,Q.guard),s(Q,B)}}},v$=($)=>K($,f);var c="List";class V$ extends Error{constructor($,J,Q){super(`Could not add ${$} key "${J}"${Q?` with value ${JSON.stringify(Q)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var u=($,J,Q)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!j$($)||!j$(J))return!1;if(!Q)Q=new WeakSet;if(Q.has($)||Q.has(J))throw new o("isEqual");Q.add($),Q.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let X=0;X<$.length;X++)if(!u($[X],J[X],Q))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(b($)&&b(J)){let X=Object.keys($),H=Object.keys(J);if(X.length!==H.length)return!1;for(let B of X){if(!(B in J))return!1;if(!u($[B],J[B],Q))return!1}return!0}return!1}finally{Q.delete($),Q.delete(J)}},k$=($,J,Q,X)=>{let H=new WeakSet,B={},N={},j={},D=[],q=new Map;for(let Z=0;Z<$.length;Z++){let U=Q[Z];if(U&&$[Z])q.set(U,$[Z])}let W=new Set;for(let Z=0;Z<J.length;Z++){let U=J[Z];if(U===void 0)continue;let F=Q[Z];if(!F)F=X(U);if(D.push(F),W.add(F),!q.has(F))B[F]=U;else{let m=q.get(F);if(!u(m,U,H))N[F]=U}}for(let[Z]of q)if(!W.has(Z))j[Z]=null;return{add:B,change:N,remove:j,newKeys:D,changed:!!(Object.keys(B).length||Object.keys(N).length||Object.keys(j).length)}},I$=($,J)=>{I(c,$,Array.isArray);let Q=new Map,X=[],H=0,B=J?.keyConfig,N=C$(B)?()=>`${B}${H++}`:E(B)?(z)=>B(z):()=>String(H++),j={value:$,sinks:null,sinksTail:null,stop:void 0},D=()=>{for(let z=j.sinks;z;z=z.nextSink)C(z.sink);if(_===0)V()},q=()=>{if(M){if(!j.sinks&&J?.watched)j.stop=J.watched();R(j,M)}},W=(z,G)=>{I(`${c} item for key "${z}"`,G),Q.set(z,r(G))},Z=(z)=>{let G={};for(let L=0;L<z.length;L++){let A=z[L];if(A===void 0)continue;let Y=X[L];if(!Y)Y=N(A),X[L]=Y;G[Y]=A}return G},U=()=>{return X.map((z)=>Q.get(z)?.get()).filter((z)=>z!==void 0)},F=(z)=>{for(let G in z.add)W(G,z.add[G]);if(Object.keys(z.change).length)l(()=>{for(let G in z.change){let L=z.change[G];I(`${c} item for key "${G}"`,L);let A=Q.get(G);if(A)A.set(L)}});for(let G in z.remove){Q.delete(G);let L=X.indexOf(G);if(L!==-1)X.splice(L,1)}return z.changed},m=Z($);for(let z in m)W(z,m[z]);let P={[Symbol.toStringTag]:c,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let z of X){let G=Q.get(z);if(G)yield G}},get length(){return q(),X.length},get(){return q(),U()},set(z){let G=U(),L=k$(G,z,X,N);if(L.changed)X=L.newKeys,F(L),D()},update(z){P.set(z(P.get()))},at(z){return Q.get(X[z])},keys(){return q(),X.values()},byKey(z){return Q.get(z)},keyAt(z){return X[z]},indexOfKey(z){return X.indexOf(z)},add(z){let G=N(z);if(Q.has(G))throw new V$(c,G,z);if(!X.includes(G))X.push(G);return W(G,z),D(),G},remove(z){let G=D$(z)?X[z]:z;if(Q.delete(G)){let A=D$(z)?z:X.indexOf(G);if(A>=0)X.splice(A,1);D()}},sort(z){let L=X.map((A)=>[A,Q.get(A)?.get()]).sort(E(z)?(A,Y)=>z(A[1],Y[1]):(A,Y)=>String(A[1]).localeCompare(String(Y[1]))).map(([A])=>A);if(!u(X,L))X=L,D()},splice(z,G,...L){let A=X.length,Y=z<0?Math.max(0,A+z):Math.min(z,A),P$=Math.max(0,Math.min(G??Math.max(0,A-Math.max(0,Y)),A-Y)),U$={},a={};for(let S=0;S<P$;S++){let e=Y+S,B$=X[e];if(B$){let _$=Q.get(B$);if(_$)a[B$]=_$.get()}}let H$=X.slice(0,Y);for(let S of L){let e=N(S);H$.push(e),U$[e]=S}H$.push(...X.slice(Y+P$));let Y$=!!(Object.keys(U$).length||Object.keys(a).length);if(Y$)F({add:U$,change:{},remove:a,changed:Y$}),X=H$.filter(()=>!0),D();return Object.values(a)},deriveCollection(z){return Z$(P,z)}};return P},K$=($)=>K($,c);var W$=($,J)=>{if(x(h,$,k),J?.value!==void 0)I(h,J.value,J?.guard);let Q={fn:$,value:J?.value,flags:g,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??O,error:void 0};return{[Symbol.toStringTag]:h,get(){if(M)R(Q,M);if(y(Q),Q.error)throw Q.error;return v(h,Q.value),Q.value}}},c$=($)=>K($,h);var R$=($,J)=>{if(x(p,$,X$),J?.value!==void 0)I(p,J.value,J?.guard);let Q={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:g,equals:J?.equals??O,controller:void 0,error:void 0};return{[Symbol.toStringTag]:p,get(){if(M)R(Q,M);if(y(Q),Q.error)throw Q.error;return v(p,Q.value),Q.value},isPending(){return!!Q.controller},abort(){Q.controller?.abort(),Q.controller=void 0}}},u$=($)=>K($,p);var z$="Collection";function Z$($,J){if(x(z$,J),!d$($))throw TypeError(`[${z$}] Invalid collection source: expected a List or Collection`);let Q=X$(J),X=new Map,H=[],B={value:[],sinks:null,sinksTail:null,stop:void 0},N=()=>{for(let U=B.sinks;U;U=U.nextSink)C(U.sink);if(_===0)V()},j=()=>{if(M)R(B,M)},D=(U)=>{let F=Q?R$(async(m,P)=>{let z=$.byKey(U)?.get();if(z==null)return m;return J(z,P)}):W$(()=>{let m=$.byKey(U)?.get();if(m==null)return;return J(m)});X.set(U,F)},q=W$(()=>{return Array.from($.keys())}),W=()=>{let U=q.get();if(H.length===U.length){let z=!1;for(let G=0;G<H.length;G++)if(H[G]!==U[G]){z=!0;break}if(!z)return}let F=new Set(H),m=new Set(U),P=!1;for(let z of H)if(!m.has(z))X.delete(z),P=!0;for(let z of U)if(!F.has(z))D(z),P=!0;if(!P)P=!0;if(H=U,P)N()};for(let U of Array.from($.keys()))D(U),H.push(U);let Z={[Symbol.toStringTag]:z$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let U of H){let F=X.get(U);if(F)yield F}},get length(){return j(),W(),H.length},keys(){return j(),W(),H.values()},get(){return j(),W(),H.map((U)=>{try{return X.get(U)?.get()}catch{return}}).filter((U)=>U!=null)},at(U){return X.get(H[U])},byKey(U){return X.get(U)},keyAt(U){return H[U]},indexOfKey(U){return H.indexOf(U)},deriveCollection(U){return Z$(Z,U)}};return Z}var T$=($)=>K($,z$),d$=($)=>K$($)||T$($);var t$=($)=>{x("Effect",$);let J={fn:$,flags:g,sources:null,sourcesTail:null,cleanup:null},Q=()=>{J$(J),J.fn=void 0,J.flags=x$,J.sourcesTail=null,t(J)};if(T)w(T,Q);return N$(J),Q},s$=($,J)=>{if(!T)throw new Q$("match");let{ok:Q,err:X=console.error,nil:H}=J,B,N=!1,j=Array($.length);for(let q=0;q<$.length;q++)try{let W=$[q].get();if(W==null)N=!0;else j[q]=W}catch(W){if(W instanceof i){N=!0;continue}if(!B)B=[];B.push(W instanceof Error?W:Error(String(W)))}let D;try{if(N)D=H?.();else if(B)D=X(B);else D=Q(j)}catch(q){X([q instanceof Error?q:Error(String(q))])}if(typeof D==="function")return D;if(D instanceof Promise){let q=T,W=new AbortController;w(q,()=>W.abort()),D.then((Z)=>{if(!W.signal.aborted&&typeof Z==="function")w(q,Z)}).catch((Z)=>{X([Z instanceof Error?Z:Error(String(Z))])})}};var O$="Ref",l$=($,J)=>{I("Ref",$),x("Ref",J,k);let Q={value:$,sinks:null,sinksTail:null,stop:void 0};return{[Symbol.toStringTag]:O$,get(){if(M){if(!Q.sinks)Q.stop=J(()=>{for(let X=Q.sinks;X;X=X.nextSink)C(X.sink);if(_===0)V()});R(Q,M)}return Q.value}}},o$=($)=>K($,O$);var n="Sensor",i$=($,J)=>{if(x(n,$,k),J?.value!==void 0)I(n,J.value,J?.guard);let Q={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??O,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:n,get(){if(M){if(!Q.sinks)Q.stop=$((X)=>{I("Sensor",X,Q.guard),s(Q,X)});R(Q,M)}return v(n,Q.value),Q.value}}},r$=($)=>K($,n);var d="Store";class b$ extends Error{constructor($,J,Q){super(`Could not add ${$} key "${J}"${Q?` with value ${JSON.stringify(Q)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var n$=($,J)=>{let Q=L$($),X=L$(J);if(!Q||!X){let Z=!Object.is($,J);return{changed:Z,add:Z&&X?J:{},change:{},remove:Z&&Q?$:{}}}let H=new WeakSet,B={},N={},j={},D=Object.keys($),q=Object.keys(J),W=new Set([...D,...q]);for(let Z of W){let U=Z in $,F=Z in J;if(!U&&F){B[Z]=J[Z];continue}else if(U&&!F){j[Z]=void 0;continue}let m=$[Z],P=J[Z];if(!u(m,P,H))N[Z]=P}return{add:B,change:N,remove:j,changed:!!(Object.keys(B).length||Object.keys(N).length||Object.keys(j).length)}},w$=($,J)=>{I(d,$,b);let Q=new Map,X={value:$,sinks:null,sinksTail:null,stop:void 0},H=()=>{for(let W=X.sinks;W;W=W.nextSink)C(W.sink);if(_===0)V()},B=()=>{if(M){if(!X.sinks&&J?.watched)X.stop=J.watched();R(X,M)}},N=(W,Z)=>{if(I(`${d} for key "${W}"`,Z),Array.isArray(Z))Q.set(W,I$(Z));else if(b(Z))Q.set(W,w$(Z));else Q.set(W,r(Z))},j=()=>{let W={};return Q.forEach((Z,U)=>{W[U]=Z.get()}),W},D=(W)=>{for(let Z in W.add)N(Z,W.add[Z]);if(Object.keys(W.change).length)l(()=>{for(let Z in W.change){let U=W.change[Z];I(`${d} for key "${Z}"`,U);let F=Q.get(Z);if(F)if(b(U)!==f$(F))N(Z,U);else F.set(U)}});for(let Z in W.remove)Q.delete(Z);return W.changed};for(let W of Object.keys($))N(W,$[W]);let q={[Symbol.toStringTag]:d,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(Q.keys())){let Z=Q.get(W);if(Z)yield[W,Z]}},keys(){return B(),Q.keys()},byKey(W){return Q.get(W)},get(){return B(),j()},set(W){let Z=j();if(D(n$(Z,W)))H()},update(W){q.set(W(q.get()))},add(W,Z){if(Q.has(W))throw new b$(d,W,Z);return N(W,Z),H(),W},remove(W){if(Q.delete(W))H()}};return new Proxy(q,{get(W,Z){if(Z in W){let U=Reflect.get(W,Z);return E(U)?U.bind(W):U}if(!A$(Z))return W.byKey(Z)},has(W,Z){if(Z in W)return!0;return W.byKey(String(Z))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Z){if(Z in W)return Reflect.getOwnPropertyDescriptor(W,Z);if(A$(Z))return;let U=W.byKey(String(Z));return U?{enumerable:!0,configurable:!0,writable:!0,value:U}:void 0}})},f$=($)=>K($,d);export{s$ as match,u$ as isTask,f$ as isStore,v$ as isState,r$ as isSensor,o$ as isRef,c$ as isMemo,K$ as isList,T$ as isCollection,R$ as createTask,w$ as createStore,r as createState,i$ as createSensor,y$ as createScope,l$ as createRef,W$ as createMemo,I$ as createList,t$ as createEffect,Z$ as createCollection,l as batch,i as UnsetSignalValueError,Q$ as RequiredOwnerError,M$ as NullishSignalValueError,q$ as InvalidSignalValueError,F$ as InvalidCallbackError,o as CircularDependencyError};
