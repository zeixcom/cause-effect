function j$($){return typeof $==="string"}function m$($){return typeof $==="number"}function x$($){return typeof $==="symbol"}function O($){return typeof $==="function"}function k($){return O($)&&$.constructor.name==="AsyncFunction"}function o($){return O($)&&$.constructor.name!=="AsyncFunction"}function L$($){return $!=null&&typeof $==="object"}function C($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function _($){return C($,"Object")}function N$($){return _($)||Array.isArray($)}function Y$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function c$($){return $ instanceof DOMException&&$.name==="AbortError"}function G$($){return j$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class l extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class f$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class z$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class n extends TypeError{constructor($,J){super(`[${$}] Signal value ${G$(J)} is invalid`);this.name="InvalidSignalValueError"}}class O$ extends TypeError{constructor($,J){super(`[${$}] Callback ${G$(J)} is invalid`);this.name="InvalidCallbackError"}}class D$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class Q$ extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function P($,J,z){if(J==null)throw new f$($);if(z&&!z(J))throw new n($,J)}function a($,J){if(J==null)throw new z$($)}function f($,J,z=O){if(!z(J))throw new O$($,J)}var E="State",S="Memo",y="Task",t="Ref",v="Sensor",h="List",r="Collection",p="Store",b=0,P$=1,m=2,X$=4,j=null,T=null,K$=[],V=0,_$=!1;function c($,J){return $===J}function u$($,J){let z=J.sourcesTail;if(z){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===z)break;Q=Q.nextSource}}return!1}function F($,J){let z=J.sourcesTail;if(z?.source===$)return;let Q=null,q=J.flags&X$;if(q){if(Q=z?z.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let W=$.sinksTail;if(W?.sink===J&&(!q||u$(W,J)))return;let M={source:$,sink:J,nextSource:Q,prevSink:W,nextSink:null};if(J.sourcesTail=$.sinksTail=M,z)z.nextSource=M;else J.sources=M;if(W)W.nextSink=M;else $.sinks=M}function d$($){let{source:J,nextSource:z,nextSink:Q,prevSink:q}=$;if(Q)Q.prevSink=q;else J.sinksTail=q;if(q)q.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function Z$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=d$(z);if(J)J.nextSource=null;else $.sources=null}function L($,J=m){let z=$.flags;if("sinks"in $){if((z&(m|P$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)L(Q.sink,P$)}else{if(z&m)return;$.flags=m,K$.push($)}}function W$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)L(z.sink);if(V===0)Y()}function d($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function F$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function t$($){let J=j;j=$,$.sourcesTail=null,$.flags=X$;let z=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,z=!0}catch(Q){z=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{j=J,Z$($)}if(z){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&P$)Q.sink.flags|=m}$.flags=b}function r$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=j;j=$,$.sourcesTail=null,$.flags=X$;let Q;try{Q=$.fn($.value,J.signal)}catch(q){$.controller=void 0,$.error=q instanceof Error?q:Error(String(q));return}finally{j=z,Z$($)}Q.then((q)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(q,$.value)){$.value=q,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)L(W.sink);if(V===0)Y()}},(q)=>{if(J.signal.aborted)return;$.controller=void 0;let W=q instanceof Error?q:Error(String(q));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let M=$.sinks;M;M=M.nextSink)L(M.sink);if(V===0)Y()}}),$.flags=b}function b$($){F$($);let J=j,z=T;j=T=$,$.sourcesTail=null,$.flags=X$;try{let Q=$.fn();if(typeof Q==="function")d($,Q)}finally{j=J,T=z,Z$($)}$.flags=b}function w($){if($.flags&P$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)w(J.source);if($.flags&m)break}if($.flags&X$)throw new l("controller"in $?y:("value"in $)?S:"Effect");if($.flags&m)if("controller"in $)r$($);else if("value"in $)t$($);else b$($);else $.flags=b}function Y(){if(_$)return;_$=!0;try{for(let $=0;$<K$.length;$++){let J=K$[$];if(J.flags&m)w(J)}K$.length=0}finally{_$=!1}}function B$($){V++;try{$()}finally{if(V--,V===0)Y()}}function s($){let J=j;j=null;try{return $()}finally{j=J}}function s$($){let J=T,z={cleanup:null};T=z;try{let Q=$();if(typeof Q==="function")d(z,Q);let q=()=>F$(z);if(J)d(J,q);return q}finally{T=J}}function u($,J){P(E,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??c,guard:J?.guard};return{[Symbol.toStringTag]:E,get(){if(j)F(z,j);return z.value},set(Q){P(E,Q,z.guard),W$(z,Q)},update(Q){f(E,Q);let q=Q(z.value);P(E,q,z.guard),W$(z,q)}}}function w$($){return C($,E)}function g($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!L$($)||!L$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new l("isEqual");z.add($),z.add(J);try{let Q=Array.isArray($);if(Q!==Array.isArray(J))return!1;if(Q){let q=$,W=J;if(q.length!==W.length)return!1;for(let M=0;M<q.length;M++)if(!g(q[M],W[M],z))return!1;return!0}if(_($)&&_(J)){let q=Object.keys($),W=Object.keys(J);if(q.length!==W.length)return!1;for(let M of q){if(!(M in J))return!1;if(!g($[M],J[M],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function i$($,J,z,Q){let q=new WeakSet,W={},M={},R={},U=[],Z=!1,X=new Map;for(let x=0;x<$.length;x++){let I=z[x];if(I&&$[x])X.set(I,$[x])}let B=new Set;for(let x=0;x<J.length;x++){let I=J[x];if(I===void 0)continue;let K=z[x];if(!K)K=Q(I);if(U.push(K),B.add(K),!X.has(K))W[K]=I,Z=!0;else{let H=X.get(K);if(!g(H,I,q))M[K]=I,Z=!0}}for(let[x]of X)if(!B.has(x))R[x]=null,Z=!0;return{add:W,change:M,remove:R,newKeys:U,changed:Z}}function e($,J){P(h,$,Array.isArray);let z=new Map,Q=[],q=0,W=J?.keyConfig,M=j$(W)?()=>`${W}${q++}`:O(W)?(H)=>W(H):()=>String(q++),R=()=>Q.map((H)=>z.get(H)?.get()).filter((H)=>H!==void 0),U={fn:R,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:g,error:void 0},Z=()=>{U.sources=null,U.sourcesTail=null},X=(H,N)=>{P(`${h} item for key "${H}"`,N),z.set(H,u(N))},B=(H)=>{let N={};for(let D=0;D<H.length;D++){let G=H[D];if(G===void 0)continue;let A=Q[D];if(!A)A=M(G),Q[D]=A;N[A]=G}return N},x=(H)=>{let N=!1;for(let D in H.add)X(D,H.add[D]),N=!0;if(Object.keys(H.change).length)B$(()=>{for(let D in H.change){let G=H.change[D];P(`${h} item for key "${D}"`,G);let A=z.get(D);if(A)A.set(G)}});for(let D in H.remove){z.delete(D);let G=Q.indexOf(D);if(G!==-1)Q.splice(G,1);N=!0}if(N)Z();return H.changed},I=B($);for(let H in I)X(H,I[H]);U.value=$,U.flags=0;let K={[Symbol.toStringTag]:h,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of Q){let N=z.get(H);if(N)yield N}},get length(){if(j){if(!U.sinks&&J?.watched)U.stop=J.watched();F(U,j)}return Q.length},get(){if(j){if(!U.sinks&&J?.watched)U.stop=J.watched();F(U,j)}if(U.sources){if(U.flags)U.value=s(R),U.flags=b}else if(w(U),U.error)throw U.error;return U.value},set(H){let N=U.flags&m?R():U.value,D=i$(N,H,Q,M);if(D.changed){if(Q=D.newKeys,x(D),L(U),U.flags|=m,V===0)Y()}},update(H){K.set(H(K.get()))},at(H){return z.get(Q[H])},keys(){if(j){if(!U.sinks&&J?.watched)U.stop=J.watched();F(U,j)}return Q.values()},byKey(H){return z.get(H)},keyAt(H){return Q[H]},indexOfKey(H){return Q.indexOf(H)},add(H){let N=M(H);if(z.has(N))throw new Q$(h,N,H);if(!Q.includes(N))Q.push(N);if(X(N,H),Z(),L(U),U.flags|=m,V===0)Y();return N},remove(H){let N=m$(H)?Q[H]:H;if(z.delete(N)){let G=m$(H)?H:Q.indexOf(N);if(G>=0)Q.splice(G,1);if(Z(),L(U),U.flags|=m,V===0)Y()}},sort(H){let D=Q.map((G)=>[G,z.get(G)?.get()]).sort(O(H)?(G,A)=>H(G[1],A[1]):(G,A)=>String(G[1]).localeCompare(String(A[1]))).map(([G])=>G);if(!g(Q,D)){if(Q=D,L(U),U.flags|=m,V===0)Y()}},splice(H,N,...D){let G=Q.length,A=H<0?Math.max(0,G+H):Math.min(H,G),y$=Math.max(0,Math.min(N??Math.max(0,G-Math.max(0,A)),G-A)),C$={},M$={};for(let i=0;i<y$;i++){let q$=A+i,A$=Q[q$];if(A$){let p$=z.get(A$);if(p$)M$[A$]=p$.get()}}let V$=Q.slice(0,A);for(let i of D){let q$=M(i);V$.push(q$),C$[q$]=i}V$.push(...Q.slice(A+y$));let h$=!!(Object.keys(C$).length||Object.keys(M$).length);if(h$){if(x({add:C$,change:{},remove:M$,changed:h$}),Q=V$,L(U),U.flags|=m,V===0)Y()}return Object.values(M$)},deriveCollection(H){return I$(K,H)}};return K}function H$($){return C($,h)}function $$($,J){if(f(S,$,o),J?.value!==void 0)P(S,J.value,J?.guard);let z={fn:$,value:J?.value,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??c,error:void 0};return{[Symbol.toStringTag]:S,get(){if(j)F(z,j);if(w(z),z.error)throw z.error;return a(S,z.value),z.value}}}function T$($){return C($,S)}function J$($,J){if(f(y,$,k),J?.value!==void 0)P(y,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:m,equals:J?.equals??c,controller:void 0,error:void 0};return{[Symbol.toStringTag]:y,get(){if(j)F(z,j);if(w(z),z.error)throw z.error;return a(y,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function E$($){return C($,y)}function g$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function I$($,J){if(f(r,J),!o$($))throw TypeError(`[${r}] Invalid collection source: expected a List or Collection`);let z=k(J),Q=new Map,q=(X)=>{let B=z?J$(async(x,I)=>{let K=$.byKey(X)?.get();if(K==null)return x;return J(K,I)}):$$(()=>{let x=$.byKey(X)?.get();if(x==null)return;return J(x)});Q.set(X,B)};function W(){let X=Array.from($.keys()),B=M.value;if(!g$(B,X)){let x=new Set(B),I=new Set(X);for(let K of B)if(!I.has(K))Q.delete(K);for(let K of X)if(!x.has(K))q(K)}return X}let M={fn:W,value:[],flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:g$,error:void 0};function R(){if(M.sources){if(M.flags)M.value=s(W),M.flags=b}else if(w(M),M.error)throw M.error;return M.value}let U=Array.from($.keys());for(let X of U)q(X);M.value=U;let Z={[Symbol.toStringTag]:r,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of M.value){let B=Q.get(X);if(B)yield B}},get length(){if(j)F(M,j);return R().length},keys(){if(j)F(M,j);return R().values()},get(){if(j)F(M,j);return R().map((B)=>{try{return Q.get(B)?.get()}catch{return}}).filter((B)=>B!=null)},at(X){return Q.get(M.value[X])},byKey(X){return Q.get(X)},keyAt(X){return M.value[X]},indexOfKey(X){return M.value.indexOf(X)},deriveCollection(X){return I$(Z,X)}};return Z}function k$($){return C($,r)}function o$($){return H$($)||k$($)}function l$($){f("Effect",$);let J={fn:$,flags:m,sources:null,sourcesTail:null,cleanup:null},z=()=>{F$(J),J.fn=void 0,J.flags=b,J.sourcesTail=null,Z$(J)};if(T)d(T,z);return b$(J),z}function n$($,J){if(!T)throw new D$("match");let{ok:z,err:Q=console.error,nil:q}=J,W,M=!1,R=Array($.length);for(let Z=0;Z<$.length;Z++)try{R[Z]=$[Z].get()}catch(X){if(X instanceof z$){M=!0;continue}if(!W)W=[];W.push(X instanceof Error?X:Error(String(X)))}let U;try{if(M)U=q?.();else if(W)U=Q(W);else U=z(R)}catch(Z){Q([Z instanceof Error?Z:Error(String(Z))])}if(typeof U==="function")return U;if(U instanceof Promise){let Z=T,X=new AbortController;d(Z,()=>X.abort()),U.then((B)=>{if(!X.signal.aborted&&typeof B==="function")d(Z,B)}).catch((B)=>{Q([B instanceof Error?B:Error(String(B))])})}}function a$($,J){P(t,$),f(t,J,o);let z={value:$,sinks:null,sinksTail:null,stop:void 0};return{[Symbol.toStringTag]:t,get(){if(j){if(!z.sinks)z.stop=J(()=>{for(let Q=z.sinks;Q;Q=Q.nextSink)L(Q.sink);if(V===0)Y()});F(z,j)}return z.value}}}function e$($){return C($,t)}function $J($,J){if(f(v,$,o),J?.value!==void 0)P(v,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??c,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:v,get(){if(j){if(!z.sinks)z.stop=$((Q)=>{P("Sensor",Q,z.guard),W$(z,Q)});F(z,j)}return a(v,z.value),z.value}}}function JJ($){return C($,v)}function zJ($,J){let z=N$($),Q=N$(J);if(!z||!Q){let B=!Object.is($,J);return{changed:B,add:B&&Q?J:{},change:{},remove:B&&z?$:{}}}let q=new WeakSet,W={},M={},R={},U=!1,Z=Object.keys($),X=Object.keys(J);for(let B of X)if(B in $){if(!g($[B],J[B],q))M[B]=J[B],U=!0}else W[B]=J[B],U=!0;for(let B of Z)if(!(B in J))R[B]=void 0,U=!0;return{add:W,change:M,remove:R,changed:U}}function U$($,J){P(p,$,_);let z=new Map,Q=(Z,X)=>{if(P(`${p} for key "${Z}"`,X),Array.isArray(X))z.set(Z,e(X));else if(_(X))z.set(Z,U$(X));else z.set(Z,u(X))},q=()=>{let Z={};return z.forEach((X,B)=>{Z[B]=X.get()}),Z},W={fn:q,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:g,error:void 0},M=()=>{W.sources=null,W.sourcesTail=null},R=(Z)=>{let X=!1;for(let B in Z.add)Q(B,Z.add[B]),X=!0;if(Object.keys(Z.change).length)B$(()=>{for(let B in Z.change){let x=Z.change[B];P(`${p} for key "${B}"`,x);let I=z.get(B);if(I)if(_(x)!==R$(I))Q(B,x),X=!0;else I.set(x)}});for(let B in Z.remove)z.delete(B),X=!0;if(X)M();return Z.changed};for(let Z of Object.keys($))Q(Z,$[Z]);let U={[Symbol.toStringTag]:p,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Z of Array.from(z.keys())){let X=z.get(Z);if(X)yield[Z,X]}},keys(){if(j){if(!W.sinks&&J?.watched)W.stop=J.watched();F(W,j)}return z.keys()},byKey(Z){return z.get(Z)},get(){if(j){if(!W.sinks&&J?.watched)W.stop=J.watched();F(W,j)}if(W.sources){if(W.flags)W.value=s(q),W.flags=b}else if(w(W),W.error)throw W.error;return W.value},set(Z){let X=W.flags&m?q():W.value,B=zJ(X,Z);if(R(B)){if(L(W),W.flags|=m,V===0)Y()}},update(Z){U.set(Z(U.get()))},add(Z,X){if(z.has(Z))throw new Q$(p,Z,X);if(Q(Z,X),M(),L(W),W.flags|=m,V===0)Y();return Z},remove(Z){if(z.delete(Z)){if(M(),L(W),W.flags|=m,V===0)Y()}}};return new Proxy(U,{get(Z,X){if(X in Z){let B=Reflect.get(Z,X);return O(B)?B.bind(Z):B}if(!x$(X))return Z.byKey(X)},has(Z,X){if(X in Z)return!0;return Z.byKey(String(X))!==void 0},ownKeys(Z){return Array.from(Z.keys())},getOwnPropertyDescriptor(Z,X){if(X in Z)return Reflect.getOwnPropertyDescriptor(Z,X);if(x$(X))return;let B=Z.byKey(String(X));return B?{enumerable:!0,configurable:!0,writable:!0,value:B}:void 0}})}function R$($){return C($,p)}function QJ($,J){return k($)?J$($,J):$$($,J)}function XJ($){if(S$($))return $;if($==null)throw new n("createSignal",$);if(k($))return J$($);if(O($))return $$($);if(Y$($))return e($);if(_($))return U$($);return u($)}function ZJ($){if(v$($))return $;if($==null||O($)||S$($))throw new n("createMutableSignal",$);if(Y$($))return e($);if(_($))return U$($);return u($)}function WJ($){return T$($)||E$($)}function S$($){let J=[E,S,y,t,v,h,r,p],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function v$($){return w$($)||R$($)||H$($)}export{G$ as valueString,s as untrack,n$ as match,E$ as isTask,x$ as isSymbol,j$ as isString,R$ as isStore,w$ as isState,S$ as isSignal,JJ as isSensor,e$ as isRef,N$ as isRecordOrArray,_ as isRecord,C as isObjectOfType,m$ as isNumber,v$ as isMutableSignal,T$ as isMemo,H$ as isList,O as isFunction,g as isEqual,WJ as isComputed,k$ as isCollection,k as isAsyncFunction,c$ as isAbortError,J$ as createTask,U$ as createStore,u as createState,XJ as createSignal,$J as createSensor,s$ as createScope,a$ as createRef,ZJ as createMutableSignal,$$ as createMemo,e as createList,l$ as createEffect,QJ as createComputed,I$ as createCollection,B$ as batch,z$ as UnsetSignalValueError,D$ as RequiredOwnerError,f$ as NullishSignalValueError,n as InvalidSignalValueError,O$ as InvalidCallbackError,l as CircularDependencyError};
