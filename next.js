var L="State",y="Memo",M="Task",T=0;var V=2;var H=null,N=null,b=[],A=0,K=($,j)=>$===j,p=($)=>typeof $==="function",u=($,j)=>{let J=j.sourcesTail;if(J){let U=j.sources;while(U){if(U===$)return!0;if(U===J)break;U=U.nextSource}}return!1},R=($,j)=>{let J=j.sourcesTail;if(J?.source===$)return;let U=null,z=j.flags&4;if(z){if(U=J?J.nextSource:j.sources,U?.source===$){j.sourcesTail=U;return}}let B=$.sinksTail;if(B?.sink===j&&(!z||u(B,j)))return;let Q={source:$,sink:j,nextSource:U,prevSink:B,nextSink:null};if(j.sourcesTail=$.sinksTail=Q,J)J.nextSource=Q;else j.sources=Q;if(B)B.nextSink=Q;else $.sinks=Q},c=($)=>{let{source:j,nextSource:J,nextSink:U,prevSink:z}=$;if(U)U.prevSink=z;else j.sinksTail=z;if(z)z.nextSink=U;else j.sinks=U;if(!j.sinks&&j.stop)j.stop(),j.stop=void 0;return J},Y=($)=>{let j=$.sourcesTail,J=j?j.nextSource:$.sources;while(J)J=c(J);if(j)j.nextSource=null;else $.sources=null},D=($,j=2)=>{let J=$.flags;if("sinks"in $){if((J&3)>=j)return;if($.flags=J|j,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let U=$.sinks;U;U=U.nextSink)D(U.sink,1)}else{if(J&2)return;$.flags=2,b.push($)}},_=($,j)=>{if($.equals($.value,j))return;$.value=j;for(let J=$.sinks;J;J=J.nextSink)D(J.sink);if(A===0)x()},F=($,j)=>{if(!$.cleanup)$.cleanup=j;else if(Array.isArray($.cleanup))$.cleanup.push(j);else $.cleanup=[$.cleanup,j]},O=($)=>{if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let j=0;j<$.cleanup.length;j++)$.cleanup[j]();else $.cleanup();$.cleanup=null},l=($)=>{let j=H;H=$,$.sourcesTail=null,$.flags=4;let J=!1;try{let U=$.fn($.value);if($.error||!$.equals(U,$.value))$.value=U,$.error=void 0,J=!0}catch(U){J=!0,$.error=U instanceof Error?U:Error(String(U))}finally{H=j,Y($)}if(J){for(let U=$.sinks;U;U=U.nextSink)if(U.sink.flags&1)U.sink.flags|=2}$.flags=0},s=($)=>{$.controller?.abort();let j=new AbortController;$.controller=j,$.error=void 0;let J=H;H=$,$.sourcesTail=null,$.flags=4;let U;try{U=$.fn($.value,j.signal)}catch(z){$.controller=void 0,$.error=z instanceof Error?z:Error(String(z));return}finally{H=J,Y($)}U.then((z)=>{if(j.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(z,$.value)){$.value=z,$.error=void 0;for(let B=$.sinks;B;B=B.nextSink)D(B.sink)}},(z)=>{if(j.signal.aborted)return;$.controller=void 0;let B=z instanceof Error?z:Error(String(z));if(!$.error||B.name!==$.error.name||B.message!==$.error.message){$.error=B;for(let Q=$.sinks;Q;Q=Q.nextSink)D(Q.sink)}}),$.flags=0},C=($)=>{O($);let j=H,J=N;H=N=$,$.sourcesTail=null,$.flags=4;try{let U=$.fn();if(typeof U==="function")F($,U)}finally{H=j,N=J,Y($)}$.flags=0},I=($)=>{if($.flags&1)for(let j=$.sources;j;j=j.nextSource){if("fn"in j.source)I(j.source);if($.flags&2)break}if($.flags&4)throw new k("controller"in $?"Task":("value"in $)?"Memo":"Effect");if($.flags&2)if("controller"in $)s($);else if("value"in $)l($);else C($);else $.flags=0},x=()=>{for(let $=0;$<b.length;$++){let j=b[$];if(j.flags&2)I(j)}b.length=0},i=($)=>{A++;try{$()}finally{if(A--,A===0)x()}},d=($)=>{let j=N,J={cleanup:null};N=J;try{let U=$((B)=>F(J,B)),z=()=>O(J);if(j)F(j,z);return[U,z]}finally{N=j}},w=($)=>typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($),W=($,j,J)=>{if(j==null)throw new E($);if(J&&!J(j))throw new g($,j)},G=($,j,J=p)=>{if(!J(j))throw new S($,j)};class k extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class E extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class g extends TypeError{constructor($,j){super(`[${$}] Signal value ${w(j)} is invalid`);this.name="InvalidSignalValueError"}}class S extends TypeError{constructor($,j){super(`[${$}] Callback ${w(j)} is invalid`);this.name="InvalidCallbackError"}}var t=($)=>{G("Effect",$);let j={fn:$,flags:V,sources:null,sourcesTail:null,cleanup:null},J=()=>{O(j),j.fn=void 0,j.flags=T,j.sourcesTail=null,Y(j)};if(N)F(N,J);return C(j),J},r=($,j)=>{if(!N)throw Error("match() must be called inside an effect");let{ok:J,err:U=console.error,nil:z}=j,B,Q=!1,m=Array($.length);for(let X=0;X<$.length;X++)try{let Z=$[X].get();if(Z==null)Q=!0;else m[X]=Z}catch(Z){(B??=[]).push(Z instanceof Error?Z:Error(String(Z)))}let q;try{if(Q)q=z?.();else if(B)q=U(B);else q=J(m)}catch(X){U(X instanceof Error?X:Error(String(X)))}if(typeof q==="function")return q;if(q instanceof Promise){let X=new AbortController;F(N,()=>X.abort()),q.then((Z)=>{if(!X.signal.aborted&&N&&typeof Z==="function")F(N,Z)}).catch((Z)=>{U(Z instanceof Error?Z:Error(String(Z)))})}};var f=($)=>typeof $==="function",h=($)=>f($)&&$.constructor.name==="AsyncFunction",v=($)=>f($)&&$.constructor.name!=="AsyncFunction";var P=($,j)=>Object.prototype.toString.call($)===`[object ${j}]`;var a=($,j)=>{if(G(y,$,v),j?.value!==void 0)W(y,j.value,j?.guard);let J={fn:$,value:j?.value,flags:V,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:j?.equals??K,error:void 0};return{[Symbol.toStringTag]:y,get(){if(H)R(J,H);if(I(J),J.error)throw J.error;return J.value}}},o=($)=>P($,y);var n=($,j)=>{let J={value:$,sinks:null,sinksTail:null,stop:void 0},U=()=>{for(let B=J.sinks;B;B=B.nextSink)D(B.sink);if(A===0)x()};return{[Symbol.toStringTag]:y,get(){if(H){if(!J.sinks)J.stop=j(U);R(J,H)}return J.value}}};var e=($,j)=>{let J={value:void 0,sinks:null,sinksTail:null,equals:j?.equals??K,guard:j?.guard,stop:void 0},U=(B)=>{W("Sensor",B,J.guard),_(J,B)};return{[Symbol.toStringTag]:y,get(){if(H){if(!J.sinks)J.stop=$(U);R(J,H)}return J.value}}};var $$=($,j)=>{W(L,$,j?.guard);let J={value:$,sinks:null,sinksTail:null,equals:j?.equals??K,guard:j?.guard};return{[Symbol.toStringTag]:L,get(){if(H)R(J,H);return J.value},set(z){W(L,z,J.guard),_(J,z)},update(z){G(L,z);let B=z(J.value);W(L,B,J.guard),_(J,B)}}},j$=($)=>P($,L);var J$=($,j)=>{if(G(M,$,h),j?.value!==void 0)W(M,j.value,j?.guard);let J={fn:$,value:j?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:V,equals:j?.equals??K,controller:void 0,error:void 0};return{[Symbol.toStringTag]:M,get(){if(H)R(J,H);if(I(J),J.error)throw J.error;return J.value},isPending(){return!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}},U$=($)=>P($,M);export{r as match,U$ as isTask,j$ as isState,o as isMemo,J$ as createTask,$$ as createState,e as createSensor,d as createScope,n as createRef,a as createMemo,t as createEffect,i as batch};
