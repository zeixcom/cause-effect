var f="State",O="Memo",d="Task",K$=0;var g=2;var q=null,m=null,a=[],_=0,z$=!1,E=($,J)=>$===J,O$=($)=>typeof $==="function",E$=($,J)=>{let U=J.sourcesTail;if(U){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===U)break;Q=Q.nextSource}}return!1},I=($,J)=>{let U=J.sourcesTail;if(U?.source===$)return;let Q=null,z=J.flags&4;if(z){if(Q=U?U.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let G=$.sinksTail;if(G?.sink===J&&(!z||E$(G,J)))return;let H={source:$,sink:J,nextSource:Q,prevSink:G,nextSink:null};if(J.sourcesTail=$.sinksTail=H,U)U.nextSource=H;else J.sources=H;if(G)G.nextSink=H;else $.sinks=H},S$=($)=>{let{source:J,nextSource:U,nextSink:Q,prevSink:z}=$;if(Q)Q.prevSink=z;else J.sinksTail=z;if(z)z.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return U},l=($)=>{let J=$.sourcesTail,U=J?J.nextSource:$.sources;while(U)U=S$(U);if(J)J.nextSource=null;else $.sources=null},x=($,J=2)=>{let U=$.flags;if("sinks"in $){if((U&3)>=J)return;if($.flags=U|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)x(Q.sink,1)}else{if(U&2)return;$.flags=2,a.push($)}},r=($,J)=>{if($.equals($.value,J))return;$.value=J;for(let U=$.sinks;U;U=U.nextSink)x(U.sink);if(_===0)C()},S=($,J)=>{if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]},e=($)=>{if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null},f$=($)=>{let J=q;q=$,$.sourcesTail=null,$.flags=4;let U=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,U=!0}catch(Q){U=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{q=J,l($)}if(U){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&1)Q.sink.flags|=2}$.flags=0},b$=($)=>{$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let U=q;q=$,$.sourcesTail=null,$.flags=4;let Q;try{Q=$.fn($.value,J.signal)}catch(z){$.controller=void 0,$.error=z instanceof Error?z:Error(String(z));return}finally{q=U,l($)}Q.then((z)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(z,$.value)){$.value=z,$.error=void 0;for(let G=$.sinks;G;G=G.nextSink)x(G.sink);if(_===0)C()}},(z)=>{if(J.signal.aborted)return;$.controller=void 0;let G=z instanceof Error?z:Error(String(z));if(!$.error||G.name!==$.error.name||G.message!==$.error.message){$.error=G;for(let H=$.sinks;H;H=H.nextSink)x(H.sink);if(_===0)C()}}),$.flags=0},W$=($)=>{e($);let J=q,U=m;q=m=$,$.sourcesTail=null,$.flags=4;try{let Q=$.fn();if(typeof Q==="function")S($,Q)}finally{q=J,m=U,l($)}$.flags=0},y=($)=>{if($.flags&1)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)y(J.source);if($.flags&2)break}if($.flags&4)throw new p("controller"in $?"Task":("value"in $)?"Memo":"Effect");if($.flags&2)if("controller"in $)b$($);else if("value"in $)f$($);else W$($);else $.flags=0},C=()=>{if(z$)return;z$=!0;try{for(let $=0;$<a.length;$++){let J=a[$];if(J.flags&2)y(J)}a.length=0}finally{z$=!1}},s=($)=>{_++;try{$()}finally{if(_--,_===0)C()}},h$=($)=>{let J=m,U={cleanup:null};m=U;try{let Q=$((G)=>S(U,G)),z=()=>e(U);if(J)S(J,z);return[Q,z]}finally{m=J}},L$=($)=>typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($),L=($,J,U)=>{if(J==null)throw new P$($);if(U&&!U(J))throw new I$($,J)},T=($,J,U=O$)=>{if(!U(J))throw new Y$($,J)};class p extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class P$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class I$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${L$(J)} is invalid`);this.name="InvalidSignalValueError"}}class Y$ extends TypeError{constructor($,J){super(`[${$}] Callback ${L$(J)} is invalid`);this.name="InvalidCallbackError"}}var _$=($)=>typeof $==="string",G$=($)=>typeof $==="number",H$=($)=>typeof $==="symbol",b=($)=>typeof $==="function",$$=($)=>b($)&&$.constructor.name==="AsyncFunction",V$=($)=>b($)&&$.constructor.name!=="AsyncFunction",v=($)=>$!=null&&typeof $==="object",j=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,w=($)=>j($,"Object"),k=($)=>w($)||Array.isArray($);var i=($,J)=>{L(f,$,J?.guard);let U={value:$,sinks:null,sinksTail:null,equals:J?.equals??E,guard:J?.guard};return{[Symbol.toStringTag]:f,get(){if(q)I(U,q);return U.value},set(z){L(f,z,U.guard),r(U,z)},update(z){T(f,z);let G=z(U.value);L(f,G,U.guard),r(U,G)}}},g$=($)=>j($,f);var u="List";class j$ extends Error{constructor($,J,U){super(`Could not add ${$} key "${J}"${U?` with value ${JSON.stringify(U)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var t=($,J,U)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!v($)||!v(J))return!1;if(!U)U=new WeakSet;if(U.has($)||U.has(J))throw new p("isEqual");U.add($),U.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let Q=0;Q<$.length;Q++)if(!t($[Q],J[Q],U))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(w($)&&w(J)){let Q=Object.keys($),z=Object.keys(J);if(Q.length!==z.length)return!1;for(let G of Q){if(!(G in J))return!1;if(!t($[G],J[G],U))return!1}return!0}return!1}finally{U.delete($),U.delete(J)}},x$=($,J)=>{let U=k($),Q=k(J);if(!U||!Q){let Z=!Object.is($,J);return{changed:Z,add:Z&&Q?J:{},change:{},remove:Z&&U?$:{}}}let z=new WeakSet,G={},H={},A={},P=Object.keys($),M=Object.keys(J),B=new Set([...P,...M]);for(let Z of B){let W=Z in $,D=Z in J;if(!W&&D){G[Z]=J[Z];continue}else if(W&&!D){A[Z]=null;continue}let V=$[Z],K=J[Z];if(!t(V,K,z))H[Z]=K}return{add:G,change:H,remove:A,changed:!!(Object.keys(G).length||Object.keys(H).length||Object.keys(A).length)}},N$=($,J)=>{L(u,$,Array.isArray);let U=new Map,Q=[],z=0,G=J?.keyConfig,H=_$(G)?()=>`${G}${z++}`:b(G)?(X)=>G(X):()=>String(z++),A={value:$,sinks:null,sinksTail:null,stop:void 0},P=()=>{for(let X=A.sinks;X;X=X.nextSink)x(X.sink);if(_===0)C()},M=()=>{if(q){if(!A.sinks&&J?.watched)A.stop=J.watched();I(A,q)}},B=(X,N)=>{L(`${u} item for key "${X}"`,N),U.set(X,i(N))},Z=(X)=>{let N={};for(let R=0;R<X.length;R++){let F=X[R];if(F===void 0)continue;let Y=Q[R];if(!Y)Y=H(F),Q[R]=Y;N[Y]=F}return N},W=()=>{return Q.map((X)=>U.get(X)?.get()).filter((X)=>X!==void 0)},D=(X)=>{for(let N in X.add)B(N,X.add[N]);if(Object.keys(X.change).length)s(()=>{for(let N in X.change){let R=X.change[N];L(`${u} item for key "${N}"`,R);let F=U.get(N);if(F)F.set(R)}});for(let N in X.remove){U.delete(N);let R=Q.indexOf(N);if(R!==-1)Q.splice(R,1)}if(Object.keys(X.remove).length)Q=Q.filter(()=>!0);return X.changed},V=Z($);for(let X in V)B(X,V[X]);let K={[Symbol.toStringTag]:u,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of Q){let N=U.get(X);if(N)yield N}},get length(){return M(),Q.length},get(){return M(),W()},set(X){let N=W(),R=x$(Z(N),Z(X));if(D(R))P()},update(X){K.set(X(K.get()))},at(X){return U.get(Q[X])},keys(){return M(),Q.values()},byKey(X){return U.get(X)},keyAt(X){return Q[X]},indexOfKey(X){return Q.indexOf(X)},add(X){let N=H(X);if(U.has(N))throw new j$(u,N,X);if(!Q.includes(N))Q.push(N);return B(N,X),P(),N},remove(X){let N=G$(X)?Q[X]:X;if(U.delete(N)){let F=G$(X)?X:Q.indexOf(N);if(F>=0)Q.splice(F,1);Q=Q.filter(()=>!0),P()}},sort(X){let R=Q.map((F)=>[F,U.get(F)?.get()]).sort(b(X)?(F,Y)=>X(F[1],Y[1]):(F,Y)=>String(F[1]).localeCompare(String(Y[1]))).map(([F])=>F);if(!t(Q,R))Q=R,P()},splice(X,N,...R){let F=Q.length,Y=X<0?Math.max(0,F+X):Math.min(X,F),M$=Math.max(0,Math.min(N??Math.max(0,F-Math.max(0,Y)),F-Y)),Z$={},o={};for(let h=0;h<M$;h++){let n=Y+h,X$=Q[n];if(X$){let R$=U.get(X$);if(R$)o[X$]=R$.get()}}let B$=Q.slice(0,Y);for(let h of R){let n=H(h);B$.push(n),Z$[n]=h}B$.push(...Q.slice(Y+M$));let D$=!!(Object.keys(Z$).length||Object.keys(o).length);if(D$)D({add:Z$,change:{},remove:o,changed:D$}),Q=B$.filter(()=>!0),P();return Object.values(o)},deriveCollection(X){return J$(K,X)}};return K},q$=($)=>j($,u);var U$=($,J)=>{if(T(O,$,V$),J?.value!==void 0)L(O,J.value,J?.guard);let U={fn:$,value:J?.value,flags:g,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??E,error:void 0};return{[Symbol.toStringTag]:O,get(){if(q)I(U,q);if(y(U),U.error)throw U.error;return U.value}}},y$=($)=>j($,O);var F$=($,J)=>{if(T(d,$,$$),J?.value!==void 0)L(d,J.value,J?.guard);let U={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:g,equals:J?.equals??E,controller:void 0,error:void 0};return{[Symbol.toStringTag]:d,get(){if(q)I(U,q);if(y(U),U.error)throw U.error;return U.value},isPending(){return!U.controller},abort(){U.controller?.abort(),U.controller=void 0}}},p$=($)=>j($,d);var Q$="Collection";function J$($,J){if(T(Q$,J),!v$($))throw TypeError(`[${Q$}] Invalid collection source: expected a List or Collection`);let U=$$(J),Q=new Map,z=[],G={value:[],sinks:null,sinksTail:null,stop:void 0},H=()=>{for(let W=G.sinks;W;W=W.nextSink)x(W.sink);if(_===0)C()},A=()=>{if(q)I(G,q)},P=(W)=>{let D=U?F$(async(V,K)=>{let X=$.byKey(W)?.get();if(X==null)return V;return J(X,K)}):U$(()=>{let V=$.byKey(W)?.get();if(V==null)return;return J(V)});Q.set(W,D)},M=U$(()=>{return Array.from($.keys())}),B=()=>{let W=M.get(),D=new Set(z),V=new Set(W),K=!1;for(let X of z)if(!V.has(X))Q.delete(X),K=!0;for(let X of W)if(!D.has(X))P(X),K=!0;if(!K&&z.length===W.length){for(let X=0;X<z.length;X++)if(z[X]!==W[X]){K=!0;break}}if(z=W,K)H()};for(let W of Array.from($.keys()))P(W),z.push(W);let Z={[Symbol.toStringTag]:Q$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let W of z){let D=Q.get(W);if(D)yield D}},get length(){return A(),B(),z.length},keys(){return A(),B(),z.values()},get(){return A(),B(),z.map((W)=>{try{return Q.get(W)?.get()}catch{return}}).filter((W)=>W!=null)},at(W){return Q.get(z[W])},byKey(W){return Q.get(W)},keyAt(W){return z[W]},indexOfKey(W){return z.indexOf(W)},deriveCollection(W){return J$(Z,W)}};return Z}var C$=($)=>j($,Q$),v$=($)=>q$($)||C$($);var k$=($)=>{T("Effect",$);let J={fn:$,flags:g,sources:null,sourcesTail:null,cleanup:null},U=()=>{e(J),J.fn=void 0,J.flags=K$,J.sourcesTail=null,l(J)};if(m)S(m,U);return W$(J),U},u$=($,J)=>{if(!m)throw Error("match() must be called inside an effect");let U=m,{ok:Q,err:z=console.error,nil:G}=J,H,A=!1,P=Array($.length);for(let B=0;B<$.length;B++)try{let Z=$[B].get();if(Z==null)A=!0;else P[B]=Z}catch(Z){if(!H)H=[];H.push(Z instanceof Error?Z:Error(String(Z)))}let M;try{if(A)M=G?.();else if(H)M=z(H);else M=Q(P)}catch(B){z([B instanceof Error?B:Error(String(B))])}if(typeof M==="function")return M;if(M instanceof Promise){let B=new AbortController;S(U,()=>B.abort()),M.then((Z)=>{if(!B.signal.aborted&&typeof Z==="function")S(U,Z)}).catch((Z)=>{z([Z instanceof Error?Z:Error(String(Z))])})}};var c$=($,J)=>{let U={value:$,sinks:null,sinksTail:null,stop:void 0},Q=()=>{for(let G=U.sinks;G;G=G.nextSink)x(G.sink);if(_===0)C()};return{[Symbol.toStringTag]:O,get(){if(q){if(!U.sinks)U.stop=J(Q);I(U,q)}return U.value}}};var d$=($,J)=>{let U={value:void 0,sinks:null,sinksTail:null,equals:J?.equals??E,guard:J?.guard,stop:void 0},Q=(G)=>{L("Sensor",G,U.guard),r(U,G)};return{[Symbol.toStringTag]:O,get(){if(q){if(!U.sinks)U.stop=$(Q);I(U,q)}return U.value}}};var c="Store";class m$ extends Error{constructor($,J,U){super(`Could not add ${$} key "${J}"${U?` with value ${JSON.stringify(U)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var A$=($,J,U)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!v($)||!v(J))return!1;if(!U)U=new WeakSet;if(U.has($)||U.has(J))throw new p("isEqual");U.add($),U.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let Q=0;Q<$.length;Q++)if(!A$($[Q],J[Q],U))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(w($)&&w(J)){let Q=Object.keys($),z=Object.keys(J);if(Q.length!==z.length)return!1;for(let G of Q){if(!(G in J))return!1;if(!A$($[G],J[G],U))return!1}return!0}return!1}finally{U.delete($),U.delete(J)}},l$=($,J)=>{let U=k($),Q=k(J);if(!U||!Q){let Z=!Object.is($,J);return{changed:Z,add:Z&&Q?J:{},change:{},remove:Z&&U?$:{}}}let z=new WeakSet,G={},H={},A={},P=Object.keys($),M=Object.keys(J),B=new Set([...P,...M]);for(let Z of B){let W=Z in $,D=Z in J;if(!W&&D){G[Z]=J[Z];continue}else if(W&&!D){A[Z]=null;continue}let V=$[Z],K=J[Z];if(!A$(V,K,z))H[Z]=K}return{add:G,change:H,remove:A,changed:!!(Object.keys(G).length||Object.keys(H).length||Object.keys(A).length)}},T$=($,J)=>{L(c,$,w);let U=new Map,Q={value:$,sinks:null,sinksTail:null,stop:void 0},z=()=>{for(let B=Q.sinks;B;B=B.nextSink)x(B.sink);if(_===0)C()},G=()=>{if(q){if(!Q.sinks&&J?.watched)Q.stop=J.watched();I(Q,q)}},H=(B,Z)=>{if(L(`${c} for key "${B}"`,Z),Array.isArray(Z))U.set(B,N$(Z));else if(w(Z))U.set(B,T$(Z));else U.set(B,i(Z))},A=()=>{let B={};return U.forEach((Z,W)=>{B[W]=Z.get()}),B},P=(B)=>{for(let Z in B.add)H(Z,B.add[Z]);if(Object.keys(B.change).length)s(()=>{for(let Z in B.change){let W=B.change[Z];L(`${c} for key "${Z}"`,W);let D=U.get(Z);if(D)if(w(W)!==w$(D))H(Z,W);else D.set(W)}});for(let Z in B.remove)U.delete(Z);return B.changed};for(let B of Object.keys($))H(B,$[B]);let M={[Symbol.toStringTag]:c,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let B of Array.from(U.keys())){let Z=U.get(B);if(Z)yield[B,Z]}},keys(){return G(),U.keys()},byKey(B){return U.get(B)},get(){return G(),A()},set(B){let Z=A();if(P(l$(Z,B)))z()},update(B){M.set(B(M.get()))},add(B,Z){if(U.has(B))throw new m$(c,B,Z);return H(B,Z),z(),B},remove(B){if(U.delete(B))z()}};return new Proxy(M,{get(B,Z){if(Z in B){let W=Reflect.get(B,Z);return b(W)?W.bind(B):W}if(!H$(Z))return B.byKey(Z)},has(B,Z){if(Z in B)return!0;return B.byKey(String(Z))!==void 0},ownKeys(B){return Array.from(B.keys())},getOwnPropertyDescriptor(B,Z){if(Z in B)return Reflect.getOwnPropertyDescriptor(B,Z);if(H$(Z))return;let W=B.byKey(String(Z));return W?{enumerable:!0,configurable:!0,writable:!0,value:W}:void 0}})},w$=($)=>j($,c);export{u$ as match,p$ as isTask,w$ as isStore,g$ as isState,y$ as isMemo,q$ as isList,t as isEqual,C$ as isCollection,x$ as diff,F$ as createTask,T$ as createStore,i as createState,d$ as createSensor,h$ as createScope,c$ as createRef,U$ as createMemo,N$ as createList,k$ as createEffect,J$ as createCollection,s as batch};
