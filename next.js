var S="State",p="Memo",y="Task",v=0;var m=2;var N=null,O=null,$$=[],A=0,G$=!1,T=($,J)=>$===J,E$=($)=>typeof $==="function",S$=($,J)=>{let H=J.sourcesTail;if(H){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===H)break;Q=Q.nextSource}}return!1},I=($,J)=>{let H=J.sourcesTail;if(H?.source===$)return;let Q=null,W=J.flags&4;if(W){if(Q=H?H.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let z=$.sinksTail;if(z?.sink===J&&(!W||S$(z,J)))return;let q={source:$,sink:J,nextSource:Q,prevSink:z,nextSink:null};if(J.sourcesTail=$.sinksTail=q,H)H.nextSource=q;else J.sources=q;if(z)z.nextSink=q;else $.sinks=q},h$=($)=>{let{source:J,nextSource:H,nextSink:Q,prevSink:W}=$;if(Q)Q.prevSink=W;else J.sinksTail=W;if(W)W.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return H},s=($)=>{let J=$.sourcesTail,H=J?J.nextSource:$.sources;while(H)H=h$(H);if(J)J.nextSource=null;else $.sources=null},x=($,J=2)=>{let H=$.flags;if("sinks"in $){if((H&3)>=J)return;if($.flags=H|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)x(Q.sink,1)}else{if(H&2)return;$.flags=2,$$.push($)}},t=($,J)=>{if($.equals($.value,J))return;$.value=J;for(let H=$.sinks;H;H=H.nextSink)x(H.sink);if(A===0)Y()},E=($,J)=>{if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]},J$=($)=>{if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null},g$=($)=>{let J=N;N=$,$.sourcesTail=null,$.flags=4;let H=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,H=!0}catch(Q){H=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{N=J,s($)}if(H){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&1)Q.sink.flags|=2}$.flags=0},p$=($)=>{$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let H=N;N=$,$.sourcesTail=null,$.flags=4;let Q;try{Q=$.fn($.value,J.signal)}catch(W){$.controller=void 0,$.error=W instanceof Error?W:Error(String(W));return}finally{N=H,s($)}Q.then((W)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(W,$.value)){$.value=W,$.error=void 0;for(let z=$.sinks;z;z=z.nextSink)x(z.sink);if(A===0)Y()}},(W)=>{if(J.signal.aborted)return;$.controller=void 0;let z=W instanceof Error?W:Error(String(W));if(!$.error||z.name!==$.error.name||z.message!==$.error.message){$.error=z;for(let q=$.sinks;q;q=q.nextSink)x(q.sink);if(A===0)Y()}}),$.flags=0},N$=($)=>{J$($);let J=N,H=O;N=O=$,$.sourcesTail=null,$.flags=4;try{let Q=$.fn();if(typeof Q==="function")E($,Q)}finally{N=J,O=H,s($)}$.flags=0},w=($)=>{if($.flags&1)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)w(J.source);if($.flags&2)break}if($.flags&4)throw new i("controller"in $?"Task":("value"in $)?"Memo":"Effect");if($.flags&2)if("controller"in $)p$($);else if("value"in $)g$($);else N$($);else $.flags=0},Y=()=>{if(G$)return;G$=!0;try{for(let $=0;$<$$.length;$++){let J=$$[$];if(J.flags&2)w(J)}$$.length=0}finally{G$=!1}},l=($)=>{A++;try{$()}finally{if(A--,A===0)Y()}},H$=($)=>{let J=N;N=null;try{return $()}finally{N=J}},y$=($)=>{let J=O,H={cleanup:null};O=H;try{let Q=$();if(typeof Q==="function")E(H,Q);let W=()=>J$(H);if(J)E(J,W);return W}finally{O=J}},_$=($)=>typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);function L($,J,H){if(J==null)throw new q$($);if(H&&!H(J))throw new j$($,J)}function k($,J){if(J==null)throw new r($)}function V($,J,H=E$){if(!H(J))throw new F$($,J)}class i extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class q$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class r extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class j$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${_$(J)} is invalid`);this.name="InvalidSignalValueError"}}class F$ extends TypeError{constructor($,J){super(`[${$}] Callback ${_$(J)} is invalid`);this.name="InvalidCallbackError"}}class Q$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}var C$=($)=>typeof $==="string",K$=($)=>typeof $==="number",D$=($)=>typeof $==="symbol",h=($)=>typeof $==="function",X$=($)=>h($)&&$.constructor.name==="AsyncFunction",c=($)=>h($)&&$.constructor.name!=="AsyncFunction",L$=($)=>$!=null&&typeof $==="object",C=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,b=($)=>C($,"Object"),P$=($)=>b($)||Array.isArray($);var o=($,J)=>{L(S,$,J?.guard);let H={value:$,sinks:null,sinksTail:null,equals:J?.equals??T,guard:J?.guard};return{[Symbol.toStringTag]:S,get(){if(N)I(H,N);return H.value},set(W){L(S,W,H.guard),t(H,W)},update(W){V(S,W);let z=W(H.value);L(S,z,H.guard),t(H,z)}}},v$=($)=>C($,S);var u="List";class V$ extends Error{constructor($,J,H){super(`Could not add ${$} key "${J}"${H?` with value ${JSON.stringify(H)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var f=($,J,H)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!L$($)||!L$(J))return!1;if(!H)H=new WeakSet;if(H.has($)||H.has(J))throw new i("isEqual");H.add($),H.add(J);try{let Q=Array.isArray($);if(Q!==Array.isArray(J))return!1;if(Q){let W=$,z=J;if(W.length!==z.length)return!1;for(let q=0;q<W.length;q++)if(!f(W[q],z[q],H))return!1;return!0}if(b($)&&b(J)){let W=Object.keys($),z=Object.keys(J);if(W.length!==z.length)return!1;for(let q of W){if(!(q in J))return!1;if(!f($[q],J[q],H))return!1}return!0}return!1}finally{H.delete($),H.delete(J)}},k$=($,J,H,Q)=>{let W=new WeakSet,z={},q={},R={},B=[],X=!1,U=new Map;for(let M=0;M<$.length;M++){let D=H[M];if(D&&$[M])U.set(D,$[M])}let G=new Set;for(let M=0;M<J.length;M++){let D=J[M];if(D===void 0)continue;let P=H[M];if(!P)P=Q(D);if(B.push(P),G.add(P),!U.has(P))z[P]=D,X=!0;else{let Z=U.get(P);if(!f(Z,D,W))q[P]=D,X=!0}}for(let[M]of U)if(!G.has(M))R[M]=null,X=!0;return{add:z,change:q,remove:R,newKeys:B,changed:X}},A$=($,J)=>{L(u,$,Array.isArray);let H=new Map,Q=[],W=0,z=J?.keyConfig,q=C$(z)?()=>`${z}${W++}`:h(z)?(Z)=>z(Z):()=>String(W++),R=()=>Q.map((Z)=>H.get(Z)?.get()).filter((Z)=>Z!==void 0),B={fn:R,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:f,error:void 0},X=()=>{B.sources=null,B.sourcesTail=null},U=(Z,j)=>{L(`${u} item for key "${Z}"`,j),H.set(Z,o(j))},G=(Z)=>{let j={};for(let K=0;K<Z.length;K++){let F=Z[K];if(F===void 0)continue;let _=Q[K];if(!_)_=q(F),Q[K]=_;j[_]=F}return j},M=(Z)=>{let j=!1;for(let K in Z.add)U(K,Z.add[K]),j=!0;if(Object.keys(Z.change).length)l(()=>{for(let K in Z.change){let F=Z.change[K];L(`${u} item for key "${K}"`,F);let _=H.get(K);if(_)_.set(F)}});for(let K in Z.remove){H.delete(K);let F=Q.indexOf(K);if(F!==-1)Q.splice(F,1);j=!0}if(j)X();return Z.changed},D=G($);for(let Z in D)U(Z,D[Z]);B.value=$,B.flags=0;let P={[Symbol.toStringTag]:u,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of Q){let j=H.get(Z);if(j)yield j}},get length(){if(N){if(!B.sinks&&J?.watched)B.stop=J.watched();I(B,N)}return Q.length},get(){if(N){if(!B.sinks&&J?.watched)B.stop=J.watched();I(B,N)}if(B.sources){if(B.flags)B.value=H$(R),B.flags=v}else if(w(B),B.error)throw B.error;return B.value},set(Z){let j=B.flags&m?R():B.value,K=k$(j,Z,Q,q);if(K.changed){if(Q=K.newKeys,M(K),x(B),B.flags|=m,A===0)Y()}},update(Z){P.set(Z(P.get()))},at(Z){return H.get(Q[Z])},keys(){if(N){if(!B.sinks&&J?.watched)B.stop=J.watched();I(B,N)}return Q.values()},byKey(Z){return H.get(Z)},keyAt(Z){return Q[Z]},indexOfKey(Z){return Q.indexOf(Z)},add(Z){let j=q(Z);if(H.has(j))throw new V$(u,j,Z);if(!Q.includes(j))Q.push(j);if(U(j,Z),X(),x(B),B.flags|=m,A===0)Y();return j},remove(Z){let j=K$(Z)?Q[Z]:Z;if(H.delete(j)){let F=K$(Z)?Z:Q.indexOf(j);if(F>=0)Q.splice(F,1);if(X(),x(B),B.flags|=m,A===0)Y()}},sort(Z){let K=Q.map((F)=>[F,H.get(F)?.get()]).sort(h(Z)?(F,_)=>Z(F[1],_[1]):(F,_)=>String(F[1]).localeCompare(String(_[1]))).map(([F])=>F);if(!f(Q,K)){if(Q=K,x(B),B.flags|=m,A===0)Y()}},splice(Z,j,...K){let F=Q.length,_=Z<0?Math.max(0,F+Z):Math.min(Z,F),R$=Math.max(0,Math.min(j??Math.max(0,F-Math.max(0,_)),F-_)),U$={},a={};for(let g=0;g<R$;g++){let e=_+g,M$=Q[e];if(M$){let Y$=H.get(M$);if(Y$)a[M$]=Y$.get()}}let B$=Q.slice(0,_);for(let g of K){let e=q(g);B$.push(e),U$[e]=g}B$.push(...Q.slice(_+R$));let x$=!!(Object.keys(U$).length||Object.keys(a).length);if(x$){if(M({add:U$,change:{},remove:a,changed:x$}),Q=B$,x(B),B.flags|=m,A===0)Y()}return Object.values(a)},deriveCollection(Z){return Z$(P,Z)}};return P},m$=($)=>C($,u);function z$($,J){if(V(p,$,c),J?.value!==void 0)L(p,J.value,J?.guard);let H={fn:$,value:J?.value,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??T,error:void 0};return{[Symbol.toStringTag]:p,get(){if(N)I(H,N);if(w(H),H.error)throw H.error;return k(p,H.value),H.value}}}var c$=($)=>C($,p);function I$($,J){if(V(y,$,X$),J?.value!==void 0)L(y,J.value,J?.guard);let H={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:m,equals:J?.equals??T,controller:void 0,error:void 0};return{[Symbol.toStringTag]:y,get(){if(N)I(H,N);if(w(H),H.error)throw H.error;return k(y,H.value),H.value},isPending(){return!!H.controller},abort(){H.controller?.abort(),H.controller=void 0}}}var u$=($)=>C($,y);var W$="Collection";function Z$($,J){if(V(W$,J),!d$($))throw TypeError(`[${W$}] Invalid collection source: expected a List or Collection`);let H=X$(J),Q=new Map,W=[],z={value:[],sinks:null,sinksTail:null,stop:void 0},q=()=>{for(let M=z.sinks;M;M=M.nextSink)x(M.sink);if(A===0)Y()},R=()=>{if(N)I(z,N)},B=(M)=>{let D=H?I$(async(P,Z)=>{let j=$.byKey(M)?.get();if(j==null)return P;return J(j,Z)}):z$(()=>{let P=$.byKey(M)?.get();if(P==null)return;return J(P)});Q.set(M,D)},X=z$(()=>{return Array.from($.keys())}),U=()=>{let M=X.get();if(W.length===M.length){let Z=!1;for(let j=0;j<W.length;j++)if(W[j]!==M[j]){Z=!0;break}if(!Z)return}let D=new Set(W),P=new Set(M);for(let Z of W)if(!P.has(Z))Q.delete(Z);for(let Z of M)if(!D.has(Z))B(Z);W=M,q()};for(let M of Array.from($.keys()))B(M),W.push(M);let G={[Symbol.toStringTag]:W$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let M of W){let D=Q.get(M);if(D)yield D}},get length(){return R(),U(),W.length},keys(){return R(),U(),W.values()},get(){return R(),U(),W.map((M)=>{try{return Q.get(M)?.get()}catch{return}}).filter((M)=>M!=null)},at(M){return Q.get(W[M])},byKey(M){return Q.get(M)},keyAt(M){return W[M]},indexOfKey(M){return W.indexOf(M)},deriveCollection(M){return Z$(G,M)}};return G}var O$=($)=>C($,W$),d$=($)=>m$($)||O$($);var s$=($)=>{V("Effect",$);let J={fn:$,flags:m,sources:null,sourcesTail:null,cleanup:null},H=()=>{J$(J),J.fn=void 0,J.flags=v,J.sourcesTail=null,s(J)};if(O)E(O,H);return N$(J),H},t$=($,J)=>{if(!O)throw new Q$("match");let{ok:H,err:Q=console.error,nil:W}=J,z,q=!1,R=Array($.length);for(let X=0;X<$.length;X++)try{let U=$[X].get();if(U==null)q=!0;else R[X]=U}catch(U){if(U instanceof r){q=!0;continue}if(!z)z=[];z.push(U instanceof Error?U:Error(String(U)))}let B;try{if(q)B=W?.();else if(z)B=Q(z);else B=H(R)}catch(X){Q([X instanceof Error?X:Error(String(X))])}if(typeof B==="function")return B;if(B instanceof Promise){let X=O,U=new AbortController;E(X,()=>U.abort()),B.then((G)=>{if(!U.signal.aborted&&typeof G==="function")E(X,G)}).catch((G)=>{Q([G instanceof Error?G:Error(String(G))])})}};var w$="Ref",l$=($,J)=>{L("Ref",$),V("Ref",J,c);let H={value:$,sinks:null,sinksTail:null,stop:void 0};return{[Symbol.toStringTag]:w$,get(){if(N){if(!H.sinks)H.stop=J(()=>{for(let Q=H.sinks;Q;Q=Q.nextSink)x(Q.sink);if(A===0)Y()});I(H,N)}return H.value}}},i$=($)=>C($,w$);var n="Sensor",r$=($,J)=>{if(V(n,$,c),J?.value!==void 0)L(n,J.value,J?.guard);let H={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??T,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:n,get(){if(N){if(!H.sinks)H.stop=$((Q)=>{L("Sensor",Q,H.guard),t(H,Q)});I(H,N)}return k(n,H.value),H.value}}},o$=($)=>C($,n);var d="Store";class T$ extends Error{constructor($,J,H){super(`Could not add ${$} key "${J}"${H?` with value ${JSON.stringify(H)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var n$=($,J)=>{let H=P$($),Q=P$(J);if(!H||!Q){let G=!Object.is($,J);return{changed:G,add:G&&Q?J:{},change:{},remove:G&&H?$:{}}}let W=new WeakSet,z={},q={},R={},B=!1,X=Object.keys($),U=Object.keys(J);for(let G of U)if(G in $){if(!f($[G],J[G],W))q[G]=J[G],B=!0}else z[G]=J[G],B=!0;for(let G of X)if(!(G in J))R[G]=void 0,B=!0;return{add:z,change:q,remove:R,changed:B}},b$=($,J)=>{L(d,$,b);let H=new Map,Q=(X,U)=>{if(L(`${d} for key "${X}"`,U),Array.isArray(U))H.set(X,A$(U));else if(b(U))H.set(X,b$(U));else H.set(X,o(U))},W=()=>{let X={};return H.forEach((U,G)=>{X[G]=U.get()}),X},z={fn:W,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:f,error:void 0},q=()=>{z.sources=null,z.sourcesTail=null},R=(X)=>{let U=!1;for(let G in X.add)Q(G,X.add[G]),U=!0;if(Object.keys(X.change).length)l(()=>{for(let G in X.change){let M=X.change[G];L(`${d} for key "${G}"`,M);let D=H.get(G);if(D)if(b(M)!==f$(D))Q(G,M),U=!0;else D.set(M)}});for(let G in X.remove)H.delete(G),U=!0;if(U)q();return X.changed};for(let X of Object.keys($))Q(X,$[X]);let B={[Symbol.toStringTag]:d,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let X of Array.from(H.keys())){let U=H.get(X);if(U)yield[X,U]}},keys(){if(N){if(!z.sinks&&J?.watched)z.stop=J.watched();I(z,N)}return H.keys()},byKey(X){return H.get(X)},get(){if(N){if(!z.sinks&&J?.watched)z.stop=J.watched();I(z,N)}if(z.sources){if(z.flags)z.value=H$(W),z.flags=v}else if(w(z),z.error)throw z.error;return z.value},set(X){let U=z.flags&m?W():z.value,G=n$(U,X);if(R(G)){if(x(z),z.flags|=m,A===0)Y()}},update(X){B.set(X(B.get()))},add(X,U){if(H.has(X))throw new T$(d,X,U);if(Q(X,U),q(),x(z),z.flags|=m,A===0)Y();return X},remove(X){if(H.delete(X)){if(q(),x(z),z.flags|=m,A===0)Y()}}};return new Proxy(B,{get(X,U){if(U in X){let G=Reflect.get(X,U);return h(G)?G.bind(X):G}if(!D$(U))return X.byKey(U)},has(X,U){if(U in X)return!0;return X.byKey(String(U))!==void 0},ownKeys(X){return Array.from(X.keys())},getOwnPropertyDescriptor(X,U){if(U in X)return Reflect.getOwnPropertyDescriptor(X,U);if(D$(U))return;let G=X.byKey(String(U));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},f$=($)=>C($,d);export{t$ as match,u$ as isTask,f$ as isStore,v$ as isState,o$ as isSensor,i$ as isRef,c$ as isMemo,m$ as isList,O$ as isCollection,I$ as createTask,b$ as createStore,o as createState,r$ as createSensor,y$ as createScope,l$ as createRef,z$ as createMemo,A$ as createList,s$ as createEffect,Z$ as createCollection,l as batch,r as UnsetSignalValueError,Q$ as RequiredOwnerError,q$ as NullishSignalValueError,j$ as InvalidSignalValueError,F$ as InvalidCallbackError,i as CircularDependencyError};
