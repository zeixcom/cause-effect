var b="State",y="Memo",v="Task",K$=0;var E=2;var G=null,Y=null,r=[],T=0,Q$=!1,f=($,U)=>$===U,_$=($)=>typeof $==="function",y$=($,U)=>{let J=U.sourcesTail;if(J){let R=U.sources;while(R){if(R===$)return!0;if(R===J)break;R=R.nextSource}}return!1},D=($,U)=>{let J=U.sourcesTail;if(J?.source===$)return;let R=null,X=U.flags&4;if(X){if(R=J?J.nextSource:U.sources,R?.source===$){U.sourcesTail=R;return}}let W=$.sinksTail;if(W?.sink===U&&(!X||y$(W,U)))return;let N={source:$,sink:U,nextSource:R,prevSink:W,nextSink:null};if(U.sourcesTail=$.sinksTail=N,J)J.nextSource=N;else U.sources=N;if(W)W.nextSink=N;else $.sinks=N},f$=($)=>{let{source:U,nextSource:J,nextSink:R,prevSink:X}=$;if(R)R.prevSink=X;else U.sinksTail=X;if(X)X.nextSink=R;else U.sinks=R;if(!U.sinks&&U.stop)U.stop(),U.stop=void 0;return J},u=($)=>{let U=$.sourcesTail,J=U?U.nextSource:$.sources;while(J)J=f$(J);if(U)U.nextSource=null;else $.sources=null},C=($,U=2)=>{let J=$.flags;if("sinks"in $){if((J&3)>=U)return;if($.flags=J|U,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let R=$.sinks;R;R=R.nextSink)C(R.sink,1)}else{if(J&2)return;$.flags=2,r.push($)}},c=($,U)=>{if($.equals($.value,U))return;$.value=U;for(let J=$.sinks;J;J=J.nextSink)C(J.sink);if(T===0)P()},O=($,U)=>{if(!$.cleanup)$.cleanup=U;else if(Array.isArray($.cleanup))$.cleanup.push(U);else $.cleanup=[$.cleanup,U]},o=($)=>{if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let U=0;U<$.cleanup.length;U++)$.cleanup[U]();else $.cleanup();$.cleanup=null},O$=($)=>{let U=G;G=$,$.sourcesTail=null,$.flags=4;let J=!1;try{let R=$.fn($.value);if($.error||!$.equals(R,$.value))$.value=R,$.error=void 0,J=!0}catch(R){J=!0,$.error=R instanceof Error?R:Error(String(R))}finally{G=U,u($)}if(J){for(let R=$.sinks;R;R=R.nextSink)if(R.sink.flags&1)R.sink.flags|=2}$.flags=0},b$=($)=>{$.controller?.abort();let U=new AbortController;$.controller=U,$.error=void 0;let J=G;G=$,$.sourcesTail=null,$.flags=4;let R;try{R=$.fn($.value,U.signal)}catch(X){$.controller=void 0,$.error=X instanceof Error?X:Error(String(X));return}finally{G=J,u($)}R.then((X)=>{if(U.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(X,$.value)){$.value=X,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)C(W.sink);if(T===0)P()}},(X)=>{if(U.signal.aborted)return;$.controller=void 0;let W=X instanceof Error?X:Error(String(X));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let N=$.sinks;N;N=N.nextSink)C(N.sink);if(T===0)P()}}),$.flags=0},Z$=($)=>{o($);let U=G,J=Y;G=Y=$,$.sourcesTail=null,$.flags=4;try{let R=$.fn();if(typeof R==="function")O($,R)}finally{G=U,Y=J,u($)}$.flags=0},h=($)=>{if($.flags&1)for(let U=$.sources;U;U=U.nextSource){if("fn"in U.source)h(U.source);if($.flags&2)break}if($.flags&4)throw new n("controller"in $?"Task":("value"in $)?"Memo":"Effect");if($.flags&2)if("controller"in $)b$($);else if("value"in $)O$($);else Z$($);else $.flags=0},P=()=>{if(Q$)return;Q$=!0;try{for(let $=0;$<r.length;$++){let U=r[$];if(U.flags&2)h(U)}r.length=0}finally{Q$=!1}},t=($)=>{T++;try{$()}finally{if(T--,T===0)P()}},w$=($)=>{let U=Y,J={cleanup:null};Y=J;try{let R=$((W)=>O(J,W)),X=()=>o(J);if(U)O(U,X);return[R,X]}finally{Y=U}},A$=($)=>typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($),K=($,U,J)=>{if(U==null)throw new D$($);if(J&&!J(U))throw new M$($,U)},_=($,U,J=_$)=>{if(!J(U))throw new x$($,U)};class n extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class D$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class M$ extends TypeError{constructor($,U){super(`[${$}] Signal value ${A$(U)} is invalid`);this.name="InvalidSignalValueError"}}class x$ extends TypeError{constructor($,U){super(`[${$}] Callback ${A$(U)} is invalid`);this.name="InvalidCallbackError"}}var S$=($)=>{_("Effect",$);let U={fn:$,flags:E,sources:null,sourcesTail:null,cleanup:null},J=()=>{o(U),U.fn=void 0,U.flags=K$,U.sourcesTail=null,u(U)};if(Y)O(Y,J);return Z$(U),J},g$=($,U)=>{if(!Y)throw Error("match() must be called inside an effect");let J=Y,{ok:R,err:X=console.error,nil:W}=U,N,F=!1,M=Array($.length);for(let Q=0;Q<$.length;Q++)try{let Z=$[Q].get();if(Z==null)F=!0;else M[Q]=Z}catch(Z){if(!N)N=[];N.push(Z instanceof Error?Z:Error(String(Z)))}let m;try{if(F)m=W?.();else if(N)m=X(N);else m=R(M)}catch(Q){X([Q instanceof Error?Q:Error(String(Q))])}if(typeof m==="function")return m;if(m instanceof Promise){let Q=new AbortController;O(J,()=>Q.abort()),m.then((Z)=>{if(!Q.signal.aborted&&typeof Z==="function")O(J,Z)}).catch((Z)=>{X([Z instanceof Error?Z:Error(String(Z))])})}};var I$=($)=>typeof $==="string",X$=($)=>typeof $==="number",z$=($)=>typeof $==="symbol",w=($)=>typeof $==="function",a=($)=>w($)&&$.constructor.name==="AsyncFunction",T$=($)=>w($)&&$.constructor.name!=="AsyncFunction",W$=($)=>$!=null&&typeof $==="object",j=($,U)=>Object.prototype.toString.call($)===`[object ${U}]`,S=($)=>j($,"Object"),H$=($)=>S($)||Array.isArray($);var e=($,U)=>{if(_(y,$,T$),U?.value!==void 0)K(y,U.value,U?.guard);let J={fn:$,value:U?.value,flags:E,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:U?.equals??f,error:void 0};return{[Symbol.toStringTag]:y,get(){if(G)D(J,G);if(h(J),J.error)throw J.error;return J.value}}},E$=($)=>j($,y);var h$=($,U)=>{let J={value:$,sinks:null,sinksTail:null,stop:void 0},R=()=>{for(let W=J.sinks;W;W=W.nextSink)C(W.sink);if(T===0)P()};return{[Symbol.toStringTag]:y,get(){if(G){if(!J.sinks)J.stop=U(R);D(J,G)}return J.value}}};var k$=($,U)=>{let J={value:void 0,sinks:null,sinksTail:null,equals:U?.equals??f,guard:U?.guard,stop:void 0},R=(W)=>{K("Sensor",W,J.guard),c(J,W)};return{[Symbol.toStringTag]:y,get(){if(G){if(!J.sinks)J.stop=$(R);D(J,G)}return J.value}}};var s=($,U)=>{K(b,$,U?.guard);let J={value:$,sinks:null,sinksTail:null,equals:U?.equals??f,guard:U?.guard};return{[Symbol.toStringTag]:b,get(){if(G)D(J,G);return J.value},set(X){K(b,X,J.guard),c(J,X)},update(X){_(b,X);let W=X(J.value);K(b,W,J.guard),c(J,W)}}},p$=($)=>j($,b);var G$=($,U)=>{if(_(v,$,a),U?.value!==void 0)K(v,U.value,U?.guard);let J={fn:$,value:U?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:E,equals:U?.equals??f,controller:void 0,error:void 0};return{[Symbol.toStringTag]:v,get(){if(G)D(J,G);if(h(J),J.error)throw J.error;return J.value},isPending(){return!J.controller},abort(){J.controller?.abort(),J.controller=void 0}}},v$=($)=>j($,v);var $$="Collection";function U$($,U){if(_($$,U),!u$($))throw TypeError(`[${$$}] Invalid collection source: expected a List or Collection`);let J=a(U),R=new Map,X=[],W={value:[],sinks:null,sinksTail:null,stop:void 0},N=()=>{for(let z=W.sinks;z;z=z.nextSink)C(z.sink);if(T===0)P()},F=()=>{if(G)D(W,G)},M=(z)=>{let A=J?G$(async(V,x)=>{let B=$.byKey(z)?.get();if(B==null)return V;return U(B,x)}):e(()=>{let V=$.byKey(z)?.get();if(V==null)return;return U(V)});R.set(z,A)},m=e(()=>{return Array.from($.keys())}),Q=()=>{let z=m.get(),A=new Set(X),V=new Set(z),x=!1;for(let B of X)if(!V.has(B))R.delete(B),x=!0;for(let B of z)if(!A.has(B))M(B),x=!0;if(!x&&X.length===z.length){for(let B=0;B<X.length;B++)if(X[B]!==z[B]){x=!0;break}}if(X=z,x)N()};for(let z of Array.from($.keys()))M(z),X.push(z);let Z={[Symbol.toStringTag]:$$,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let z of X){let A=R.get(z);if(A)yield A}},get length(){return F(),Q(),X.length},keys(){return F(),Q(),X.values()},get(){return F(),Q(),X.map((z)=>{try{return R.get(z)?.get()}catch{return}}).filter((z)=>z!=null)},at(z){return R.get(X[z])},byKey(z){return R.get(z)},keyAt(z){return X[z]},indexOfKey(z){return X.indexOf(z)},deriveCollection(z){return U$(Z,z)}};return Z}var j$=($)=>j($,$$),u$=($)=>N$($)||j$($);var k="Store";class C$ extends Error{constructor($,U,J){super(`Could not add ${$} key "${U}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var i=($,U,J)=>{if(Object.is($,U))return!0;if(typeof $!==typeof U)return!1;if(!W$($)||!W$(U))return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(U))throw new n("isEqual");J.add($),J.add(U);try{if(Array.isArray($)&&Array.isArray(U)){if($.length!==U.length)return!1;for(let R=0;R<$.length;R++)if(!i($[R],U[R],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(U))return!1;if(S($)&&S(U)){let R=Object.keys($),X=Object.keys(U);if(R.length!==X.length)return!1;for(let W of R){if(!(W in U))return!1;if(!i($[W],U[W],J))return!1}return!0}return!1}finally{J.delete($),J.delete(U)}},L$=($,U)=>{let J=H$($),R=H$(U);if(!J||!R){let Z=!Object.is($,U);return{changed:Z,add:Z&&R?U:{},change:{},remove:Z&&J?$:{}}}let X=new WeakSet,W={},N={},F={},M=Object.keys($),m=Object.keys(U),Q=new Set([...M,...m]);for(let Z of Q){let z=Z in $,A=Z in U;if(!z&&A){W[Z]=U[Z];continue}else if(z&&!A){F[Z]=null;continue}let V=$[Z],x=U[Z];if(!i(V,x,X))N[Z]=x}return{add:W,change:N,remove:F,changed:!!(Object.keys(W).length||Object.keys(N).length||Object.keys(F).length)}},P$=($,U)=>{K(k,$,S);let J=new Map,R={value:$,sinks:null,sinksTail:null,stop:void 0},X=()=>{for(let Q=R.sinks;Q;Q=Q.nextSink)C(Q.sink);if(T===0)P()},W=()=>{if(G){if(!R.sinks&&U?.watched)R.stop=U.watched();D(R,G)}},N=(Q,Z)=>{if(K(`${k} for key "${Q}"`,Z),S(Z))J.set(Q,P$(Z));else J.set(Q,s(Z))},F=()=>{let Q={};return J.forEach((Z,z)=>{Q[z]=Z.get()}),Q},M=(Q)=>{for(let Z in Q.add)N(Z,Q.add[Z]);if(Object.keys(Q.change).length)t(()=>{for(let Z in Q.change){let z=Q.change[Z];K(`${k} for key "${Z}"`,z);let A=J.get(Z);if(A)if(S(z)!==V$(A))N(Z,z);else A.set(z)}});for(let Z in Q.remove)J.delete(Z);return Q.changed};for(let Q of Object.keys($))N(Q,$[Q]);let m={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Q of Array.from(J.keys())){let Z=J.get(Q);if(Z)yield[Q,Z]}},keys(){return W(),J.keys()},byKey(Q){return J.get(Q)},get(){return W(),F()},set(Q){let Z=F();if(M(L$(Z,Q)))X()},update(Q){m.set(Q(m.get()))},add(Q,Z){if(J.has(Q))throw new C$(k,Q,Z);return N(Q,Z),X(),Q},remove(Q){if(J.delete(Q))X()}};return new Proxy(m,{get(Q,Z){if(Z in Q){let z=Reflect.get(Q,Z);return w(z)?z.bind(Q):z}if(!z$(Z))return Q.byKey(Z)},has(Q,Z){if(Z in Q)return!0;return Q.byKey(String(Z))!==void 0},ownKeys(Q){return Array.from(Q.keys())},getOwnPropertyDescriptor(Q,Z){if(Z in Q)return Reflect.getOwnPropertyDescriptor(Q,Z);if(z$(Z))return;let z=Q.byKey(String(Z));return z?{enumerable:!0,configurable:!0,writable:!0,value:z}:void 0}})},V$=($)=>j($,k);var p="List";class Y$ extends Error{constructor($,U,J){super(`Could not add ${$} key "${U}"${J?` with value ${JSON.stringify(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}var c$=($,U)=>{K(p,$,Array.isArray);let J=new Map,R=[],X=0,W=U?.keyConfig,N=I$(W)?()=>`${W}${X++}`:w(W)?(B)=>W(B):()=>String(X++),F={value:$,sinks:null,sinksTail:null,stop:void 0},M=()=>{for(let B=F.sinks;B;B=B.nextSink)C(B.sink);if(T===0)P()},m=()=>{if(G){if(!F.sinks&&U?.watched)F.stop=U.watched();D(F,G)}},Q=(B,H)=>{K(`${p} item for key "${B}"`,H),J.set(B,s(H))},Z=(B)=>{let H={};for(let q=0;q<B.length;q++){let L=B[q];if(L===void 0)continue;let I=R[q];if(!I)I=N(L),R[q]=I;H[I]=L}return H},z=()=>{return R.map((B)=>J.get(B)?.get()).filter((B)=>B!==void 0)},A=(B)=>{for(let H in B.add)Q(H,B.add[H]);if(Object.keys(B.change).length)t(()=>{for(let H in B.change){let q=B.change[H];K(`${p} item for key "${H}"`,q);let L=J.get(H);if(L)L.set(q)}});for(let H in B.remove){J.delete(H);let q=R.indexOf(H);if(q!==-1)R.splice(q,1)}if(Object.keys(B.remove).length)R=R.filter(()=>!0);return B.changed},V=Z($);for(let B in V)Q(B,V[B]);let x={[Symbol.toStringTag]:p,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of R){let H=J.get(B);if(H)yield H}},get length(){return m(),R.length},get(){return m(),z()},set(B){let H=z(),q=L$(Z(H),Z(B));if(A(q))M()},update(B){x.set(B(x.get()))},at(B){return J.get(R[B])},keys(){return m(),R.values()},byKey(B){return J.get(B)},keyAt(B){return R[B]},indexOfKey(B){return R.indexOf(B)},add(B){let H=N(B);if(J.has(H))throw new Y$(p,H,B);if(!R.includes(H))R.push(H);return Q(H,B),M(),H},remove(B){let H=X$(B)?R[B]:B;if(J.delete(H)){let L=X$(B)?B:R.indexOf(H);if(L>=0)R.splice(L,1);R=R.filter(()=>!0),M()}},sort(B){let q=R.map((L)=>[L,J.get(L)?.get()]).sort(w(B)?(L,I)=>B(L[1],I[1]):(L,I)=>String(L[1]).localeCompare(String(I[1]))).map(([L])=>L);if(!i(R,q))R=q,M()},splice(B,H,...q){let L=R.length,I=B<0?Math.max(0,L+B):Math.min(B,L),m$=Math.max(0,Math.min(H??Math.max(0,L-Math.max(0,I)),L-I)),J$={},d={};for(let g=0;g<m$;g++){let l=I+g,B$=R[l];if(B$){let F$=J.get(B$);if(F$)d[B$]=F$.get()}}let R$=R.slice(0,I);for(let g of q){let l=N(g);R$.push(l),J$[l]=g}R$.push(...R.slice(I+m$));let q$=!!(Object.keys(J$).length||Object.keys(d).length);if(q$)A({add:J$,change:{},remove:d,changed:q$}),R=R$.filter(()=>!0),M();return Object.values(d)},deriveCollection(B){return U$(x,B)}};return x},N$=($)=>j($,p);export{g$ as match,v$ as isTask,V$ as isStore,p$ as isState,E$ as isMemo,N$ as isList,j$ as isCollection,G$ as createTask,P$ as createStore,s as createState,k$ as createSensor,w$ as createScope,h$ as createRef,e as createMemo,c$ as createList,S$ as createEffect,U$ as createCollection,t as batch};
