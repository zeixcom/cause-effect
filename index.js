var N,O=new Set,b=0,h=new Map,k,e=()=>{k=void 0;let $=Array.from(h.values());h.clear();for(let B of $)B()},Z$=()=>{if(k)cancelAnimationFrame(k);k=requestAnimationFrame(e)};queueMicrotask(e);var y=($)=>{let B=new Set,W=$;return W.off=(J)=>{B.add(J)},W.cleanup=()=>{for(let J of B)J();B.clear()},W},j=($)=>{if(N&&!$.has(N)){let B=N;$.add(B),N.off(()=>{$.delete(B)})}},M=($)=>{for(let B of $)if(b)O.add(B);else B()},w=()=>{while(O.size){let $=Array.from(O);O.clear();for(let B of $)B()}},d=($)=>{b++;try{$()}finally{w(),b--}},T=($,B)=>{let W=N;N=B;try{$()}finally{N=W}},F$=($,B)=>new Promise((W,J)=>{h.set(B||Symbol(),()=>{try{W($())}catch(X){J(X)}}),Z$()});var $$=($)=>typeof $==="string",B$=($)=>typeof $==="number",K=($)=>typeof $==="function",f=($)=>K($)&&$.constructor.name==="AsyncFunction",m=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,U=($)=>m($,"Object"),E=($)=>U($)||Array.isArray($),W$=($)=>{if(!$.length)return null;let B=$.map((W)=>$$(W)?parseInt(W,10):B$(W)?W:NaN);return B.every((W)=>Number.isFinite(W)&&W>=0)?B.sort((W,J)=>W-J):null},J$=($,B)=>(B in $)&&K($[B]),_=($)=>$ instanceof DOMException&&$.name==="AbortError",Y=($)=>$ instanceof Error?$:Error(String($));class q extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var v="State",V=($)=>{let B=new Set,W=$,J={[Symbol.toStringTag]:v,get:()=>{return j(B),W},set:(X)=>{if(D(W,X))return;if(W=X,M(B),H===W)B.clear()},update:(X)=>{J.set(X(W))}};return J},g=($)=>m($,v);var o=($)=>{let B=f($),W=!1,J,X=y(()=>T(()=>{if(W)throw new q("effect");W=!0,J?.abort(),J=void 0;let z;try{if(B){J=new AbortController;let x=J;$(J.signal).then((G)=>{if(K(G)&&J===x)X.off(G)}).catch((G)=>{if(!_(G))console.error("Async effect error:",G)})}else if(z=$(),K(z))X.off(z)}catch(x){if(!_(x))console.error("Effect callback error:",x)}W=!1},X));return X(),()=>{J?.abort(),X.cleanup()}};var n="Store",c="store-add",L$="store-change",Q$="store-remove",G$=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"],S=($)=>{let B=new Set,W=new EventTarget,J=new Map,X=new Map,z=V(0),x=()=>{let C=Array.from(J.keys()),L=W$(C);if(L)return L.map((Z)=>J.get(String(Z))?.get());let Q={};for(let[Z,F]of J)Q[Z]=F.get();return Q},G=(C,L)=>W.dispatchEvent(new CustomEvent(C,{detail:L})),R=(C,L)=>{let Q=String(C),Z=u(L);J.set(Q,Z);let F=o(()=>{let A=Z.get();if(A!=null)G(L$,{[C]:A})});X.set(Q,F)},P=(C)=>{let L=String(C);J.delete(L);let Q=X.get(L);if(Q)Q();X.delete(L)},I=(C,L,Q)=>{let Z=i(C,L);return d(()=>{if(Object.keys(Z.add).length){for(let F in Z.add){let A=Z.add[F];if(A!=null)R(F,A)}if(Q)setTimeout(()=>{G(c,$)},0);else G(c,Z.add)}if(Object.keys(Z.change).length){for(let F in Z.change){let A=J.get(F),a=Z.change[F];if(A&&a!=null&&J$(A,"set"))A.set(a)}G(L$,Z.change)}if(Object.keys(Z.remove).length){for(let F in Z.remove)P(F);G(Q$,Z.remove)}z.set(J.size)}),Z.changed};return I({},$,!0),new Proxy({},{get(C,L){switch(L){case"add":return(Q,Z)=>{if(!J.has(Q))R(Q,Z),M(B),G(c,{[Q]:Z}),z.set(J.size)};case"get":return()=>{return j(B),x()};case"remove":return(Q)=>{if(J.has(Q))P(Q),M(B),G(Q$,{[Q]:H}),z.set(J.size)};case"set":return(Q)=>{if(I(x(),Q)){if(M(B),H===Q)B.clear()}};case"update":return(Q)=>{let Z=x(),F=Q(Z);if(I(Z,F)){if(M(B),H===F)B.clear()}};case"addEventListener":return W.addEventListener.bind(W);case"removeEventListener":return W.removeEventListener.bind(W);case"dispatchEvent":return W.dispatchEvent.bind(W);case"size":return z}if(L===Symbol.toStringTag)return n;if(L===Symbol.iterator)return function*(){for(let[Q,Z]of J)yield[Q,Z]};return J.get(String(L))},has(C,L){let Q=String(L);return J.has(Q)||G$.includes(Q)||L===Symbol.toStringTag||L===Symbol.iterator},ownKeys(){return Array.from(J.keys()).map((C)=>String(C))},getOwnPropertyDescriptor(C,L){let Q=J.get(String(L));return Q?{enumerable:!0,configurable:!0,writable:!0,value:Q}:void 0}})},p=($)=>m($,n);var H=Symbol(),X$=($)=>g($)||s($)||p($);function x$($){if(X$($))return $;if(r($))return t($);if(Array.isArray($))return S($);if(Array.isArray($)||U($))return S($);return V($)}function u($){if(g($)||p($))return $;if(Array.isArray($))return S($);if(U($))return S($);return V($)}var D=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new q("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let J=0;J<$.length;J++)if(!D($[J],B[J],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(U($)&&U(B)){let J=Object.keys($),X=Object.keys(B);if(J.length!==X.length)return!1;for(let z of J){if(!(z in B))return!1;if(!D($[z],B[z],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},i=($,B)=>{let W=E($),J=E(B);if(!W||!J){let L=!Object.is($,B);return{changed:L,add:L&&J?B:{},change:{},remove:L&&W?$:{}}}let X=new WeakSet,z={},x={},G={},R=Object.keys($),P=Object.keys(B),I=new Set([...R,...P]);for(let L of I){let Q=L in $,Z=L in B;if(!Q&&Z){z[L]=B[L];continue}else if(Q&&!Z){G[L]=H;continue}let F=$[L],A=B[L];if(!D(F,A,X))x[L]=A}return{changed:Object.keys(z).length>0||Object.keys(x).length>0||Object.keys(G).length>0,add:z,change:x,remove:G}};var l="Computed",t=($)=>{let B=new Set,W=H,J,X,z=!0,x=!1,G=!1,R=(F)=>{if(!D(F,W))W=F,x=!0;J=void 0,z=!1},P=()=>{x=H!==W,W=H,J=void 0},I=(F)=>{let A=Y(F);x=!J||A.name!==J.name||A.message!==J.message,W=H,J=A},C=(F)=>(A)=>{if(G=!1,X=void 0,F(A),x)M(B)},L=y(()=>{if(z=!0,X?.abort(),B.size)M(B);else L.cleanup()});L.off(()=>{X?.abort()});let Q=()=>T(()=>{if(G)throw new q("computed");if(x=!1,f($)){if(X)return W;X=new AbortController,X.signal.addEventListener("abort",()=>{G=!1,X=void 0,Q()},{once:!0})}let F;G=!0;try{F=X?$(X.signal):$()}catch(A){if(_(A))P();else I(A);G=!1;return}if(F instanceof Promise)F.then(C(R),C(I));else if(F==null||H===F)P();else R(F);G=!1},L);return{[Symbol.toStringTag]:l,get:()=>{if(j(B),w(),z)Q();if(J)throw J;return W}}},s=($)=>m($,l),r=($)=>K($)&&$.length<2;function z$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(Y(W))))B.err($.errors?[...$.errors,Y(W)]:[Y(W)]);else throw W}}function A$($){let B=[],W=!1,J={};for(let[X,z]of Object.entries($))try{let x=z.get();if(x===H)W=!0;else J[X]=x}catch(x){B.push(Y(x))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:J}}export{y as watch,x$ as toSignal,u as toMutableSignal,Y as toError,j as subscribe,S as store,V as state,A$ as resolve,T as observe,M as notify,z$ as match,$$ as isString,p as isStore,g as isState,X$ as isSignal,E as isRecordOrArray,U as isRecord,B$ as isNumber,K as isFunction,D as isEqual,r as isComputedCallback,s as isComputed,f as isAsyncFunction,_ as isAbortError,w as flush,F$ as enqueue,o as effect,i as diff,t as computed,d as batch,H as UNSET,n as TYPE_STORE,v as TYPE_STATE,l as TYPE_COMPUTED,q as CircularDependencyError};
