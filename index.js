function g($){return typeof $==="function"}function i($){return g($)&&$.constructor.name==="AsyncFunction"}function z$($){return g($)&&$.constructor.name!=="AsyncFunction"}function A($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function L($){return A($,"Object")}function A$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function m$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class X$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class Y$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class o extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class Z$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${m$(J)} is invalid`);this.name="InvalidSignalValueError"}}class b$ extends TypeError{constructor($,J){super(`[${$}] Callback ${m$(J)} is invalid`);this.name="InvalidCallbackError"}}class P$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class D$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class e extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function K($,J,z){if(J==null)throw new Y$($);if(z&&!z(J))throw new Z$($,J)}function j$($,J){if(J==null)throw new o($)}function T($,J,z=g){if(!z(J))throw new b$($,J)}var c="State",u="Memo",d="Task",t="Sensor",E="List",l="Collection",r="Store",s="Slot",S=0,C$=1,D=2,M$=4,b=8,N=null,y=null,G$=[],R=0,_$=!1,k=($,J)=>$===J,L$=($,J)=>!1;function g$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function F($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,W=J.flags&M$;if(W){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let H=$.sinksTail;if(H?.sink===J&&(!W||g$(H,J)))return;let P={source:$,sink:J,nextSource:X,prevSink:H,nextSink:null};if(J.sourcesTail=$.sinksTail=P,z)z.nextSource=P;else J.sources=P;if(H)H.nextSink=P;else $.sinks=P}function k$($){let{source:J,nextSource:z,nextSink:X,prevSink:W}=$;if(X)X.prevSink=W;else J.sinksTail=W;if(W)W.nextSink=X;else J.sinks=X;if(!J.sinks){if(J.stop)J.stop(),J.stop=void 0;if("sources"in J&&J.sources){let H=J;H.sourcesTail=null,W$(H)}}return z}function W$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=k$(z);if(J)J.nextSource=null;else $.sources=null}function x($,J=D){let z=$.flags;if("sinks"in $){if((z&(D|C$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)x(X.sink,C$)}else{if(z&D)return;$.flags=D,G$.push($)}}function U$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)x(z.sink);if(R===0)w()}function $$($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function K$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function v$($){let J=N;N=$,$.sourcesTail=null,$.flags=M$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{N=J,W$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&C$)X.sink.flags|=D}$.flags=S}function c$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=N;N=$,$.sourcesTail=null,$.flags=M$;let X;try{X=$.fn($.value,J.signal)}catch(W){$.controller=void 0,$.error=W instanceof Error?W:Error(String(W));return}finally{N=z,W$($)}X.then((W)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(W,$.value)){$.value=W,$.error=void 0;for(let H=$.sinks;H;H=H.nextSink)x(H.sink);if(R===0)w()}},(W)=>{if(J.signal.aborted)return;$.controller=void 0;let H=W instanceof Error?W:Error(String(W));if(!$.error||H.name!==$.error.name||H.message!==$.error.message){$.error=H;for(let P=$.sinks;P;P=P.nextSink)x(P.sink);if(R===0)w()}}),$.flags=S}function T$($){K$($);let J=N,z=y;N=y=$,$.sourcesTail=null,$.flags=M$;try{let X=$.fn();if(typeof X==="function")$$($,X)}finally{N=J,y=z,W$($)}$.flags=S}function I($){if($.flags&C$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)I(J.source);if($.flags&D)break}if($.flags&M$)throw new X$("controller"in $?d:("value"in $)?u:"Effect");if($.flags&D)if("controller"in $)c$($);else if("value"in $)v$($);else T$($);else $.flags=S}function w(){if(_$)return;_$=!0;try{for(let $=0;$<G$.length;$++){let J=G$[$];if(J.flags&D)I(J)}G$.length=0}finally{_$=!1}}function J$($){R++;try{$()}finally{if(R--,R===0)w()}}function v($){let J=N;N=null;try{return $()}finally{N=J}}function u$($){let J=y,z={cleanup:null};y=z;try{let X=$();if(typeof X==="function")$$(z,X);let W=()=>K$(z);if(J)$$(J,W);return W}finally{y=J}}function p($,J){K(c,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??k,guard:J?.guard};return{[Symbol.toStringTag]:c,get(){if(N)F(z,N);return z.value},set(X){K(c,X,z.guard),U$(z,X)},update(X){T(c,X);let W=X(z.value);K(c,W,z.guard),U$(z,W)}}}function N$($){return A($,c)}function n($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new X$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let W=$,H=J;if(W.length!==H.length)return!1;for(let P=0;P<W.length;P++)if(!n(W[P],H[P],z))return!1;return!0}if(L($)&&L(J)){let W=Object.keys($),H=Object.keys(J);if(W.length!==H.length)return!1;for(let P of W){if(!(P in J))return!1;if(!n($[P],J[P],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function O$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function E$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function d$($,J,z,X,W){let H=new WeakSet,P={},M={},C={},U=[],Q=!1,j=new Map;for(let q=0;q<$.length;q++){let Z=z[q];if(Z&&$[q])j.set(Z,$[q])}let G=new Set;for(let q=0;q<J.length;q++){let Z=J[q];if(Z===void 0)continue;let B=W?X(Z):z[q]??X(Z);if(G.has(B))throw new e(E,B,Z);if(U.push(B),G.add(B),!j.has(B))P[B]=Z,Q=!0;else if(!n(j.get(B),Z,H))M[B]=Z,Q=!0}for(let[q]of j)if(!G.has(q))C[q]=null,Q=!0;if(!Q&&!O$(z,U))Q=!0;return{add:P,change:M,remove:C,newKeys:U,changed:Q}}function H$($,J){K(E,$,Array.isArray);let z=new Map,X=[],[W,H]=E$(J?.keyConfig),P=()=>X.map((Z)=>z.get(Z)?.get()).filter((Z)=>Z!==void 0),M={fn:P,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},C=(Z)=>{let B={};for(let V=0;V<Z.length;V++){let m=Z[V];if(m===void 0)continue;let O=X[V];if(!O)O=W(m),X[V]=O;B[O]=m}return B},U=(Z)=>{let B=!1;for(let V in Z.add){let m=Z.add[V];K(`${E} item for key "${V}"`,m),z.set(V,p(m)),B=!0}if(Object.keys(Z.change).length)J$(()=>{for(let V in Z.change){let m=Z.change[V];K(`${E} item for key "${V}"`,m);let O=z.get(V);if(O)O.set(m)}});for(let V in Z.remove){z.delete(V);let m=X.indexOf(V);if(m!==-1)X.splice(m,1);B=!0}if(B)M.flags|=b;return Z.changed},Q=J?.watched,j=Q?()=>{if(N){if(!M.sinks)M.stop=Q();F(M,N)}}:()=>{if(N)F(M,N)},G=C($);for(let Z in G){let B=G[Z];K(`${E} item for key "${Z}"`,B),z.set(Z,p(B))}M.value=$,M.flags=0;let q={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of X){let B=z.get(Z);if(B)yield B}},get length(){return j(),X.length},get(){if(j(),M.sources){if(M.flags){let Z=M.flags&b;if(M.value=v(P),Z){if(M.flags=D,I(M),M.error)throw M.error}else M.flags=S}}else if(I(M),M.error)throw M.error;return M.value},set(Z){let B=M.flags&D?P():M.value,V=d$(B,Z,X,W,H);if(V.changed){X=V.newKeys,U(V),M.flags|=D;for(let m=M.sinks;m;m=m.nextSink)x(m.sink);if(R===0)w()}},update(Z){q.set(Z(q.get()))},at(Z){return z.get(X[Z])},keys(){return j(),X.values()},byKey(Z){return z.get(Z)},keyAt(Z){return X[Z]},indexOfKey(Z){return X.indexOf(Z)},add(Z){let B=W(Z);if(z.has(B))throw new e(E,B,Z);if(!X.includes(B))X.push(B);K(`${E} item for key "${B}"`,Z),z.set(B,p(Z)),M.flags|=D|b;for(let V=M.sinks;V;V=V.nextSink)x(V.sink);if(R===0)w();return B},remove(Z){let B=typeof Z==="number"?X[Z]:Z;if(z.delete(B)){let m=typeof Z==="number"?Z:X.indexOf(B);if(m>=0)X.splice(m,1);M.flags|=D|b;for(let O=M.sinks;O;O=O.nextSink)x(O.sink);if(R===0)w()}},sort(Z){let V=X.map((m)=>[m,z.get(m)?.get()]).sort(g(Z)?(m,O)=>Z(m[1],O[1]):(m,O)=>String(m[1]).localeCompare(String(O[1]))).map(([m])=>m);if(!O$(X,V)){X=V,M.flags|=D;for(let m=M.sinks;m;m=m.nextSink)x(m.sink);if(R===0)w()}},splice(Z,B,...V){let m=X.length,O=Z<0?Math.max(0,m+Z):Math.min(Z,m),f=Math.max(0,Math.min(B??Math.max(0,m-Math.max(0,O)),m-O)),Y={},_={};for(let h=0;h<f;h++){let a=O+h,f$=X[a];if(f$){let y$=z.get(f$);if(y$)_[f$]=y$.get()}}let I$=X.slice(0,O);for(let h of V){let a=W(h);if(z.has(a)&&!(a in _))throw new e(E,a,h);I$.push(a),Y[a]=h}I$.push(...X.slice(O+f));let p$=!!(Object.keys(Y).length||Object.keys(_).length);if(p$){U({add:Y,change:{},remove:_,changed:p$}),X=I$,M.flags|=D;for(let h=M.sinks;h;h=h.nextSink)x(h.sink);if(R===0)w()}return Object.values(_)},deriveCollection(Z){return R$(q,Z)}};return q}function F$($){return A($,E)}function Q$($,J){if(T(u,$,z$),J?.value!==void 0)K(u,J.value,J?.guard);let z={fn:$,value:J?.value,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??k,error:void 0,stop:void 0},X=J?.watched,W=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{z.flags|=D;for(let H=z.sinks;H;H=H.nextSink)x(H.sink);if(R===0)w()});F(z,N)}}:()=>{if(N)F(z,N)};return{[Symbol.toStringTag]:u,get(){if(W(),I(z),z.error)throw z.error;return j$(u,z.value),z.value}}}function S$($){return A($,u)}function B$($,J){if(T(d,$,i),J?.value!==void 0)K(d,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:D,equals:J?.equals??k,controller:void 0,error:void 0,stop:void 0},X=J?.watched,W=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{z.flags|=D;for(let H=z.sinks;H;H=H.nextSink)x(H.sink);if(R===0)w()});F(z,N)}}:()=>{if(N)F(z,N)};return{[Symbol.toStringTag]:d,get(){if(W(),I(z),z.error)throw z.error;return j$(d,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function h$($){return A($,d)}function R$($,J){T(l,J);let z=i(J),X=new Map,W=[],H=(q)=>{let Z=z?B$(async(B,V)=>{let m=$.byKey(q)?.get();if(m==null)return B;return J(m,V)}):Q$(()=>{let B=$.byKey(q)?.get();if(B==null)return;return J(B)});X.set(q,Z)};function P(q){if(!O$(W,q)){let Z=new Set(W),B=new Set(q);for(let V of W)if(!B.has(V))X.delete(V);for(let V of q)if(!Z.has(V))H(V);W=q,U.flags|=b}}function M(){P(Array.from($.keys()));let q=[];for(let Z of W)try{let B=X.get(Z)?.get();if(B!=null)q.push(B)}catch(B){if(!(B instanceof o))throw B}return q}let U={fn:M,value:[],flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(q,Z)=>{if(q.length!==Z.length)return!1;for(let B=0;B<q.length;B++)if(q[B]!==Z[B])return!1;return!0},error:void 0};function Q(){if(U.sources){if(U.flags)if(U.value=v(M),U.flags&b){if(U.flags=D,I(U),U.error)throw U.error}else U.flags=S}else if(U.sinks){if(I(U),U.error)throw U.error}else U.value=v(M)}let j=Array.from(v(()=>$.keys()));for(let q of j)H(q);W=j;let G={[Symbol.toStringTag]:l,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let q of W){let Z=X.get(q);if(Z)yield Z}},get length(){if(N)F(U,N);return Q(),W.length},keys(){if(N)F(U,N);return Q(),W.values()},get(){if(N)F(U,N);return Q(),U.value},at(q){return X.get(W[q])},byKey(q){return X.get(q)},keyAt(q){return W[q]},indexOfKey(q){return W.indexOf(q)},deriveCollection(q){return R$(G,q)}};return G}function t$($,J){let z=J?.value??[];if(z.length)K(l,z,Array.isArray);T(l,$,z$);let X=new Map,W=[],H=new Map,[P,M]=E$(J?.keyConfig),C=(Z)=>H.get(Z)??(M?P(Z):void 0),U=J?.createItem??p;function Q(){let Z=[];for(let B of W)try{let V=X.get(B)?.get();if(V!=null)Z.push(V)}catch(V){if(!(V instanceof o))throw V}return Z}let j={fn:Q,value:z,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:L$,error:void 0};for(let Z of z){let B=P(Z);X.set(B,U(Z)),H.set(Z,B),W.push(B)}j.value=z,j.flags=D;function G(){if(N){if(!j.sinks)j.stop=$((Z)=>{let{add:B,change:V,remove:m}=Z;if(!B?.length&&!V?.length&&!m?.length)return;let O=!1;J$(()=>{if(B)for(let f of B){let Y=P(f);if(X.set(Y,U(f)),H.set(f,Y),!W.includes(Y))W.push(Y);O=!0}if(V)for(let f of V){let Y=C(f);if(!Y)continue;let _=X.get(Y);if(_&&N$(_))H.delete(_.get()),_.set(f),H.set(f,Y)}if(m)for(let f of m){let Y=C(f);if(!Y)continue;H.delete(f),X.delete(Y);let _=W.indexOf(Y);if(_!==-1)W.splice(_,1);O=!0}j.flags=D|(O?b:0);for(let f=j.sinks;f;f=f.nextSink)x(f.sink)})});F(j,N)}}let q={[Symbol.toStringTag]:l,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of W){let B=X.get(Z);if(B)yield B}},get length(){return G(),W.length},keys(){return G(),W.values()},get(){if(G(),j.sources){if(j.flags){let Z=j.flags&b;if(j.value=v(Q),Z){if(j.flags=D,I(j),j.error)throw j.error}else j.flags=S}}else if(I(j),j.error)throw j.error;return j.value},at(Z){return X.get(W[Z])},byKey(Z){return X.get(Z)},keyAt(Z){return W[Z]},indexOfKey(Z){return W.indexOf(Z)},deriveCollection(Z){return R$(q,Z)}};return q}function l$($){return A($,l)}function r$($){T("Effect",$);let J={fn:$,flags:D,sources:null,sourcesTail:null,cleanup:null},z=()=>{K$(J),J.fn=void 0,J.flags=S,J.sourcesTail=null,W$(J)};if(y)$$(y,z);return T$(J),z}function s$($,J){if(!y)throw new D$("match");let{ok:z,err:X=console.error,nil:W}=J,H,P=!1,M=Array($.length);for(let U=0;U<$.length;U++)try{M[U]=$[U].get()}catch(Q){if(Q instanceof o){P=!0;continue}if(!H)H=[];H.push(Q instanceof Error?Q:Error(String(Q)))}let C;try{if(P)C=W?.();else if(H)C=X(H);else C=z(M)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof C==="function")return C;if(C instanceof Promise){let U=y,Q=new AbortController;$$(U,()=>Q.abort()),C.then((j)=>{if(!Q.signal.aborted&&typeof j==="function")$$(U,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function i$($,J){if(T(t,$,z$),J?.value!==void 0)K(t,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??k,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:t,get(){if(N){if(!z.sinks)z.stop=$((X)=>{K(t,X,z.guard),U$(z,X)});F(z,N)}return j$(t,z.value),z.value}}}function o$($){return A($,t)}function n$($,J){let z=L($)||Array.isArray($),X=L(J)||Array.isArray(J);if(!z||!X){let j=!Object.is($,J);return{changed:j,add:j&&X?J:{},change:{},remove:j&&z?$:{}}}let W=new WeakSet,H={},P={},M={},C=!1,U=Object.keys($),Q=Object.keys(J);for(let j of Q)if(j in $){if(!n($[j],J[j],W))P[j]=J[j],C=!0}else H[j]=J[j],C=!0;for(let j of U)if(!(j in J))M[j]=void 0,C=!0;return{add:H,change:P,remove:M,changed:C}}function V$($,J){K(r,$,L);let z=new Map,X=(Q,j)=>{if(K(`${r} for key "${Q}"`,j),Array.isArray(j))z.set(Q,H$(j));else if(L(j))z.set(Q,V$(j));else z.set(Q,p(j))},W=()=>{let Q={};return z.forEach((j,G)=>{Q[G]=j.get()}),Q},H={fn:W,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},P=(Q)=>{let j=!1;for(let G in Q.add)X(G,Q.add[G]),j=!0;if(Object.keys(Q.change).length)J$(()=>{for(let G in Q.change){let q=Q.change[G];K(`${r} for key "${G}"`,q);let Z=z.get(G);if(Z)if(L(q)!==x$(Z))X(G,q),j=!0;else Z.set(q)}});for(let G in Q.remove)z.delete(G),j=!0;if(j)H.flags|=b;return Q.changed},M=J?.watched,C=M?()=>{if(N){if(!H.sinks)H.stop=M();F(H,N)}}:()=>{if(N)F(H,N)};for(let Q of Object.keys($))X(Q,$[Q]);let U={[Symbol.toStringTag]:r,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Q of Array.from(z.keys())){let j=z.get(Q);if(j)yield[Q,j]}},keys(){return C(),z.keys()},byKey(Q){return z.get(Q)},get(){if(C(),H.sources){if(H.flags){let Q=H.flags&b;if(H.value=v(W),Q){if(H.flags=D,I(H),H.error)throw H.error}else H.flags=S}}else if(I(H),H.error)throw H.error;return H.value},set(Q){let j=H.flags&D?W():H.value,G=n$(j,Q);if(P(G)){H.flags|=D;for(let q=H.sinks;q;q=q.nextSink)x(q.sink);if(R===0)w()}},update(Q){U.set(Q(U.get()))},add(Q,j){if(z.has(Q))throw new e(r,Q,j);X(Q,j),H.flags|=D|b;for(let G=H.sinks;G;G=G.nextSink)x(G.sink);if(R===0)w();return Q},remove(Q){if(z.delete(Q)){H.flags|=D|b;for(let G=H.sinks;G;G=G.nextSink)x(G.sink);if(R===0)w()}}};return new Proxy(U,{get(Q,j){if(j in Q)return Reflect.get(Q,j);if(typeof j!=="symbol")return Q.byKey(j)},has(Q,j){if(j in Q)return!0;return Q.byKey(String(j))!==void 0},ownKeys(Q){return Array.from(Q.keys())},getOwnPropertyDescriptor(Q,j){if(j in Q)return Reflect.getOwnPropertyDescriptor(Q,j);if(typeof j==="symbol")return;let G=Q.byKey(String(j));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})}function x$($){return A($,r)}function a$($,J){return i($)?B$($,J):Q$($,J)}function e$($){if(q$($))return $;if($==null)throw new Z$("createSignal",$);if(i($))return B$($);if(g($))return Q$($);if(A$($))return H$($);if(L($))return V$($);return p($)}function $J($){if(w$($))return $;if($==null||g($)||q$($))throw new Z$("createMutableSignal",$);if(A$($))return H$($);if(L($))return V$($);return p($)}function JJ($){return S$($)||h$($)}function q$($){let J=[c,u,d,t,s,E,l,r],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function w$($){return N$($)||x$($)||F$($)}function zJ($,J){K(s,$,q$);let z=$,X=J?.guard,W={fn:()=>z.get(),value:void 0,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??k,error:void 0},H=()=>{if(N)F(W,N);if(I(W),W.error)throw W.error;return W.value},P=(C)=>{if(!w$(z))throw new P$(s);K(s,C,X),z.set(C)},M=(C)=>{K(s,C,q$),z=C,W.flags|=D;for(let U=W.sinks;U;U=U.nextSink)x(U.sink);if(R===0)w()};return{[Symbol.toStringTag]:s,configurable:!0,enumerable:!0,get:H,set:P,replace:M,current:()=>z}}function XJ($){return A($,s)}export{m$ as valueString,v as untrack,s$ as match,h$ as isTask,x$ as isStore,N$ as isState,XJ as isSlot,q$ as isSignal,o$ as isSensor,L as isRecord,A as isObjectOfType,w$ as isMutableSignal,S$ as isMemo,F$ as isList,g as isFunction,n as isEqual,JJ as isComputed,l$ as isCollection,i as isAsyncFunction,B$ as createTask,V$ as createStore,p as createState,zJ as createSlot,e$ as createSignal,i$ as createSensor,u$ as createScope,$J as createMutableSignal,Q$ as createMemo,H$ as createList,r$ as createEffect,a$ as createComputed,t$ as createCollection,J$ as batch,o as UnsetSignalValueError,L$ as SKIP_EQUALITY,D$ as RequiredOwnerError,P$ as ReadonlySignalError,Y$ as NullishSignalValueError,Z$ as InvalidSignalValueError,b$ as InvalidCallbackError,X$ as CircularDependencyError};
