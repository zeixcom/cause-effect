var C,e=new Set,D$=0,B=Symbol(),v="add",K="change",S="cleanup",n="remove",d="sort",q="watch",U=($)=>{let J=new Set,z=$;return z.on=(X,Z)=>{if(X===S)J.add(Z);else throw new N("watcher",X)},z.stop=()=>{for(let X of J)X();J.clear()},z},I=($)=>{let J=!$.size;if(C&&!$.has(C)){let z=C;z.on(S,()=>$.delete(z)),$.add(z)}return J},x=($)=>{if(!$.size)return!1;for(let J of $)if(D$)e.add(J);else J();return!0},h=()=>{while(e.size){let $=Array.from(e);e.clear();for(let J of $)J()}},I$=($)=>{D$++;try{$()}finally{h(),D$--}},R=($,J)=>{let z=C;C=$||void 0;try{J()}finally{C=z}},M=($,J)=>{if(!$)return;let z=[];for(let X of $){let Z=X(J);if(Z)z.push(Z)}return()=>{for(let X of z)X()}},$$=($,J)=>J.includes($);var J$=($)=>typeof $==="string",z$=($)=>typeof $==="number",w=($)=>typeof $==="symbol",D=($)=>typeof $==="function",V=($)=>D($)&&$.constructor.name==="AsyncFunction",W$=($)=>D($)&&$.constructor.name!=="AsyncFunction",Y$=($)=>$!=null&&typeof $==="object",L=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,P=($)=>L($,"Object"),X$=($)=>P($)||Array.isArray($),j$=($,J=(z)=>z!=null)=>Array.isArray($)&&$.every(J);var O=($)=>$ instanceof DOMException&&$.name==="AbortError",f=($)=>J$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var A=($,J,z)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!Y$($)||!Y$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new T("isEqual");z.add($),z.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let X=0;X<$.length;X++)if(!A($[X],J[X],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(P($)&&P(J)){let X=Object.keys($),Z=Object.keys(J);if(X.length!==Z.length)return!1;for(let Q of X){if(!(Q in J))return!1;if(!A($[Q],J[Q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}},k=($,J)=>{let z=X$($),X=X$(J);if(!z||!X){let F=!Object.is($,J);return{changed:F,add:F&&X?J:{},change:{},remove:F&&z?$:{}}}let Z=new WeakSet,Q={},G={},j={},b=Object.keys($),a=Object.keys(J),_=new Set([...b,...a]);for(let F of _){let E=F in $,y=F in J;if(!E&&y){Q[F]=J[F];continue}else if(E&&!y){j[F]=B;continue}let C$=$[F],V$=J[F];if(!A(C$,V$,Z))G[F]=V$}return{add:Q,change:G,remove:j,changed:!!(Object.keys(Q).length||Object.keys(G).length||Object.keys(j).length)}};var Z$="Computed";class u{#J=new Set;#z;#X;#$;#Q=!0;#B=!1;#Z;#G={};constructor($,J=B){m(this.constructor.name,$,Q$),Y(this.constructor.name,J),this.#z=$,this.#X=J}#x(){if(!this.#Z){this.#Z=U(()=>{if(this.#Q=!0,!x(this.#J))this.#Z?.stop()});let $=M(this.#G[q]);this.#Z.on(S,()=>{if($)$();this.#Z=void 0})}return this.#Z}get[Symbol.toStringTag](){return Z$}get(){if(I(this.#J),h(),this.#Q){let $=this.#x();R($,()=>{if(this.#B)throw new T("memo");let J;this.#B=!0;try{J=this.#z(this.#X)}catch(z){this.#X=B,this.#$=W(z),this.#B=!1;return}if(J==null||B===J)this.#X=B,this.#$=void 0;else this.#X=J,this.#$=void 0,this.#Q=!1;this.#B=!1})}if(this.#$)throw this.#$;return this.#X}on($,J){if($===q)return this.#G[q]||=new Set,this.#G[q].add(J),()=>{this.#G[q]?.delete(J)};throw new N(this.constructor.name,$)}}class o{#J=new Set;#z;#X;#$;#Q=!0;#B=!1;#Z=!1;#G;#x;#q={};constructor($,J=B){m(this.constructor.name,$,B$),Y(this.constructor.name,J),this.#z=$,this.#X=J}#M(){if(!this.#G){this.#G=U(()=>{if(this.#Q=!0,this.#x?.abort(),!x(this.#J))this.#G?.stop()});let $=M(this.#q[q]);this.#G.on(S,()=>{if(this.#x?.abort(),this.#x=void 0,$)$();this.#G=void 0})}return this.#G}get[Symbol.toStringTag](){return Z$}get(){I(this.#J),h();let $=(Q)=>{if(!A(Q,this.#X))this.#X=Q,this.#Z=!0;this.#$=void 0,this.#Q=!1},J=()=>{this.#Z=B!==this.#X,this.#X=B,this.#$=void 0},z=(Q)=>{let G=W(Q);this.#Z=!this.#$||G.name!==this.#$.name||G.message!==this.#$.message,this.#X=B,this.#$=G},X=(Q)=>(G)=>{if(this.#B=!1,this.#x=void 0,Q(G),this.#Z&&!x(this.#J))this.#G?.stop()},Z=()=>R(this.#M(),()=>{if(this.#B)throw new T("task");if(this.#Z=!1,this.#x)return this.#X;this.#x=new AbortController,this.#x.signal.addEventListener("abort",()=>{this.#B=!1,this.#x=void 0,Z()},{once:!0});let Q;this.#B=!0;try{Q=this.#z(this.#X,this.#x.signal)}catch(G){if(O(G))J();else z(G);this.#B=!1;return}if(Q instanceof Promise)Q.then(X($),X(z));else if(Q==null||B===Q)J();else $(Q);this.#B=!1});if(this.#Q)Z();if(this.#$)throw this.#$;return this.#X}on($,J){if($===q)return this.#q[q]||=new Set,this.#q[q].add(J),()=>{this.#q[q]?.delete(J)};throw new N(this.constructor.name,$)}}var L$=($,J=B)=>V($)?new o($,J):new u($,J),U$=($)=>L($,Z$),Q$=($)=>W$($)&&$.length<2,B$=($)=>V($)&&$.length<3;class i{signals=new Map;#J;#z;#X=new Map;#$={};#Q=!1;constructor($,J,z){this.#J=J,this.#z=z,this.change({add:$,change:{},remove:{},changed:!0},!0)}#B($){let J=U(()=>{R(J,()=>{if(this.signals.get($)?.get(),!this.#Q)M(this.#$.change,[$])})});this.#X.set($,J),J()}add($,J){if(!this.#J($,J))return!1;if(this.signals.set($,this.#z(J)),this.#$.change?.size)this.#B($);if(!this.#Q)M(this.#$.add,[$]);return!0}remove($){if(!this.signals.delete($))return!1;let z=this.#X.get($);if(z)z.stop(),this.#X.delete($);if(!this.#Q)M(this.#$.remove,[$]);return!0}change($,J){if(this.#Q=!0,Object.keys($.add).length){for(let X in $.add)this.add(X,$.add[X]);let z=()=>M(this.#$.add,Object.keys($.add));if(J)setTimeout(z,0);else z()}if(Object.keys($.change).length)I$(()=>{for(let z in $.change){let X=$.change[z];if(!this.#J(z,X))continue;let Z=this.signals.get(z);if(R$(`list item "${z}"`,X,Z))Z.set(X)}}),M(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let z in $.remove)this.remove(z);M(this.#$.remove,Object.keys($.remove))}return this.#Q=!1,$.changed}clear(){let $=Array.from(this.signals.keys());return this.signals.clear(),this.#X.clear(),M(this.#$.remove,$),!0}on($,J){if(this.#$[$]||=new Set,this.#$[$].add(J),$===K&&!this.#X.size){this.#Q=!0;for(let z of this.signals.keys())this.#B(z);this.#Q=!1}return()=>{if(this.#$[$]?.delete(J),$===K&&!this.#$.change?.size){if(this.#X.size){for(let z of this.#X.values())z.stop();this.#X.clear()}}}}}var N$="State";class H{#J=new Set;#z;constructor($){Y("state",$),this.#z=$}get[Symbol.toStringTag](){return N$}get(){return I(this.#J),this.#z}set($){if(Y("state",$),A(this.#z,$))return;if(this.#z=$,this.#J.size)x(this.#J);if(B===this.#z)this.#J.clear()}update($){m("state update",$),this.set($(this.#z))}}var G$=($)=>L($,N$);var g="List";class s{#J;#z=new Set;#X={};#$=[];#Q;constructor($,J){Y(g,$,Array.isArray);let z=0;this.#Q=J$(J)?()=>`${J}${z++}`:D(J)?(X)=>J(X):()=>String(z++),this.#J=new i(this.#B($),(X,Z)=>{return Y(`${g} for key "${X}"`,Z),!0},(X)=>new H(X))}#B($){let J={};for(let z=0;z<$.length;z++){let X=$[z];if(X===void 0)continue;let Z=this.#$[z];if(!Z)Z=this.#Q(X),this.#$[z]=Z;J[Z]=X}return J}get#Z(){return this.#$.map(($)=>this.#J.signals.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return g}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let J=this.#J.signals.get($);if(J)yield J}}get length(){return I(this.#z),this.#$.length}get(){return I(this.#z),this.#Z}set($){if(B===$){this.#J.clear(),x(this.#z),this.#z.clear();return}let J=this.#Z,z=k(this.#B(J),this.#B($)),X=Object.keys(z.remove);if(this.#J.change(z)){for(let Q of X){let G=this.#$.indexOf(Q);if(G!==-1)this.#$.splice(G,1)}this.#$=this.#$.filter(()=>!0),x(this.#z)}}update($){this.set($(this.get()))}at($){return this.#J.signals.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#J.signals.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let J=this.#Q($);if(this.#J.signals.has(J))throw new p("store",J,$);if(!this.#$.includes(J))this.#$.push(J);if(this.#J.add(J,$))x(this.#z);return J}remove($){let J=z$($)?this.#$[$]:$;if(this.#J.remove(J)){let X=z$($)?$:this.#$.indexOf(J);if(X>=0)this.#$.splice(X,1);this.#$=this.#$.filter(()=>!0),x(this.#z)}}sort($){let z=this.#$.map((X)=>[X,this.#J.signals.get(X)?.get()]).sort(D($)?(X,Z)=>$(X[1],Z[1]):(X,Z)=>String(X[1]).localeCompare(String(Z[1]))).map(([X])=>X);if(!A(this.#$,z))this.#$=z,x(this.#z),M(this.#X.sort,this.#$)}splice($,J,...z){let X=this.#$.length,Z=$<0?Math.max(0,X+$):Math.min($,X),Q=Math.max(0,Math.min(J??Math.max(0,X-Math.max(0,Z)),X-Z)),G={},j={};for(let _=0;_<Q;_++){let F=Z+_,E=this.#$[F];if(E){let y=this.#J.signals.get(E);if(y)j[E]=y.get()}}let b=this.#$.slice(0,Z);for(let _ of z){let F=this.#Q(_);b.push(F),G[F]=_}b.push(...this.#$.slice(Z+Q));let a=!!(Object.keys(G).length||Object.keys(j).length);if(a)this.#J.change({add:G,change:{},remove:j,changed:a}),this.#$=b.filter(()=>!0),x(this.#z);return Object.values(j)}on($,J){if($$($,[d,q]))return this.#X[$]||=new Set,this.#X[$].add(J),()=>{this.#X[$]?.delete(J)};else if($$($,[v,K,n]))return this.#J.on($,J);throw new N(g,$)}deriveCollection($){return new c(this,$)}}var t=($)=>L($,g);var P$="Store";class A${#J;#z=new Set;constructor($){Y("store",$,P),this.#J=new i($,(J,z)=>{return Y(`store for key "${J}"`,z),!0},(J)=>m$(J))}get#X(){let $={};for(let[J,z]of this.#J.signals.entries())$[J]=z.get();return $}get[Symbol.toStringTag](){return P$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,J]of this.#J.signals.entries())yield[$,J]}get(){return I(this.#z),this.#X}set($){if(B===$){this.#J.clear(),x(this.#z),this.#z.clear();return}let J=this.#X;if(this.#J.change(k(J,$)))x(this.#z)}keys(){return this.#J.signals.keys()}byKey($){return this.#J.signals.get($)}update($){this.set($(this.get()))}add($,J){if(this.#J.signals.has($))throw new p("store",$,J);if(this.#J.add($,J))x(this.#z);return $}remove($){if(this.#J.remove($))x(this.#z)}on($,J){return this.#J.on($,J)}}var x$=($)=>{let J=new A$($);return new Proxy(J,{get(z,X){if(X in z){let Z=Reflect.get(z,X);return D(Z)?Z.bind(z):Z}if(!w(X))return z.byKey(X)},has(z,X){if(X in z)return!0;return z.byKey(String(X))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,X){if(X in z)return Reflect.getOwnPropertyDescriptor(z,X);if(w(X))return;let Z=z.byKey(String(X));return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},q$=($)=>L($,P$);var w$=($)=>G$($)||U$($)||q$($),K$=($)=>G$($)||q$($)||t($);function O$($){if(Q$($))return new u($);if(B$($))return new o($);if(j$($))return new s($);if(P($))return x$($);return new H($)}function m$($){if(j$($))return new s($);if(P($))return x$($);return new H($)}class T extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class p extends Error{constructor($,J,z){super(`Could not add ${$} key "${J}"${z?` with value ${f(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class r extends TypeError{constructor($,J){super(`Invalid ${$} callback ${f(J)}`);this.name="InvalidCallbackError"}}class M$ extends TypeError{constructor($,J){super(`Invalid ${$} source ${f(J)}`);this.name="InvalidCollectionSourceError"}}class N extends TypeError{constructor($,J){super(`Invalid hook "${J}" in  ${$}`);this.name="InvalidHookError"}}class S$ extends TypeError{constructor($,J){super(`Invalid signal value ${f(J)} in ${$}`);this.name="InvalidSignalValueError"}}class T$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class _$ extends Error{constructor($,J){super(`Could not set ${$} to ${f(J)} because signal is read-only`);this.name="ReadonlySignalError"}}var W=($)=>$ instanceof Error?$:Error(String($)),m=($,J,z=D)=>{if(!z(J))throw new r($,J)},Y=($,J,z=()=>!(w(J)&&J!==B)||D(J))=>{if(J==null)throw new T$($);if(!z(J))throw new S$($,J)},R$=($,J,z)=>{if(!K$(z))throw new _$($,J);return!0};var l="Collection";class c{#J=new Set;#z;#X;#$=new Map;#Q=new Map;#B={};#Z=[];constructor($,J){if(m(l,J),D($))$=$();if(!g$($))throw new M$(l,$);this.#z=$,this.#X=J;for(let z=0;z<this.#z.length;z++){let X=this.#z.keyAt(z);if(!X)continue;this.#G(X)}this.#z.on(v,(z)=>{if(!z)return;for(let X of z)if(!this.#$.has(X)){this.#G(X);let Z=this.#$.get(X);if(Z&&f$(this.#X))Z.get()}x(this.#J),M(this.#B.add,z)}),this.#z.on(n,(z)=>{if(!z)return;for(let X of z){if(!this.#$.has(X))continue;this.#$.delete(X);let Z=this.#Z.indexOf(X);if(Z>=0)this.#Z.splice(Z,1);let Q=this.#Q.get(X);if(Q)Q.stop(),this.#Q.delete(X)}this.#Z=this.#Z.filter(()=>!0),x(this.#J),M(this.#B.remove,z)}),this.#z.on(d,(z)=>{if(z)this.#Z=[...z];x(this.#J),M(this.#B.sort,z)})}#G($){let J=f$(this.#X)?async(X,Z)=>{let Q=this.#z.byKey($)?.get();if(Q===B)return B;return this.#X(Q,Z)}:()=>{let X=this.#z.byKey($)?.get();if(X===B)return B;return this.#X(X)},z=L$(J);if(this.#$.set($,z),!this.#Z.includes($))this.#Z.push($);if(this.#B.change?.size)this.#x($);return!0}#x($){let J=U(()=>{R(J,()=>{this.#$.get($)?.get()})});this.#Q.set($,J),J()}get[Symbol.toStringTag](){return l}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#Z){let J=this.#$.get($);if(J)yield J}}keys(){return this.#Z.values()}get(){return I(this.#J),this.#Z.map(($)=>this.#$.get($)?.get()).filter(($)=>$!=null&&$!==B)}at($){return this.#$.get(this.#Z[$])}byKey($){return this.#$.get($)}keyAt($){return this.#Z[$]}indexOfKey($){return this.#Z.indexOf($)}on($,J){if(this.#B[$]||=new Set,this.#B[$].add(J),$===K&&!this.#Q.size)for(let z of this.#$.keys())this.#x(z);return()=>{if(this.#B[$]?.delete(J),$===K&&!this.#B.change?.size){if(this.#Q.size){for(let z of this.#Q.values())z.stop();this.#Q.clear()}}}}deriveCollection($){return new c(this,$)}get length(){return I(this.#J),this.#Z.length}}var H$=($)=>L($,l),g$=($)=>t($)||H$($),f$=($)=>V($);var F$="Ref";class E${#J=new Set;#z;#X={};#$;constructor($,J){Y(F$,$,J),this.#z=$}get[Symbol.toStringTag](){return F$}get(){if(I(this.#J))this.#$=M(this.#X[q]);return this.#z}notify(){if(!x(this.#J)&&this.#$)this.#$()}on($,J){if($===q)return this.#X[q]||=new Set,this.#X[q].add(J),()=>{this.#X[q]?.delete(J)};throw new N(this.constructor.name,$)}}var p$=($)=>L($,F$);var b$=($)=>{if(!D($)||$.length>1)throw new r("effect",$);let J=V($),z=!1,X,Z=U(()=>R(Z,()=>{if(z)throw new T("effect");z=!0,X?.abort(),X=void 0;let Q;try{if(J){X=new AbortController;let G=X;$(X.signal).then((j)=>{if(D(j)&&X===G)Z.on(S,j)}).catch((j)=>{if(!O(j))console.error("Async effect error:",j)})}else if(Q=$(),D(Q))Z.on(S,Q)}catch(G){if(!O(G))console.error("Effect callback error:",G)}z=!1}));return Z(),()=>{X?.abort(),Z.stop()}};function y$($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(z){let X=W(z);if(J.err&&(!$.errors||!$.errors.includes(X)))J.err($.errors?[...$.errors,X]:[X]);else throw X}}function v$($){let J=[],z=!1,X={};for(let[Z,Q]of Object.entries($))try{let G=Q.get();if(G===B)z=!0;else X[Z]=G}catch(G){J.push(W(G))}if(z)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:X}}export{f as valueString,Y as validateSignalValue,m as validateCallback,M as triggerHook,R as trackSignalReads,I as subscribeActiveWatcher,v$ as resolve,x as notifyWatchers,y$ as match,B$ as isTaskCallback,w as isSymbol,J$ as isString,q$ as isStore,G$ as isState,w$ as isSignal,p$ as isRef,X$ as isRecordOrArray,P as isRecord,L as isObjectOfType,z$ as isNumber,K$ as isMutableSignal,Q$ as isMemoCallback,t as isList,$$ as isHandledHook,D as isFunction,A as isEqual,U$ as isComputed,H$ as isCollection,V as isAsyncFunction,O as isAbortError,R$ as guardMutableSignal,h as flushPendingReactions,k as diff,U as createWatcher,x$ as createStore,O$ as createSignal,W as createError,b$ as createEffect,L$ as createComputed,I$ as batchSignalWrites,B as UNSET,o as Task,P$ as TYPE_STORE,N$ as TYPE_STATE,F$ as TYPE_REF,g as TYPE_LIST,Z$ as TYPE_COMPUTED,l as TYPE_COLLECTION,H as State,E$ as Ref,_$ as ReadonlySignalError,T$ as NullishSignalValueError,u as Memo,s as List,S$ as InvalidSignalValueError,M$ as InvalidCollectionSourceError,r as InvalidCallbackError,q as HOOK_WATCH,d as HOOK_SORT,n as HOOK_REMOVE,S as HOOK_CLEANUP,K as HOOK_CHANGE,v as HOOK_ADD,p as DuplicateKeyError,c as DerivedCollection,T as CircularDependencyError,A$ as BaseStore};
