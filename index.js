var U,w=new Set,v=0,d=new Map,b,e=()=>{b=void 0;let $=Array.from(d.values());d.clear();for(let B of $)B()},F$=()=>{if(b)cancelAnimationFrame(b);b=requestAnimationFrame(e)};queueMicrotask(e);var f=($)=>{let B=new Set,W=$;return W.off=(J)=>{B.add(J)},W.cleanup=()=>{for(let J of B)J();B.clear()},W},O=($)=>{if(U&&!$.has(U)){let B=U;$.add(B),U.off(()=>{$.delete(B)})}},C=($)=>{for(let B of $)if(v)w.add(B);else B()},g=()=>{while(w.size){let $=Array.from(w);w.clear();for(let B of $)B()}},o=($)=>{v++;try{$()}finally{g(),v--}},y=($,B)=>{let W=U;U=B;try{$()}finally{U=W}},G$=($,B)=>new Promise((W,J)=>{d.set(B||Symbol(),()=>{try{W($())}catch(G){J(G)}}),F$()});var J$=($)=>typeof $==="string",L$=($)=>typeof $==="number",D=($)=>typeof $==="function",k=($)=>D($)&&$.constructor.name==="AsyncFunction",P=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,R=($)=>P($,"Object"),S=($)=>{let B={};for(let W=0;W<$.length;W++)if(W in $)B[String(W)]=$[W];return B},$$=($)=>{if(!$.length)return null;let B=$.map((W)=>J$(W)?parseInt(W,10):L$(W)?W:NaN);return B.every((W)=>Number.isFinite(W)&&W>=0)?B.sort((W,J)=>W-J):null},B$=($,B)=>(B in $)&&D($[B]),V=($)=>$ instanceof DOMException&&$.name==="AbortError",Y=($)=>$ instanceof Error?$:Error(String($));class I extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var c="State",T=($)=>{let B=new Set,W=$,J={[Symbol.toStringTag]:c,get:()=>{return O(B),W},set:(G)=>{if(N(W,G))return;if(W=G,C(B),M===W)B.clear()},update:(G)=>{J.set(G(W))}};return J},p=($)=>P($,c);var n=($)=>{let B=k($),W=!1,J,G=f(()=>y(()=>{if(W)throw new I("effect");W=!0,J?.abort(),J=void 0;let A;try{if(B){J=new AbortController;let Z=J;$(J.signal).then((H)=>{if(D(H)&&J===Z)G.off(H)}).catch((H)=>{if(!V(H))console.error("Async effect error:",H)})}else if(A=$(),D(A))G.off(A)}catch(Z){if(!V(Z))console.error("Effect callback error:",Z)}W=!1},G));return G(),()=>{J?.abort(),G.cleanup()}};var u="Store";function m($){let B=new Set,W=new EventTarget,J=Array.isArray($)?S($):$,G=new Map,A=new Map,Z=T(0),H=()=>{let Q=Array.from(G.keys()),X=$$(Q);if(X)return X.map((L)=>G.get(String(L))?.get());let F={};for(let[L,x]of G)F[L]=x.get();return F},z=(Q,X)=>W.dispatchEvent(new CustomEvent(Q,{detail:X})),K=(Q,X)=>{let F=String(Q),L=i(X);G.set(F,L);let x=n(()=>{let E=L.get();if(E!=null)z("store-change",{[Q]:E})});A.set(F,x)},q=(Q)=>{let X=String(Q);G.delete(X);let F=A.get(X);if(F)F();A.delete(X)},j=(Q,X)=>{let F=t(Q,X);return o(()=>{if(Object.keys(F.add).length){for(let L in F.add){let x=F.add[L];if(x!=null)K(L,x)}z("store-add",F.add)}if(Object.keys(F.change).length){for(let L in F.change){let x=G.get(L),E=F.change[L];if(x&&E!=null&&B$(x,"set"))x.set(E)}z("store-change",F.change)}if(Object.keys(F.remove).length){for(let L in F.remove)q(L);z("store-remove",F.remove)}Z.set(G.size)}),F.changed};j({},$),setTimeout(()=>{let Q=new CustomEvent("store-add",{detail:J});W.dispatchEvent(Q)},0);let _=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(Q,X){switch(X){case"add":return(F,L)=>{if(!G.has(F))K(F,L),C(B),z("store-add",{[F]:L}),Z.set(G.size)};case"get":return()=>{return O(B),H()};case"remove":return(F)=>{if(G.has(F))q(F),C(B),z("store-remove",{[F]:M}),Z.set(G.size)};case"set":return(F)=>{if(j(H(),F)){if(C(B),M===F)B.clear()}};case"update":return(F)=>{let L=H(),x=F(L);if(j(L,x)){if(C(B),M===x)B.clear()}};case"addEventListener":return W.addEventListener.bind(W);case"removeEventListener":return W.removeEventListener.bind(W);case"dispatchEvent":return W.dispatchEvent.bind(W);case"size":return Z}if(X===Symbol.toStringTag)return u;if(X===Symbol.iterator)return function*(){for(let[F,L]of G)yield[F,L]};return G.get(String(X))},has(Q,X){let F=String(X);return G.has(F)||_.includes(F)||X===Symbol.toStringTag||X===Symbol.iterator},ownKeys(){return Array.from(G.keys()).map((Q)=>String(Q))},getOwnPropertyDescriptor(Q,X){let F=G.get(String(X));return F?{enumerable:!0,configurable:!0,writable:!0,value:F}:void 0}})}var h=($)=>P($,u);var M=Symbol(),W$=($)=>p($)||l($)||h($);function Q$($){if(W$($))return $;if(r($))return s($);if(Array.isArray($))return m(S($));if(R($))return m($);return T($)}function i($){if(p($)||h($))return $;if(Array.isArray($))return m(S($));if(R($))return m($);return T($)}var N=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new I("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let J=0;J<$.length;J++)if(!N($[J],B[J],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(R($)&&R(B)){let J=Object.keys($),G=Object.keys(B);if(J.length!==G.length)return!1;for(let A of J){if(!(A in B))return!1;if(!N($[A],B[A],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},t=($,B)=>{let W=new WeakSet;return((G,A)=>{let Z={},H={},z={},K=Object.keys(G),q=Object.keys(A),j=new Set([...K,...q]);for(let Q of j){let X=Q in G,F=Q in A;if(!X&&F){Z[Q]=A[Q];continue}else if(X&&!F){z[Q]=M;continue}let L=G[Q],x=A[Q];if(!N(L,x,W))H[Q]=x}return{changed:Object.keys(Z).length>0||Object.keys(H).length>0||Object.keys(z).length>0,add:Z,change:H,remove:z}})($,B)};var a="Computed",s=($)=>{let B=new Set,W=M,J,G,A=!0,Z=!1,H=!1,z=(F)=>{if(!N(F,W))W=F,Z=!0;J=void 0,A=!1},K=()=>{Z=M!==W,W=M,J=void 0},q=(F)=>{let L=Y(F);Z=!J||L.name!==J.name||L.message!==J.message,W=M,J=L},j=(F)=>(L)=>{if(H=!1,G=void 0,F(L),Z)C(B)},_=f(()=>{if(A=!0,G?.abort(),B.size)C(B);else _.cleanup()});_.off(()=>{G?.abort()});let Q=()=>y(()=>{if(H)throw new I("computed");if(Z=!1,k($)){if(G)return W;G=new AbortController,G.signal.addEventListener("abort",()=>{H=!1,G=void 0,Q()},{once:!0})}let F;H=!0;try{F=G?$(G.signal):$()}catch(L){if(V(L))K();else q(L);H=!1;return}if(F instanceof Promise)F.then(j(z),j(q));else if(F==null||M===F)K();else z(F);H=!1},_);return{[Symbol.toStringTag]:a,get:()=>{if(O(B),g(),A)Q();if(J)throw J;return W}}},l=($)=>P($,a),r=($)=>D($)&&$.length<2;function X$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(Y(W))))B.err($.errors?[...$.errors,Y(W)]:[Y(W)]);else throw W}}function Z$($){let B=[],W=!1,J={};for(let[G,A]of Object.entries($))try{let Z=A.get();if(Z===M)W=!0;else J[G]=Z}catch(Z){B.push(Y(Z))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:J}}export{f as watch,Q$ as toSignal,i as toMutableSignal,Y as toError,O as subscribe,m as store,T as state,Z$ as resolve,y as observe,C as notify,X$ as match,h as isStore,p as isState,W$ as isSignal,D as isFunction,N as isEqual,r as isComputedCallback,l as isComputed,k as isAsyncFunction,V as isAbortError,g as flush,G$ as enqueue,n as effect,t as diff,s as computed,o as batch,S as arrayToRecord,M as UNSET,u as TYPE_STORE,c as TYPE_STATE,a as TYPE_COMPUTED,I as CircularDependencyError};
