var D,b=new Set,g=0,k=new Map,m,n=()=>{m=void 0;let $=Array.from(k.values());k.clear();for(let B of $)B()},p=()=>{if(m)cancelAnimationFrame(m);m=requestAnimationFrame(n)};queueMicrotask(n);var P=($)=>{let B=new Set,W=$;return W.off=(G)=>{B.add(G)},W.cleanup=()=>{for(let G of B)G();B.clear()},W},_=($)=>{if(D&&!$.has(D)){let B=D;$.add(B),D.off(()=>{$.delete(B)})}},N=($)=>{for(let B of $)if(g)b.add(B);else B()},w=()=>{while(b.size){let $=Array.from(b);b.clear();for(let B of $)B()}},o=($)=>{g++;try{$()}finally{w(),g--}},T=($,B)=>{let W=D;D=B;try{$()}finally{D=W}},l=($,B)=>new Promise((W,G)=>{k.set(B||Symbol(),()=>{try{W($())}catch(K){G(K)}}),p()});var I=($)=>typeof $==="function",f=($)=>I($)&&$.constructor.name==="AsyncFunction",R=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,O=($)=>$ instanceof DOMException&&$.name==="AbortError",q=($)=>$ instanceof Error?$:Error(String($));class U extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var y="State",x=($)=>{let B=new Set,W=$,G={[Symbol.toStringTag]:y,get:()=>{return _(B),W},set:(K)=>{if(Object.is(W,K))return;if(W=K,N(B),A===W)B.clear()},update:(K)=>{G.set(K(W))}};return G},C=($)=>R($,y);var S="Store",i=($)=>{let B=new Map,W=x([]),G=x([]),K=x([]),j,Q=(z,H)=>{if(typeof H==="function")throw Error(`Functions are not allowed as store property values (property: ${z})`);if(R(H,"Object"))return i(H);else return x(H)};for(let[z,H]of Object.entries($))B.set(z,Q(z,H));j=x(B.size);let F=new Proxy({},{get(z,H){if(H===Symbol.toStringTag)return S;if(H===Symbol.iterator)return function*(){for(let[J,L]of B.entries())yield[J,L]};if(H==="clear")return()=>{let J=[],L=Date.now();for(let[X,M]of B.entries())if(J.push({key:X,oldValue:C(M)?M.get():M.toObject?.()||{},timestamp:L}),C(M))M.set(A);if(B.clear(),j.set(0),J.length>0)K.update((X)=>[...X,...J])};if(H==="delete")return(J)=>{let L=B.get(J);if(!L)return!1;let X=C(L)?L.get():L.toObject?.()||{},M=Date.now();if(C(L))L.set(A);return B.delete(J),j.set(B.size),K.update((V)=>[...V,{key:J,oldValue:X,timestamp:M}]),!0};if(H==="entries")return function*(){for(let[J,L]of B.entries())yield[J,L]};if(H==="forEach")return(J)=>{for(let[L,X]of B.entries())J(X,L,F)};if(H==="get")return(J)=>{return B.get(J)};if(H==="has")return(J)=>{return B.has(J)};if(H==="keys")return function*(){yield*B.keys()};if(H==="set")return(J,L)=>{let X=B.has(J),M=Date.now();if(X){let V=B.get(J),Z=C(V)?V.get():V.toObject?.()||{};if(C(V))V.set(A);let Y=Q(J,L);B.set(J,Y),G.update((s)=>[...s,{key:J,value:L,oldValue:Z,timestamp:M}])}else{let V=Q(J,L);B.set(J,V),j.set(B.size),W.update((Z)=>[...Z,{key:J,value:L,timestamp:M}])}return F};if(H==="values")return function*(){yield*B.values()};if(H==="size")return E(()=>j.get());if(H==="toObject")return()=>{let J={};for(let[L,X]of B)J[L]=C(X)?X.get():X.toObject();return J};if(H==="additions")return W;if(H==="mutations")return G;if(H==="deletions")return K;return},has(z,H){return H==="clear"||H==="delete"||H==="entries"||H==="forEach"||H==="get"||H==="has"||H==="keys"||H==="set"||H==="values"||H==="size"||H==="toObject"||H==="additions"||H==="mutations"||H==="deletions"||H===Symbol.toStringTag||H===Symbol.iterator},ownKeys(z){return Array.from(B.keys())},getOwnPropertyDescriptor(z,H){if(this.has?.(z,H))return{enumerable:!0,configurable:!0};return}});return F},h=($)=>R($,S);var A=Symbol(),u=($)=>C($)||d($)||h($),a=($)=>u($)?$:v($)?E($):x($);var c="Computed",E=($)=>{let B=new Set,W=A,G,K,j=!0,Q=!1,F=!1,z=(Z)=>{if(!Object.is(Z,W))W=Z,Q=!0;G=void 0,j=!1},H=()=>{Q=A!==W,W=A,G=void 0},J=(Z)=>{let Y=q(Z);Q=!G||Y.name!==G.name||Y.message!==G.message,W=A,G=Y},L=(Z)=>(Y)=>{if(F=!1,K=void 0,Z(Y),Q)N(B)},X=P(()=>{if(j=!0,K?.abort(),B.size)N(B);else X.cleanup()});X.off(()=>{K?.abort()});let M=()=>T(()=>{if(F)throw new U("computed");if(Q=!1,f($)){if(K)return W;K=new AbortController,K.signal.addEventListener("abort",()=>{F=!1,K=void 0,M()},{once:!0})}let Z;F=!0;try{Z=K?$(K.signal):$()}catch(Y){if(O(Y))H();else J(Y);F=!1;return}if(Z instanceof Promise)Z.then(L(z),L(J));else if(Z==null||A===Z)H();else z(Z);F=!1},X);return{[Symbol.toStringTag]:c,get:()=>{if(_(B),w(),j)M();if(G)throw G;return W}}},d=($)=>R($,c),v=($)=>I($)&&$.length<2;var t=($)=>{let B=f($),W=!1,G,K=P(()=>T(()=>{if(W)throw new U("effect");W=!0,G?.abort(),G=void 0;let j;try{if(B){G=new AbortController;let Q=G;$(G.signal).then((F)=>{if(I(F)&&G===Q)K.off(F)}).catch((F)=>{if(!O(F))console.error("Async effect error:",F)})}else if(j=$(),I(j))K.off(j)}catch(Q){if(!O(Q))console.error("Effect callback error:",Q)}W=!1},K));return K(),()=>{G?.abort(),K.cleanup()}};function r($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(q(W)))){let G=$.errors?[...$.errors,q(W)]:[q(W)];B.err(G)}else throw W}}function e($){let B=[],W=!1,G={};for(let[K,j]of Object.entries($))try{let Q=j.get();if(Q===A)W=!0;else G[K]=Q}catch(Q){B.push(q(Q))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:G}}export{P as watch,a as toSignal,q as toError,_ as subscribe,i as store,x as state,e as resolve,T as observe,N as notify,r as match,h as isStore,C as isState,u as isSignal,I as isFunction,v as isComputedCallback,d as isComputed,f as isAsyncFunction,O as isAbortError,w as flush,l as enqueue,t as effect,E as computed,o as batch,A as UNSET,S as TYPE_STORE,y as TYPE_STATE,c as TYPE_COMPUTED,U as CircularDependencyError};
