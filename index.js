var M,V=new WeakMap,U$=new WeakMap,Y$=new WeakMap,s=new Set,B$=0,Z=Symbol(),Y=($,G)=>{let J=new Set,z=$;return z.run=()=>{let Q=M;M=z;try{G()}finally{M=Q}},z.onCleanup=(Q)=>{J.add(Q)},z.stop=()=>{try{for(let Q of J)Q()}finally{J.clear()}},z},q$=($)=>{let G=M;M=void 0;try{$()}finally{M=G}},K=($,G,J)=>{if(U$.set($,G),J)Y$.set($,J)},q=($)=>{if(!M||V.get($)?.has(M))return!1;let G=M;if(!V.has($))V.set($,new Set);let J=V.get($);if(j$(J),!J.size){let z=U$.get($);if(z)q$(z)}return J.add(G),G.onCleanup(()=>{if(J.delete(G),!J.size){let z=Y$.get($);if(z)q$(z)}}),!0};var C=($)=>{let G=V.get($);if(!G)return;for(let J of G)J.stop();G.clear()},x=($)=>{let G=V.get($);if(!G?.size)return!1;for(let J of G)if(B$)s.add(J);else J();return!0};var y=()=>{while(s.size){let $=Array.from(s);s.clear();for(let G of $)G()}},d=($)=>{B$++;try{$()}finally{y(),B$--}},C$=($,G)=>{let J=M;M=$||void 0;try{G()}finally{M=J}};var l=($)=>typeof $==="string",a=($)=>typeof $==="number",E=($)=>typeof $==="symbol",H=($)=>typeof $==="function",j=($)=>H($)&&$.constructor.name==="AsyncFunction",P$=($)=>H($)&&$.constructor.name!=="AsyncFunction",A$=($)=>$!=null&&typeof $==="object",I=($,G)=>Object.prototype.toString.call($)===`[object ${G}]`,L=($)=>I($,"Object"),e=($)=>L($)||Array.isArray($),H$=($,G=(J)=>J!=null)=>Array.isArray($)&&$.every(G);var T=($)=>$ instanceof DOMException&&$.name==="AbortError",_=($)=>l($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var N=($,G,J)=>{if(Object.is($,G))return!0;if(typeof $!==typeof G)return!1;if(!A$($)||!A$(G))return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(G))throw new R("isEqual");J.add($),J.add(G);try{if(Array.isArray($)&&Array.isArray(G)){if($.length!==G.length)return!1;for(let z=0;z<$.length;z++)if(!N($[z],G[z],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(G))return!1;if(L($)&&L(G)){let z=Object.keys($),Q=Object.keys(G);if(z.length!==Q.length)return!1;for(let X of z){if(!(X in G))return!1;if(!N($[X],G[X],J))return!1}return!0}return!1}finally{J.delete($),J.delete(G)}},k=($,G)=>{let J=e($),z=e(G);if(!J||!z){let A=!Object.is($,G);return{changed:A,add:A&&z?G:{},change:{},remove:A&&J?$:{}}}let Q=new WeakSet,X={},B={},F={},g=Object.keys($),t=Object.keys(G),U=new Set([...g,...t]);for(let A of U){let S=A in $,b=A in G;if(!S&&b){X[A]=G[A];continue}else if(S&&!b){F[A]=Z;continue}let V$=$[A],R$=G[A];if(!N(V$,R$,Q))B[A]=R$}return{add:X,change:B,remove:F,changed:!!(Object.keys(X).length||Object.keys(B).length||Object.keys(F).length)}};var $$="Computed";class v{#G;#$;#J;#z=!0;#Q=!1;#X;constructor($,G){m(this.constructor.name,$,G$);let J=G?.initialValue??Z;if(D(this.constructor.name,J,G?.guard),this.#G=$,this.#$=J,G?.watched)K(this,G.watched,G.unwatched)}#Z(){return this.#X||=Y(()=>{if(this.#z=!0,!x(this))this.#X?.stop()},()=>{if(this.#Q)throw new R("memo");let $;this.#Q=!0;try{$=this.#G(this.#$)}catch(G){this.#$=Z,this.#J=P(G),this.#Q=!1;return}if($==null||Z===$)this.#$=Z,this.#J=void 0;else this.#$=$,this.#J=void 0,this.#z=!1;this.#Q=!1}),this.#X.onCleanup(()=>{this.#X=void 0}),this.#X}get[Symbol.toStringTag](){return $$}get(){if(q(this),y(),this.#z)this.#Z().run();if(this.#J)throw this.#J;return this.#$}}class h{#G;#$;#J;#z=!0;#Q=!1;#X=!1;#Z;#x;constructor($,G){m(this.constructor.name,$,J$);let J=G?.initialValue??Z;if(D(this.constructor.name,J,G?.guard),this.#G=$,this.#$=J,G?.watched)K(this,G.watched,G.unwatched)}#B(){if(!this.#Z){let $=(Q)=>{if(!N(Q,this.#$))this.#$=Q,this.#X=!0;this.#J=void 0,this.#z=!1},G=()=>{this.#X=Z!==this.#$,this.#$=Z,this.#J=void 0},J=(Q)=>{let X=P(Q);this.#X=!this.#J||X.name!==this.#J.name||X.message!==this.#J.message,this.#$=Z,this.#J=X},z=(Q)=>(X)=>{if(this.#Q=!1,this.#x=void 0,Q(X),this.#X&&!x(this))this.#Z?.stop()};this.#Z=Y(()=>{if(this.#z=!0,this.#x?.abort(),!x(this))this.#Z?.stop()},()=>{if(this.#Q)throw new R("task");if(this.#X=!1,this.#x)return this.#$;this.#x=new AbortController,this.#x.signal.addEventListener("abort",()=>{this.#Q=!1,this.#x=void 0,this.#B().run()},{once:!0});let Q;this.#Q=!0;try{Q=this.#G(this.#$,this.#x.signal)}catch(X){if(T(X))G();else J(X);this.#Q=!1;return}if(Q instanceof Promise)Q.then(z($),z(J));else if(Q==null||Z===Q)G();else $(Q);this.#Q=!1}),this.#Z.onCleanup(()=>{this.#x?.abort(),this.#x=void 0,this.#Z=void 0})}return this.#Z}get[Symbol.toStringTag](){return $$}get(){if(q(this),y(),this.#z)this.#B().run();if(this.#J)throw this.#J;return this.#$}}var D$=($,G)=>j($)?new h($,G):new v($,G),F$=($)=>I($,$$),G$=($)=>P$($)&&$.length<2,J$=($)=>j($)&&$.length<3;var f="State";class W{#G;constructor($,G){if(D(f,$,G?.guard),this.#G=$,G?.watched)K(this,G.watched,G.unwatched)}get[Symbol.toStringTag](){return f}get(){return q(this),this.#G}set($){if(D(f,$),N(this.#G,$))return;if(this.#G=$,x(this),Z===this.#G)C(this)}update($){m(`${f} update`,$),this.set($(this.#G))}}var z$=($)=>I($,f);var O="List";class o{#G=new Map;#$=[];#J;#z;constructor($,G){D(O,$,Array.isArray);let J=0,z=G?.keyConfig;if(this.#J=l(z)?()=>`${z}${J++}`:H(z)?(Q)=>z(Q):()=>String(J++),this.#z=(Q,X)=>{return D(`${O} item for key "${Q}"`,X,G?.guard),!0},this.#Z({add:this.#Q($),change:{},remove:{},changed:!0}),G?.watched)K(this,G.watched,G.unwatched)}#Q($){let G={};for(let J=0;J<$.length;J++){let z=$[J];if(z===void 0)continue;let Q=this.#$[J];if(!Q)Q=this.#J(z),this.#$[J]=Q;G[Q]=z}return G}#X($,G){if(!this.#z($,G))return!1;return this.#G.set($,new W(G)),!0}#Z($){if(Object.keys($.add).length)for(let G in $.add)this.#X(G,$.add[G]);if(Object.keys($.change).length)d(()=>{for(let G in $.change){let J=$.change[G];if(!this.#z(G,J))continue;let z=this.#G.get(G);if(u(`${O} item "${G}"`,J,z))z.set(J)}});if(Object.keys($.remove).length){for(let G in $.remove){this.#G.delete(G);let J=this.#$.indexOf(G);if(J!==-1)this.#$.splice(J,1)}this.#$=this.#$.filter(()=>!0)}return $.changed}get#x(){return this.#$.map(($)=>this.#G.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return O}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let G=this.#G.get($);if(G)yield G}}get length(){return q(this),this.#$.length}get(){return q(this),this.#x}set($){if(Z===$){this.#G.clear(),x(this),C(this);return}let G=k(this.#Q(this.#x),this.#Q($));if(this.#Z(G))x(this)}update($){this.set($(this.get()))}at($){return this.#G.get(this.#$[$])}keys(){return q(this),this.#$.values()}byKey($){return this.#G.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let G=this.#J($);if(this.#G.has(G))throw new w("store",G,$);if(!this.#$.includes(G))this.#$.push(G);if(this.#X(G,$))x(this);return G}remove($){let G=a($)?this.#$[$]:$;if(this.#G.delete(G)){let z=a($)?$:this.#$.indexOf(G);if(z>=0)this.#$.splice(z,1);this.#$=this.#$.filter(()=>!0),x(this)}}sort($){let J=this.#$.map((z)=>[z,this.#G.get(z)?.get()]).sort(H($)?(z,Q)=>$(z[1],Q[1]):(z,Q)=>String(z[1]).localeCompare(String(Q[1]))).map(([z])=>z);if(!N(this.#$,J))this.#$=J,x(this)}splice($,G,...J){let z=this.#$.length,Q=$<0?Math.max(0,z+$):Math.min($,z),X=Math.max(0,Math.min(G??Math.max(0,z-Math.max(0,Q)),z-Q)),B={},F={};for(let U=0;U<X;U++){let A=Q+U,S=this.#$[A];if(S){let b=this.#G.get(S);if(b)F[S]=b.get()}}let g=this.#$.slice(0,Q);for(let U of J){let A=this.#J(U);g.push(A),B[A]=U}g.push(...this.#$.slice(Q+X));let t=!!(Object.keys(B).length||Object.keys(F).length);if(t)this.#Z({add:B,change:{},remove:F,changed:t}),this.#$=g.filter(()=>!0),x(this);return Object.values(F)}deriveCollection($,G){return new i(this,$,G)}}var n=($)=>I($,O);var p="Store";class I${#G=new Map;constructor($,G){if(D(p,$,G?.guard??L),this.#Q({add:$,change:{},remove:{},changed:!0}),G?.watched)K(this,G.watched,G.unwatched)}get#$(){let $={};for(let[G,J]of this.#G.entries())$[G]=J.get();return $}#J($,G){return D(`${p} for key "${$}"`,G),!0}#z($,G){if(!this.#J($,G))return!1;return this.#G.set($,m$(G)),!0}#Q($){if(Object.keys($.add).length)for(let G in $.add)this.#z(G,$.add[G]);if(Object.keys($.change).length)d(()=>{for(let G in $.change){let J=$.change[G];if(!this.#J(G,J))continue;let z=this.#G.get(G);if(u(`list item "${G}"`,J,z))z.set(J)}});if(Object.keys($.remove).length)for(let G in $.remove)this.remove(G);return $.changed}get[Symbol.toStringTag](){return p}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,G]of this.#G.entries())yield[$,G]}keys(){return q(this),this.#G.keys()}byKey($){return this.#G.get($)}get(){return q(this),this.#$}set($){if(Z===$){this.#G.clear(),x(this),C(this);return}if(this.#Q(k(this.#$,$)))x(this)}update($){this.set($(this.get()))}add($,G){if(this.#G.has($))throw new w(p,$,G);if(this.#z($,G))x(this);return $}remove($){if(this.#G.delete($))x(this)}}var Q$=($,G)=>{let J=new I$($,G);return new Proxy(J,{get(z,Q){if(Q in z){let X=Reflect.get(z,Q);return H(X)?X.bind(z):X}if(!E(Q))return z.byKey(Q)},has(z,Q){if(Q in z)return!0;return z.byKey(String(Q))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,Q){if(Q in z)return Reflect.getOwnPropertyDescriptor(z,Q);if(E(Q))return;let X=z.byKey(String(Q));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},X$=($)=>I($,p);var E$=($)=>z$($)||F$($)||X$($),K$=($)=>z$($)||X$($)||n($);function T$($){if(G$($))return new v($);if(J$($))return new h($);if(H$($))return new o($);if(L($))return Q$($);return new W($)}function m$($){if(H$($))return new o($);if(L($))return Q$($);return new W($)}class R extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class w extends Error{constructor($,G,J){super(`Could not add ${$} key "${G}"${J?` with value ${_(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class _$ extends Error{constructor($="unexpected condition"){super(`Assertion failed: ${$}`);this.name="FailedAssertionError"}}class c extends TypeError{constructor($,G){super(`Invalid ${$} callback ${_(G)}`);this.name="InvalidCallbackError"}}class Z$ extends TypeError{constructor($,G){super(`Invalid ${$} source ${_(G)}`);this.name="InvalidCollectionSourceError"}}class M$ extends TypeError{constructor($,G){super(`Invalid signal value ${_(G)} in ${$}`);this.name="InvalidSignalValueError"}}class L$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class N$ extends Error{constructor($,G){super(`Could not set ${$} to ${_(G)} because signal is read-only`);this.name="ReadonlySignalError"}}function j$($,G){if(!$)throw new _$(G)}var P=($)=>$ instanceof Error?$:Error(String($)),m=($,G,J=H)=>{if(!J(G))throw new c($,G)},D=($,G,J=()=>!(E(G)&&G!==Z)||H(G))=>{if(G==null)throw new L$($);if(!J(G))throw new M$($,G)},u=($,G,J)=>{if(!K$(J))throw new N$($,G);return!0};var r="Collection";class i{#G;#$;#J=new Map;#z=[];#Q=!0;#X;constructor($,G,J){if(m(r,G),H($))$=$();if(!f$($))throw new Z$(r,$);this.#G=$,this.#$=G;for(let z=0;z<this.#G.length;z++){let Q=this.#G.keyAt(z);if(!Q)continue;this.#x(Q)}if(J?.watched)K(this,J.watched,J.unwatched)}#Z(){return this.#X||=Y(()=>{if(this.#Q=!0,!x(this))this.#X?.stop()},()=>{let $=Array.from(this.#G.keys()),G=new Set([...this.#z,...$]),J=[],z=[];for(let Q of G){let X=this.#z.includes(Q),B=$.includes(Q);if(!X&&B)J.push(Q);else if(X&&!B)z.push(Q)}for(let Q of z)this.#J.delete(Q);for(let Q of J)this.#x(Q);this.#z=$,this.#Q=!1}),this.#X.onCleanup(()=>{this.#X=void 0}),this.#X}#x($){let G=O$(this.#$)?async(z,Q)=>{let X=this.#G.byKey($)?.get();if(X===Z)return Z;return this.#$(X,Q)}:()=>{let z=this.#G.byKey($)?.get();if(z===Z)return Z;return this.#$(z)},J=D$(G);if(this.#J.set($,J),!this.#z.includes($))this.#z.push($);return!0}get[Symbol.toStringTag](){return r}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#z){let G=this.#J.get($);if(G)yield G}}keys(){if(q(this),this.#Q)this.#Z().run();return this.#z.values()}get(){if(q(this),this.#Q)this.#Z().run();return this.#z.map(($)=>this.#J.get($)?.get()).filter(($)=>$!=null&&$!==Z)}at($){return this.#J.get(this.#z[$])}byKey($){return this.#J.get($)}keyAt($){return this.#z[$]}indexOfKey($){return this.#z.indexOf($)}deriveCollection($,G){return new i(this,$,G)}get length(){if(q(this),this.#Q)this.#Z().run();return this.#z.length}}var W$=($)=>I($,r),f$=($)=>n($)||W$($),O$=($)=>j($);var x$="Ref";class S${#G;constructor($,G){if(D(x$,$,G?.guard),this.#G=$,G?.watched)K(this,G.watched,G.unwatched)}get[Symbol.toStringTag](){return x$}get(){return q(this),this.#G}notify(){x(this)}}var w$=($)=>I($,x$);var p$=($)=>{if(!H($)||$.length>1)throw new c("effect",$);let G=j($),J=!1,z,Q=Y(()=>{Q.run()},()=>{if(J)throw new R("effect");J=!0,z?.abort(),z=void 0;let X;try{if(G){z=new AbortController;let B=z;$(z.signal).then((F)=>{if(H(F)&&z===B)Q.onCleanup(F)}).catch((F)=>{if(!T(F))console.error("Error in async effect callback:",F)})}else if(X=$(),H(X))Q.onCleanup(X)}catch(B){if(!T(B))console.error("Error in effect callback:",B)}J=!1});return Q(),()=>{z?.abort();try{Q.stop()}catch(X){console.error("Error in effect cleanup:",X)}}};function g$($,G){try{if($.pending)G.nil?.();else if($.errors)G.err?.($.errors);else if($.ok)G.ok($.values)}catch(J){let z=P(J);if(G.err&&(!$.errors||!$.errors.includes(z)))G.err($.errors?[...$.errors,z]:[z]);else throw z}}function b$($){let G=[],J=!1,z={};for(let[Q,X]of Object.entries($))try{let B=X.get();if(B===Z)J=!0;else z[Q]=B}catch(B){G.push(P(B))}if(J)return{ok:!1,pending:!0};if(G.length>0)return{ok:!1,errors:G};return{ok:!0,values:z}}export{_ as valueString,D as validateSignalValue,m as validateCallback,q$ as untrack,C$ as track,q as subscribeTo,b$ as resolve,x as notifyOf,g$ as match,J$ as isTaskCallback,E as isSymbol,l as isString,X$ as isStore,z$ as isState,E$ as isSignal,w$ as isRef,e as isRecordOrArray,L as isRecord,I as isObjectOfType,a as isNumber,K$ as isMutableSignal,G$ as isMemoCallback,n as isList,H as isFunction,N as isEqual,F$ as isComputed,W$ as isCollection,j as isAsyncFunction,T as isAbortError,u as guardMutableSignal,y as flush,k as diff,Y as createWatcher,Q$ as createStore,T$ as createSignal,P as createError,p$ as createEffect,D$ as createComputed,d as batch,Z as UNSET,h as Task,p as TYPE_STORE,f as TYPE_STATE,x$ as TYPE_REF,O as TYPE_LIST,$$ as TYPE_COMPUTED,r as TYPE_COLLECTION,W as State,S$ as Ref,N$ as ReadonlySignalError,L$ as NullishSignalValueError,v as Memo,o as List,M$ as InvalidSignalValueError,Z$ as InvalidCollectionSourceError,c as InvalidCallbackError,w as DuplicateKeyError,i as DerivedCollection,R as CircularDependencyError,I$ as BaseStore};
