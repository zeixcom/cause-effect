var q,k=new Set,p=0,h=new Map,f,a=()=>{f=void 0;let $=Array.from(h.values());h.clear();for(let B of $)B()},B$=()=>{if(f)cancelAnimationFrame(f);f=requestAnimationFrame(a)};queueMicrotask(a);var E=($)=>{let B=new Set,W=$;return W.off=(x)=>{B.add(x)},W.cleanup=()=>{for(let x of B)x();B.clear()},W},N=($)=>{if(q&&!$.has(q)){let B=q;$.add(B),q.off(()=>{$.delete(B)})}},C=($)=>{for(let B of $)if(p)k.add(B);else B()},w=()=>{while(k.size){let $=Array.from(k);k.clear();for(let B of $)B()}},d=($)=>{p++;try{$()}finally{w(),p--}},m=($,B)=>{let W=q;q=B;try{$()}finally{q=W}},W$=($,B)=>new Promise((W,x)=>{h.set(B||Symbol(),()=>{try{W($())}catch(J){x(J)}}),B$()});var j=($)=>typeof $==="function",y=($)=>j($)&&$.constructor.name==="AsyncFunction",U=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,_=($)=>U($,"Object"),v=($)=>{let B={};for(let W=0;W<$.length;W++)if(W in $)B[String(W)]=$[W];return B},e=($,B)=>(B in $)&&j($[B]),R=($)=>$ instanceof DOMException&&$.name==="AbortError",Y=($)=>$ instanceof Error?$:Error(String($));class A extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var o="State",V=($)=>{let B=new Set,W=$,x={[Symbol.toStringTag]:o,get:()=>{return N(B),W},set:(J)=>{if(D(W,J))return;if(W=J,C(B),z===W)B.clear()},update:(J)=>{x.set(J(W))}};return x},b=($)=>U($,o);var c=($)=>{let B=y($),W=!1,x,J=E(()=>m(()=>{if(W)throw new A("effect");W=!0,x?.abort(),x=void 0;let Z;try{if(B){x=new AbortController;let F=x;$(x.signal).then((H)=>{if(j(H)&&x===F)J.off(H)}).catch((H)=>{if(!R(H))console.error("Async effect error:",H)})}else if(Z=$(),j(Z))J.off(Z)}catch(F){if(!R(F))console.error("Effect callback error:",F)}W=!1},J));return J(),()=>{x?.abort(),J.cleanup()}};var n="Store",S=($)=>{let B=new Set,W=new EventTarget,x=new Map,J=new Map,Z=V(0),F=()=>{let X={};for(let[Q,G]of x)X[Q]=G.get();return X},H=(X,Q)=>W.dispatchEvent(new CustomEvent(X,{detail:Q})),K=(X,Q)=>{let G=u(Q);x.set(X,G);let L=c(()=>{let M=G.get();if(M!=null)H("store-change",{[X]:M})});J.set(X,L)},P=(X)=>{x.delete(X);let Q=J.get(X);if(Q)Q();J.delete(X)},I=(X,Q)=>{let G=i(X,Q);return d(()=>{if(Object.keys(G.add).length){for(let L in G.add){let M=G.add[L];if(M!=null)K(L,M)}H("store-add",G.add)}if(Object.keys(G.change).length){for(let L in G.change){let M=x.get(L),T=G.change[L];if(M&&T!=null&&e(M,"set"))M.set(T)}H("store-change",G.change)}if(Object.keys(G.remove).length){for(let L in G.remove)P(L);H("store-remove",G.remove)}Z.set(x.size)}),G.changed};I({},$),setTimeout(()=>{let X=new CustomEvent("store-add",{detail:$});W.dispatchEvent(X)},0);let O=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(X,Q){switch(Q){case"add":return(G,L)=>{if(!x.has(G))K(G,L),C(B),H("store-add",{[G]:L}),Z.set(x.size)};case"get":return()=>{return N(B),F()};case"remove":return(G)=>{if(x.has(G))P(G),C(B),H("store-remove",{[G]:z}),Z.set(x.size)};case"set":return(G)=>{if(I(F(),G)){if(C(B),z===G)B.clear()}};case"update":return(G)=>{let L=F(),M=G(L);if(I(L,M)){if(C(B),z===M)B.clear()}};case"addEventListener":return W.addEventListener.bind(W);case"removeEventListener":return W.removeEventListener.bind(W);case"dispatchEvent":return W.dispatchEvent.bind(W);case"size":return Z}if(Q===Symbol.toStringTag)return n;if(Q===Symbol.iterator)return function*(){for(let[G,L]of x)yield[G,L]};return x.get(String(Q))},has(X,Q){let G=String(Q);return x.has(G)||O.includes(G)||Q===Symbol.toStringTag||Q===Symbol.iterator},ownKeys(){return Array.from(x.keys())},getOwnPropertyDescriptor(X,Q){let G=x.get(String(Q));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},g=($)=>U($,n);var z=Symbol(),$$=($)=>b($)||s($)||g($);function x$($){if($$($))return $;if(l($))return t($);if(Array.isArray($))return S(v($));if(_($))return S($);return V($)}function u($){if(b($)||g($))return $;if(Array.isArray($))return S(v($));if(_($))return S($);return V($)}var D=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new A("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let x=0;x<$.length;x++)if(!D($[x],B[x],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(_($)&&_(B)){let x=Object.keys($),J=Object.keys(B);if(x.length!==J.length)return!1;for(let Z of x){if(!(Z in B))return!1;if(!D($[Z],B[Z],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},i=($,B)=>{let W=new WeakSet;return((J,Z)=>{let F={},H={},K={},P=Object.keys(J),I=Object.keys(Z),O=new Set([...P,...I]);for(let Q of O){let G=Q in J,L=Q in Z;if(!G&&L){F[Q]=Z[Q];continue}else if(G&&!L){K[Q]=z;continue}let M=J[Q],T=Z[Q];if(!D(M,T,W))H[Q]=T}return{changed:Object.keys(F).length>0||Object.keys(H).length>0||Object.keys(K).length>0,add:F,change:H,remove:K}})($,B)};var r="Computed",t=($)=>{let B=new Set,W=z,x,J,Z=!0,F=!1,H=!1,K=(L)=>{if(!D(L,W))W=L,F=!0;x=void 0,Z=!1},P=()=>{F=z!==W,W=z,x=void 0},I=(L)=>{let M=Y(L);F=!x||M.name!==x.name||M.message!==x.message,W=z,x=M},O=(L)=>(M)=>{if(H=!1,J=void 0,L(M),F)C(B)},X=E(()=>{if(Z=!0,J?.abort(),B.size)C(B);else X.cleanup()});X.off(()=>{J?.abort()});let Q=()=>m(()=>{if(H)throw new A("computed");if(F=!1,y($)){if(J)return W;J=new AbortController,J.signal.addEventListener("abort",()=>{H=!1,J=void 0,Q()},{once:!0})}let L;H=!0;try{L=J?$(J.signal):$()}catch(M){if(R(M))P();else I(M);H=!1;return}if(L instanceof Promise)L.then(O(K),O(I));else if(L==null||z===L)P();else K(L);H=!1},X);return{[Symbol.toStringTag]:r,get:()=>{if(N(B),w(),Z)Q();if(x)throw x;return W}}},s=($)=>U($,r),l=($)=>j($)&&$.length<2;function G$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(Y(W))))B.err($.errors?[...$.errors,Y(W)]:[Y(W)]);else throw W}}function J$($){let B=[],W=!1,x={};for(let[J,Z]of Object.entries($))try{let F=Z.get();if(F===z)W=!0;else x[J]=F}catch(F){B.push(Y(F))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:x}}export{E as watch,x$ as toSignal,u as toMutableSignal,Y as toError,N as subscribe,S as store,V as state,J$ as resolve,m as observe,C as notify,G$ as match,g as isStore,b as isState,$$ as isSignal,j as isFunction,D as isEqual,l as isComputedCallback,s as isComputed,y as isAsyncFunction,R as isAbortError,w as flush,W$ as enqueue,c as effect,i as diff,t as computed,d as batch,z as UNSET,n as TYPE_STORE,o as TYPE_STATE,r as TYPE_COMPUTED,A as CircularDependencyError};
