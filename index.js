var X=(x)=>typeof x==="function",d=(x)=>X(x)&&x.constructor.name==="AsyncFunction",M=(x,y)=>Object.prototype.toString.call(x)===`[object ${y}]`,c=(x)=>x instanceof Error,I=(x)=>x instanceof DOMException&&x.name==="AbortError",m=(x)=>x instanceof Promise,j=(x)=>c(x)?x:Error(String(x));class V extends Error{constructor(x){super(`Circular dependency in ${x} detected`);return this}}var A,P=new Set,_=0,S=new Map,D,v=()=>{D=void 0;let x=Array.from(S.values());S.clear();for(let y of x)y()},t=()=>{if(D)cancelAnimationFrame(D);D=requestAnimationFrame(v)};queueMicrotask(v);var N=(x)=>{if(A&&!x.has(A)){let y=A;x.add(y),A.cleanups.add(()=>{x.delete(y)})}},F=(x)=>{for(let y of x)if(_)P.add(y);else y()},k=()=>{while(P.size){let x=Array.from(P);P.clear();for(let y of x)y()}},a=(x)=>{_++;try{x()}finally{k(),_--}},Y=(x,y)=>{let z=A;A=y;try{x()}finally{A=z}},r=(x,y)=>new Promise((z,J)=>{let B=()=>{try{z(x())}catch(K){J(K)}};if(y)S.set(y,B);t()});function R(x){let{signals:y,ok:z,err:J=console.error,nil:B=()=>{}}=X(x)?{signals:[],ok:x}:x,K=!1,L=()=>Y(()=>{if(K)throw new V("effect");K=!0;let G=void 0;try{G=T({signals:y,ok:z,err:J,nil:B})}catch(Q){J(j(Q))}if(X(G))L.cleanups.add(G);K=!1},L);return L.cleanups=new Set,L(),()=>{L.cleanups.forEach((G)=>G()),L.cleanups.clear()}}var o="Computed",e=(x,y)=>{if(!y)return!1;return x.name===y.name&&x.message===y.message},O=(x)=>{let y=new Set,z=X(x)?void 0:{nil:()=>Z,err:(...$)=>{if($.length>1)throw new AggregateError($);else throw $[0]},...x},J=z?z.ok:x,B=Z,K,L=!0,G=!1,Q=!1,H,W=($)=>{if(!Object.is($,B))B=$,L=!1,K=void 0,G=!0},g=()=>{G=Z!==B,B=Z,K=void 0},p=($)=>{let C=j($);G=!e(C,K),B=Z,K=C},n=($)=>{if(Q=!1,H=void 0,W($),G)F(y)},u=($)=>{if(Q=!1,H=void 0,p($),G)F(y)},l=()=>{Q=!1,H=void 0,f()},q=()=>{if(L=!0,H?.abort("Aborted because source signal changed"),y.size){if(G)F(y)}else q.cleanups.forEach(($)=>$()),q.cleanups.clear()};q.cleanups=new Set;let f=()=>Y(()=>{if(Q)throw new V("computed");if(G=!1,d(J)){if(H)return B;if(H=new AbortController,z)z.abort=z.abort instanceof AbortSignal?AbortSignal.any([z.abort,H.signal]):H.signal;H.signal.addEventListener("abort",l,{once:!0})}let $;Q=!0;try{$=z&&z.signals.length?T(z):J(H?.signal)}catch(C){I(C)?g():p(C),Q=!1;return}if(m($))$.then(n,u);else if($==null||Z===$)g();else W($);Q=!1},q),U={[Symbol.toStringTag]:o,get:()=>{if(N(y),k(),L)f();if(K)throw K;return B},map:($)=>O({signals:[U],ok:$}),tap:($)=>R({signals:[U],...X($)?{ok:$}:$})};return U},b=(x)=>M(x,o);var s="State",E=(x)=>{let y=new Set,z=x,J={[Symbol.toStringTag]:s,get:()=>{return N(y),z},set:(B)=>{if(Object.is(z,B))return;if(z=B,F(y),Z===z)y.clear()},update:(B)=>{J.set(B(z))},map:(B)=>O({signals:[J],ok:B}),tap:(B)=>R({signals:[J],...X(B)?{ok:B}:B})};return J},w=(x)=>M(x,s);var Z=Symbol(),i=(x)=>w(x)||b(x),h=(x)=>X(x)&&x.length<2,xx=(x)=>i(x)?x:h(x)?O(x):E(x),T=(x)=>{let{signals:y,abort:z,ok:J,err:B,nil:K}=x,L=[],G=!1,Q=y.map((H)=>{try{let W=H.get();if(W===Z)G=!0;return W}catch(W){if(I(W))throw W;L.push(j(W))}});try{return G?K(z):L.length?B(...L):J(...Q)}catch(H){if(I(H))throw H;let W=j(H);return B(W)}};export{Y as watch,xx as toSignal,E as state,w as isState,i as isSignal,h as isComputedCallback,b as isComputed,r as enqueue,R as effect,O as computed,a as batch,Z as UNSET,V as CircularDependencyError};
