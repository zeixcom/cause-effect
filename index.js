var C=(T)=>typeof T==="function",R=(T)=>C(T)&&/^async\s+/.test(T.toString()),Y=(T)=>C(T)&&T.length<2,D=(T)=>(x)=>x instanceof T,Q=D(Error),O=D(Promise);var P="Computed",I=(T,x)=>{x=x??R(T);let F=[],J=q,z=null,K=!0,U=()=>{if(K=!0,x)j(F)},M={[Symbol.toStringTag]:P,get:()=>{if(x)B(F);if(!x||K)G(()=>{let A=(y)=>{J=y,K=!1,z=null},N=(y)=>{z=Q(y)?y:new Error(`Computed function failed: ${y}`)};try{let y=T(J);O(y)?y.then((k)=>{A(k),j(F)}).catch(N):A(y)}catch(y){N(y)}},U);if(Q(z))throw z;return J},map:(A)=>I(()=>A(M.get()))};return M},V=(T)=>!!T&&typeof T==="object"&&T[Symbol.toStringTag]===P;var L,W=!1,X=[],q=Symbol(),S=(T)=>$(T)||V(T),E=(T,x=!1)=>S(T)?T:Y(T)?I(T,x):Z(T),B=(T)=>{if(L&&!T.includes(L))T.push(L)},j=(T)=>T.forEach((x)=>W?X.push(x):x()),G=(T,x)=>{let F=L;L=x,T(),L=F},g=(T)=>{W=!0,T(),W=!1,X.forEach((x)=>x()),X.length=0};class H{T;watchers=[];constructor(T){this.value=T}get(){return B(this.watchers),this.value}set(T){if(Object.is(this.value,T))return;if(this.value=T,j(this.watchers),q===T)this.watchers=[]}update(T){this.set(T(this.value))}map(T){return I(()=>T(this.get()))}}var Z=(T)=>new H(T),$=(T)=>T instanceof H;var p=(T)=>{let x=()=>G(()=>{try{T()}catch(F){console.error(F)}},x);x()};export{E as toSignal,Z as state,$ as isState,S as isSignal,V as isComputed,p as effect,I as computed,g as batch,q as UNSET,H as State};
