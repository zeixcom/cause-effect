var C=Symbol(),w=(B)=>typeof B==="string",LB=(B)=>typeof B==="number",U=(B)=>typeof B==="function",f=(B)=>U(B)&&B.constructor.name==="AsyncFunction",V=(B,W)=>Object.prototype.toString.call(B)===`[object ${W}]`,D=(B)=>V(B,"Object"),E=(B)=>D(B)||Array.isArray(B),v=(B)=>{if(!B.length)return null;let W=B.map((J)=>w(J)?parseInt(J,10):LB(J)?J:NaN);return W.every((J)=>Number.isFinite(J)&&J>=0)?W.sort((J,L)=>J-L):null},QB=(B,W)=>(W in B)&&U(B[W]),j=(B)=>B instanceof DOMException&&B.name==="AbortError",K=(B)=>B instanceof Error?B:Error(String(B)),d=(B)=>{let W=v(Object.keys(B));if(W===null)return B;let J=[];for(let L of W)J.push(B[String(L)]);return J};class P extends Error{constructor(B){super(`Circular dependency in ${B} detected`);this.name="CircularDependencyError"}}var A=(B,W,J)=>{if(Object.is(B,W))return!0;if(typeof B!==typeof W)return!1;if(typeof B!=="object"||B===null||W===null)return!1;if(!J)J=new WeakSet;if(J.has(B)||J.has(W))throw new P("isEqual");J.add(B),J.add(W);try{if(Array.isArray(B)&&Array.isArray(W)){if(B.length!==W.length)return!1;for(let L=0;L<B.length;L++)if(!A(B[L],W[L],J))return!1;return!0}if(Array.isArray(B)!==Array.isArray(W))return!1;if(D(B)&&D(W)){let L=Object.keys(B),$=Object.keys(W);if(L.length!==$.length)return!1;for(let Y of L){if(!(Y in W))return!1;if(!A(B[Y],W[Y],J))return!1}return!0}return!1}finally{J.delete(B),J.delete(W)}},c=(B,W)=>{let J=E(B),L=E(W);if(!J||!L){let Q=!Object.is(B,W);return{changed:Q,add:Q&&L?W:{},change:{},remove:Q&&J?B:{}}}let $=new WeakSet,Y={},H={},z={},x=Object.keys(B),N=Object.keys(W),q=new Set([...x,...N]);for(let Q of q){let Z=Q in B,G=Q in W;if(!Z&&G){Y[Q]=W[Q];continue}else if(Z&&!G){z[Q]=C;continue}let X=B[Q],M=W[Q];if(!A(X,M,$))H[Q]=M}return{changed:Object.keys(Y).length>0||Object.keys(H).length>0||Object.keys(z).length>0,add:Y,change:H,remove:z}};var _,y=new Set,u=0,o=new Map,g,XB=()=>{g=void 0;let B=Array.from(o.values());o.clear();for(let W of B)W()},zB=()=>{if(g)cancelAnimationFrame(g);g=requestAnimationFrame(XB)};queueMicrotask(XB);var T=(B)=>{let W=new Set,J=B;return J.off=(L)=>{W.add(L)},J.cleanup=()=>{for(let L of W)L();W.clear()},J},S=(B)=>{if(_&&!B.has(_)){let W=_;B.add(W),_.off(()=>{B.delete(W)})}},F=(B)=>{for(let W of B)if(u)y.add(W);else W()},b=()=>{while(y.size){let B=Array.from(y);y.clear();for(let W of B)W()}},i=(B)=>{u++;try{B()}finally{b(),u--}},k=(B,W)=>{let J=_;_=W;try{B()}finally{_=J}},HB=(B,W)=>new Promise((J,L)=>{o.set(W||Symbol(),()=>{try{J(B())}catch($){L($)}}),zB()});var t="Computed",s=(B)=>{let W=new Set,J=C,L,$,Y=!0,H=!1,z=!1,x=(X)=>{if(!A(X,J))J=X,H=!0;L=void 0,Y=!1},N=()=>{H=C!==J,J=C,L=void 0},q=(X)=>{let M=K(X);H=!L||M.name!==L.name||M.message!==L.message,J=C,L=M},R=(X)=>(M)=>{if(z=!1,$=void 0,X(M),H)F(W)},Q=T(()=>{if(Y=!0,$?.abort(),W.size)F(W);else Q.cleanup()});Q.off(()=>{$?.abort()});let Z=()=>k(()=>{if(z)throw new P("computed");if(H=!1,f(B)){if($)return J;$=new AbortController,$.signal.addEventListener("abort",()=>{z=!1,$=void 0,Z()},{once:!0})}let X;z=!0;try{X=$?B($.signal):B()}catch(M){if(j(M))N();else q(M);z=!1;return}if(X instanceof Promise)X.then(R(x),R(q));else if(X==null||C===X)N();else x(X);z=!1},Q);return{[Symbol.toStringTag]:t,get:()=>{if(S(W),b(),Y)Z();if(L)throw L;return J}}},n=(B)=>V(B,t),l=(B)=>U(B)&&B.length<2;var a=(B)=>{let W=f(B),J=!1,L,$=T(()=>k(()=>{if(J)throw new P("effect");J=!0,L?.abort(),L=void 0;let Y;try{if(W){L=new AbortController;let H=L;B(L.signal).then((z)=>{if(U(z)&&L===H)$.off(z)}).catch((z)=>{if(!j(z))console.error("Async effect error:",z)})}else if(Y=B(),U(Y))$.off(Y)}catch(H){if(!j(H))console.error("Effect callback error:",H)}J=!1},$));return $(),()=>{L?.abort(),$.cleanup()}};function YB(B,W){try{if(B.pending)W.nil?.();else if(B.errors)W.err?.(B.errors);else if(B.ok)W.ok(B.values)}catch(J){if(W.err&&(!B.errors||!B.errors.includes(K(J))))W.err(B.errors?[...B.errors,K(J)]:[K(J)]);else throw J}}function MB(B){let W=[],J=!1,L={};for(let[$,Y]of Object.entries(B))try{let H=Y.get();if(H===C)J=!0;else L[$]=H}catch(H){W.push(K(H))}if(J)return{ok:!1,pending:!0};if(W.length>0)return{ok:!1,errors:W};return{ok:!0,values:L}}var r="State",m=(B)=>{let W=new Set,J=B,L={[Symbol.toStringTag]:r,get:()=>{return S(W),J},set:($)=>{if(A(J,$))return;if(J=$,F(W),C===J)W.clear()},update:($)=>{L.set($(J))}};return L},p=(B)=>V(B,r);var BB="Store",e="store-add",ZB="store-change",$B="store-remove",O=(B)=>{let W=new Set,J=new EventTarget,L=new Map,$=new Map,Y=m(0),H=()=>{let Q={};for(let[Z,G]of L)Q[String(Z)]=G.get();return Q},z=(Q,Z)=>J.dispatchEvent(new CustomEvent(Q,{detail:Z})),x=(Q,Z)=>{let G=String(Q),X=WB(Z);L.set(G,X);let M=a(()=>{let I=X.get();if(I!=null)z(ZB,{[Q]:I})});$.set(G,M)},N=(Q)=>{let Z=String(Q);L.delete(Z);let G=$.get(Z);if(G)G();$.delete(Z)},q=(Q,Z,G)=>{let X=c(Q,Z);return i(()=>{if(Object.keys(X.add).length){for(let M in X.add){let I=X.add[M];if(I!=null)x(M,I)}if(G)setTimeout(()=>{z(e,X.add)},0);else z(e,X.add)}if(Object.keys(X.change).length){for(let M in X.change){let I=L.get(M),JB=X.change[M];if(I&&JB!=null&&QB(I,"set"))I.set(JB)}z(ZB,X.change)}if(Object.keys(X.remove).length){for(let M in X.remove)N(M);z($B,X.remove)}Y.set(L.size)}),X.changed};q({},B,!0);let R={add:(Q,Z)=>{let G=v(Array.from(L.keys())),X=G?G.length?Math.max(...G)+1:0:Q;if(!L.has(String(X)))x(X,Z),F(W),z(e,{[X]:Z}),Y.set(L.size)},get:()=>{return S(W),d(H())},remove:(Q)=>{if(L.has(String(Q)))N(Q),F(W),z($B,{[Q]:C}),Y.set(L.size)},set:(Q)=>{if(q(H(),Q)){if(F(W),C===Q)W.clear()}},update:(Q)=>{let Z=H(),G=Q(d(Z));if(q(Z,G)){if(F(W),C===G)W.clear()}},addEventListener:J.addEventListener.bind(J),removeEventListener:J.removeEventListener.bind(J),dispatchEvent:J.dispatchEvent.bind(J),size:Y};return new Proxy({},{get(Q,Z){if(w(Z)&&Z in R)return R[Z];if(Z===Symbol.toStringTag)return BB;if(Z===Symbol.iterator)return function*(){for(let[G,X]of L)yield[G,X]};return L.get(String(Z))},has(Q,Z){let G=String(Z);return L.has(G)||Object.keys(R).includes(G)||Z===Symbol.toStringTag||Z===Symbol.iterator},ownKeys(){return Array.from(L.keys()).map((Q)=>String(Q))},getOwnPropertyDescriptor(Q,Z){let G=L.get(String(Z));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},h=(B)=>V(B,BB);var GB=(B)=>p(B)||n(B)||h(B);function CB(B){if(GB(B))return B;if(l(B))return s(B);if(Array.isArray(B))return O(B);if(Array.isArray(B)||D(B))return O(B);return m(B)}function WB(B){if(p(B)||h(B))return B;if(Array.isArray(B))return O(B);if(D(B))return O(B);return m(B)}export{T as watch,CB as toSignal,WB as toMutableSignal,K as toError,S as subscribe,O as store,m as state,MB as resolve,k as observe,F as notify,YB as match,w as isString,h as isStore,p as isState,GB as isSignal,E as isRecordOrArray,D as isRecord,LB as isNumber,U as isFunction,A as isEqual,l as isComputedCallback,n as isComputed,f as isAsyncFunction,j as isAbortError,b as flush,HB as enqueue,a as effect,c as diff,s as computed,i as batch,C as UNSET,BB as TYPE_STORE,r as TYPE_STATE,t as TYPE_COMPUTED,P as CircularDependencyError};
