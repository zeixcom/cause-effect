var N=(x)=>typeof x==="function";var Y=(x,y)=>Object.prototype.toString.call(x)===`[object ${y}]`,_=(x)=>(y)=>y instanceof x,o=_(Error),w=_(Promise),X=(x)=>o(x)?x:Error(String(x));class Z extends Error{constructor(x){super(`Circular dependency in ${x} detected`);return this}}var Q,q=new Set,D=0,k=new Map,P,E=()=>{P=void 0;let x=Array.from(k.values());k.clear();for(let y of x)y()},d=()=>{if(P)cancelAnimationFrame(P);P=requestAnimationFrame(E)};queueMicrotask(E);var M=(x)=>{if(Q&&!x.has(Q)){let y=Q;x.add(y),Q.cleanups.add(()=>{x.delete(y)})}},V=(x)=>{for(let y of x)if(D)q.add(y);else y()},T=()=>{while(q.size){let x=Array.from(q);q.clear();for(let y of x)y()}},h=(x)=>{D++;try{x()}finally{T(),D--}},I=(x,y)=>{let $=Q;Q=y;try{x()}finally{Q=$}},s=(x,y)=>new Promise(($,F)=>{let B=()=>{try{$(x())}catch(L){F(L)}};if(y)k.set(y,B);d()});function R({signals:x,ok:y,err:$=console.error,nil:F=()=>{}}){let B=!1,L=()=>I(()=>{if(B)throw new Z("effect");B=!0;let H=[],j=!1,C=x.map((W)=>{try{let K=W.get();if(K===G)j=!0;return K}catch(K){H.push(X(K))}});try{j?F():H.length?$(...H):y(...C)}catch(W){$(X(W))}B=!1},L);return L.cleanups=new Set,L(),()=>{L.cleanups.forEach((H)=>H()),L.cleanups.clear()}}var g="Computed",i=(x,y)=>{if(!y)return!1;return x.name===y.name&&x.message===y.message},A=(x)=>{let y=new Set,$=G,F,B=!0,L=!1,H=!1,j=(z)=>{if(!Object.is(z,$))$=z,B=!1,F=void 0,L=!1},C=()=>{L=G===$,$=G,F=void 0},W=(z)=>{let J=X(z);L=i(J,F),$=G,F=J},K=()=>{if(B=!0,!L)V(y)};K.cleanups=new Set;let p=()=>I(()=>{if(H)throw new Z("computed");L=!0,H=!0;let z;try{z=x()}catch(J){W(X(J)),H=!1;return}if(w(z))C(),z.then((J)=>{j(J),V(y)}).catch(W);else if(z==null||G===z)C();else j(z);H=!1},K),O={[Symbol.toStringTag]:g,get:()=>{if(M(y),T(),B)p();if(F)throw F;return $},map:(z)=>A(()=>z(O.get())),tap:(z)=>{let J={...z,signals:[O]};return R(J),O}};return O},U=(x)=>Y(x,g);var m="State",b=(x)=>{let y=new Set,$=x,F={[Symbol.toStringTag]:m,get:()=>{return M(y),$},set:(B)=>{if(Object.is($,B))return;if($=B,V(y),G===$)y.clear()},update:(B)=>{F.set(B($))},map:(B)=>A(()=>B(F.get())),tap:(B)=>{let L={...B,signals:[F]};return R(L),F}};return F},S=(x)=>Y(x,m);var G=Symbol(),f=(x)=>S(x)||U(x),c=(x)=>N(x)&&!x.length,n=(x)=>f(x)?x:N(x)?A(x):b(x);export{I as watch,n as toSignal,b as state,S as isState,f as isSignal,c as isComputedCallback,U as isComputed,s as enqueue,R as effect,A as computed,h as batch,G as UNSET,Z as CircularDependencyError};
