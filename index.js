class A extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class d extends TypeError{constructor($,B){super(`Invalid signal value ${B} in ${$}`);this.name="InvalidSignalValueError"}}class V extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class n extends Error{constructor($,B){super(`Could not add store key "${$}" with value ${B} because it already exists`);this.name="StoreKeyExistsError"}}class c extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class v extends Error{constructor($,B){super(`Could not set store key "${$}" to ${B} because it is readonly`);this.name="StoreKeyReadonlyError"}}var H=Symbol(),e=($)=>typeof $==="string",F$=($)=>typeof $==="number",E=($)=>typeof $==="symbol",L=($)=>typeof $==="function",g=($)=>L($)&&$.constructor.name==="AsyncFunction",Y$=($)=>!!$&&typeof $==="object",T=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,U=($)=>T($,"Object"),t=($)=>U($)||Array.isArray($),D$=($)=>{if(!$.length)return null;let B=$.map((W)=>e(W)?parseInt(W,10):F$(W)?W:NaN);return B.every((W)=>Number.isFinite(W)&&W>=0)?B.sort((W,Q)=>W-Q):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",q=($)=>$ instanceof Error?$:Error(String($));var s=($)=>{let B=D$(Object.keys($));if(B===null)return $;let W=[];for(let Q of B)W.push($[String(Q)]);return W},u=($)=>e($)?`"${$}"`:Y$($)?JSON.stringify($):String($);var P=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new A("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Q=0;Q<$.length;Q++)if(!P($[Q],B[Q],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(U($)&&U(B)){let Q=Object.keys($),X=Object.keys(B);if(Q.length!==X.length)return!1;for(let C of Q){if(!(C in B))return!1;if(!P($[C],B[C],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},$$=($,B)=>{let W=t($),Q=t(B);if(!W||!Q){let F=!Object.is($,B);return{changed:F,add:F&&Q?B:{},change:{},remove:F&&W?$:{}}}let X=new WeakSet,C={},G={},K={},z=Object.keys($),j=Object.keys(B),S=new Set([...z,...j]);for(let F of S){let Y=F in $,D=F in B;if(!Y&&D){C[F]=B[F];continue}else if(Y&&!D){K[F]=H;continue}let x=$[F],J=B[F];if(!P(x,J,X))G[F]=J}return{changed:Object.keys(C).length>0||Object.keys(G).length>0||Object.keys(K).length>0,add:C,change:G,remove:K}};var f,i=new Set,B$=0,J$=new Map,r,H$=()=>{r=void 0;let $=Array.from(J$.values());J$.clear();for(let B of $)B()},L$=()=>{if(r)cancelAnimationFrame(r);r=requestAnimationFrame(H$)};queueMicrotask(H$);var k=($)=>{let B=new Set,W=$;return W.off=(Q)=>{B.add(Q)},W.cleanup=()=>{for(let Q of B)Q();B.clear()},W},m=($)=>{if(f&&!$.has(f)){let B=f;$.add(B),f.off(()=>{$.delete(B)})}},I=($)=>{for(let B of $)if(B$)i.add(B);else B()},l=()=>{while(i.size){let $=Array.from(i);i.clear();for(let B of $)B()}},W$=($)=>{B$++;try{$()}finally{l(),B$--}},b=($,B)=>{let W=f;f=B;try{$()}finally{f=W}},U$=($,B)=>new Promise((W,Q)=>{J$.set(B||Symbol(),()=>{try{W($())}catch(X){Q(X)}}),L$()});var x$="Computed",Q$=($)=>{let B=new Set,W=H,Q,X,C=!0,G=!1,K=!1,z=(x)=>{if(!P(x,W))W=x,G=!0;Q=void 0,C=!1},j=()=>{G=H!==W,W=H,Q=void 0},S=(x)=>{let J=q(x);G=!Q||J.name!==Q.name||J.message!==Q.message,W=H,Q=J},_=(x)=>(J)=>{if(K=!1,X=void 0,x(J),G)I(B)},F=k(()=>{if(C=!0,X?.abort(),B.size)I(B);else F.cleanup()});F.off(()=>{X?.abort()});let Y=()=>b(()=>{if(K)throw new A("computed");if(G=!1,g($)){if(X)return W;X=new AbortController,X.signal.addEventListener("abort",()=>{K=!1,X=void 0,Y()},{once:!0})}let x;K=!0;try{x=X?$(X.signal):$()}catch(J){if(O(J))j();else S(J);K=!1;return}if(x instanceof Promise)x.then(_(z),_(S));else if(x==null||H===x)j();else z(x);K=!1},F);return{[Symbol.toStringTag]:x$,get:()=>{if(m(B),l(),C)Y();if(Q)throw Q;return W}}},h=($)=>T($,x$),X$=($)=>L($)&&$.length<2;var Z$=($)=>{let B=g($),W=!1,Q,X=k(()=>b(()=>{if(W)throw new A("effect");W=!0,Q?.abort(),Q=void 0;let C;try{if(B){Q=new AbortController;let G=Q;$(Q.signal).then((K)=>{if(L(K)&&Q===G)X.off(K)}).catch((K)=>{if(!O(K))console.error("Async effect error:",K)})}else if(C=$(),L(C))X.off(C)}catch(G){if(!O(G))console.error("Effect callback error:",G)}W=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function q$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(q(W))))B.err($.errors?[...$.errors,q(W)]:[q(W)]);else throw W}}function N$($){let B=[],W=!1,Q={};for(let[X,C]of Object.entries($))try{let G=C.get();if(G===H)W=!0;else Q[X]=G}catch(G){B.push(q(G))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Q}}var R$="State",y=($)=>{let B=new Set,W=$,Q={[Symbol.toStringTag]:R$,get:()=>{return m(B),W},set:(X)=>{if(X==null)throw new V("state");if(P(W,X))return;if(W=X,I(B),H===W)B.clear()},update:(X)=>{Q.set(X(W))}};return Q},w=($)=>T($,R$);var a="Store",C$="store-add",M$="store-change",z$="store-remove",p=($)=>{let B=new Set,W=new EventTarget,Q=new Map,X=new Map,C=Array.isArray($),G=y(0),K=()=>{let x={};for(let[J,R]of Q)x[J]=R.get();return x},z=(x,J)=>W.dispatchEvent(new CustomEvent(x,{detail:J})),j=()=>Array.from(Q.keys()).map((x)=>Number(x)).filter((x)=>Number.isInteger(x)).sort((x,J)=>x-J),S=(x,J)=>{if(J==null)throw new V(`store for key "${x}"`);if(J===H)return!0;if(E(J)||L(J)||h(J))throw new d(`store for key "${x}"`,u(J));return!0},_=(x,J,R=!1)=>{if(!S(x,J))return!1;let Z=w(J)||o(J)?J:U(J)?p(J):Array.isArray(J)?p(J):y(J);Q.set(x,Z);let M=Z$(()=>{let N=Z.get();if(N!=null)z(M$,{[x]:N})});if(X.set(x,M),R)G.set(Q.size),I(B),z(C$,{[x]:J});return!0},F=(x,J=!1)=>{let R=Q.delete(x);if(R){let Z=X.get(x);if(Z)Z();X.delete(x)}if(J)G.set(Q.size),I(B),z(z$,{[x]:H});return R},Y=(x,J,R)=>{let Z=$$(x,J);return W$(()=>{if(Object.keys(Z.add).length){for(let M in Z.add){let N=Z.add[M]??H;_(M,N)}if(R)setTimeout(()=>{z(C$,Z.add)},0);else z(C$,Z.add)}if(Object.keys(Z.change).length){for(let M in Z.change){let N=Z.change[M];if(!S(M,N))continue;let K$=Q.get(M);if(G$(K$))K$.set(N);else throw new v(M,u(N))}z(M$,Z.change)}if(Object.keys(Z.remove).length){for(let M in Z.remove)F(M);z(z$,Z.remove)}G.set(Q.size)}),Z.changed};Y({},$,!0);let D={add:C?(x)=>{let J=Q.size,R=String(J);_(R,x,!0)}:(x,J)=>{if(!Q.has(x))_(x,J,!0);else throw new n(x,u(J))},get:()=>{return m(B),s(K())},remove:C?(x)=>{let J=s(K()),R=Q.size;if(!Array.isArray(J)||x<=-R||x>=R)throw new c(x);let Z=[...J];if(Z.splice(x,1),Y(J,Z))I(B)}:(x)=>{if(Q.has(x))F(x,!0)},set:(x)=>{if(Y(K(),x)){if(I(B),H===x)B.clear()}},update:(x)=>{let J=K(),R=x(s(J));if(Y(J,R)){if(I(B),H===R)B.clear()}},addEventListener:W.addEventListener.bind(W),removeEventListener:W.removeEventListener.bind(W),dispatchEvent:W.dispatchEvent.bind(W),size:G};return new Proxy({},{get(x,J){if(J===Symbol.toStringTag)return a;if(J===Symbol.isConcatSpreadable)return C;if(J===Symbol.iterator)return C?function*(){let R=j();for(let Z of R){let M=Q.get(String(Z));if(M)yield M}}:function*(){for(let[R,Z]of Q)yield[R,Z]};if(E(J))return;if(J in D)return D[J];if(J==="length"&&C)return m(B),G.get();return Q.get(J)},has(x,J){let R=String(J);return R&&Q.has(R)||Object.keys(D).includes(R)||J===Symbol.toStringTag||J===Symbol.iterator||J===Symbol.isConcatSpreadable||J==="length"&&C},ownKeys(){return C?j().map((x)=>String(x)).concat(["length"]):Array.from(Q.keys()).map((x)=>String(x))},getOwnPropertyDescriptor(x,J){let R=(M)=>({enumerable:!1,configurable:!0,writable:!1,value:M});if(J==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:G.get()};if(J===Symbol.isConcatSpreadable)return R(C);if(J===Symbol.toStringTag)return R(a);if(E(J))return;if(Object.keys(D).includes(J))return R(D[J]);let Z=Q.get(J);return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},o=($)=>T($,a);var I$=($)=>w($)||h($)||o($),G$=($)=>w($)||o($);function A$($){if(I$($))return $;if(X$($))return Q$($);if(Array.isArray($)||U($))return p($);return y($)}export{k as watch,A$ as toSignal,q as toError,m as subscribe,p as store,y as state,N$ as resolve,b as observe,I as notify,q$ as match,E as isSymbol,e as isString,o as isStore,w as isState,I$ as isSignal,t as isRecordOrArray,U as isRecord,F$ as isNumber,G$ as isMutableSignal,L as isFunction,P as isEqual,X$ as isComputedCallback,h as isComputed,g as isAsyncFunction,O as isAbortError,l as flush,U$ as enqueue,Z$ as effect,$$ as diff,Q$ as computed,W$ as batch,H as UNSET,a as TYPE_STORE,R$ as TYPE_STATE,x$ as TYPE_COMPUTED,v as StoreKeyReadonlyError,c as StoreKeyRangeError,n as StoreKeyExistsError,V as NullishSignalValueError,d as InvalidSignalValueError,A as CircularDependencyError};
