var K=(y)=>typeof y==="function";var q=(y,x)=>Object.prototype.toString.call(y)===`[object ${x}]`,w=(y)=>(x)=>x instanceof y,o=w(Error),g=w(Promise),A=(y)=>o(y)?y:Error(String(y));class V extends Error{constructor(y){super(`Circular dependency in ${y} detected`);return this}}var X,M=new Set,k=0,T=new Map,P,E=()=>{P=void 0;let y=Array.from(T.values());T.clear();for(let x of y)x()},d=()=>{if(P)cancelAnimationFrame(P);P=requestAnimationFrame(E)};queueMicrotask(E);var N=(y)=>{if(X&&!y.has(X)){let x=X;y.add(x),X.cleanups.add(()=>{y.delete(x)})}},R=(y)=>{for(let x of y)if(k)M.add(x);else x()},b=()=>{while(M.size){let y=Array.from(M);M.clear();for(let x of y)x()}},s=(y)=>{k++;try{y()}finally{b(),k--}},C=(y,x)=>{let $=X;X=x;try{y()}finally{X=$}},h=(y,x)=>new Promise(($,z)=>{let B=()=>{try{$(y())}catch(G){z(G)}};if(x)T.set(x,B);d()});function O(y){let{signals:x,ok:$,err:z=console.error,nil:B=()=>{}}=K(y)?{signals:[],ok:y}:y,G=!1,H=()=>C(()=>{if(G)throw new V("effect");G=!0;let W=[],I=!1,Y=x.map((Q)=>{try{let Z=Q.get();if(Z===J)I=!0;return Z}catch(Z){W.push(A(Z))}});try{let Q=I?B():W.length?z(...W):$(...Y);if(K(Q))H.cleanups.add(Q)}catch(Q){z(A(Q))}G=!1},H);return H.cleanups=new Set,H(),()=>{H.cleanups.forEach((W)=>W()),H.cleanups.clear()}}var f="Computed",i=(y,x)=>{if(!x)return!1;return y.name===x.name&&y.message===x.message},F=(y)=>{let x=new Set,$=J,z,B=!0,G=!1,H=!1,W=(L)=>{if(!Object.is(L,$))$=L,B=!1,z=void 0,G=!1},I=()=>{G=J===$,$=J,z=void 0},Y=(L)=>{let j=A(L);G=i(j,z),$=J,z=j},Q=()=>{if(B=!0,!G)R(x)};Q.cleanups=new Set;let Z=()=>C(()=>{if(H)throw new V("computed");G=!0,H=!0;let L;try{L=y()}catch(j){Y(A(j)),H=!1;return}if(g(L))I(),L.then((j)=>{W(j),R(x)}).catch(Y);else if(L==null||J===L)I();else W(L);H=!1},Q),D={[Symbol.toStringTag]:f,get:()=>{if(N(x),b(),B)Z();if(z)throw z;return $},map:(L)=>F(()=>L(D.get())),tap:(L)=>O({signals:[D],...K(L)?{ok:L}:L})};return D},U=(y)=>q(y,f);var p="State",S=(y)=>{let x=new Set,$=y,z={[Symbol.toStringTag]:p,get:()=>{return N(x),$},set:(B)=>{if(Object.is($,B))return;if($=B,R(x),J===$)x.clear()},update:(B)=>{z.set(B($))},map:(B)=>F(()=>B(z.get())),tap:(B)=>O({signals:[z],...K(B)?{ok:B}:B})};return z},_=(y)=>q(y,p);var J=Symbol(),m=(y)=>_(y)||U(y),v=(y)=>K(y)&&!y.length,n=(y)=>m(y)?y:K(y)?F(y):S(y);export{C as watch,n as toSignal,S as state,_ as isState,m as isSignal,v as isComputedCallback,U as isComputed,h as enqueue,O as effect,F as computed,s as batch,J as UNSET,V as CircularDependencyError};
