var N,w=new Set,v=0,d=new Map,b,a=()=>{b=void 0;let $=Array.from(d.values());d.clear();for(let B of $)B()},W$=()=>{if(b)cancelAnimationFrame(b);b=requestAnimationFrame(a)};queueMicrotask(a);var E=($)=>{let B=new Set,W=$;return W.off=(x)=>{B.add(x)},W.cleanup=()=>{for(let x of B)x();B.clear()},W},P=($)=>{if(N&&!$.has(N)){let B=N;$.add(B),N.off(()=>{$.delete(B)})}},A=($)=>{for(let B of $)if(v)w.add(B);else B()},g=()=>{while(w.size){let $=Array.from(w);w.clear();for(let B of $)B()}},n=($)=>{v++;try{$()}finally{g(),v--}},k=($,B)=>{let W=N;N=B;try{$()}finally{N=W}},x$=($,B)=>new Promise((W,x)=>{d.set(B||Symbol(),()=>{try{W($())}catch(J){x(J)}}),W$()});var j=($)=>typeof $==="function",y=($)=>j($)&&$.constructor.name==="AsyncFunction",q=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,R=($)=>q($,"Object");var c=($)=>{let B={};for(let W=0;W<$.length;W++)if(W in $)B[String(W)]=$[W];return B},e=($,B)=>(B in $)&&j($[B]),S=($)=>$ instanceof DOMException&&$.name==="AbortError",K=($)=>$ instanceof Error?$:Error(String($));class I extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var o="State",U=($)=>{let B=new Set,W=$,x={[Symbol.toStringTag]:o,get:()=>{return P(B),W},set:(J)=>{if(D(W,J))return;if(W=J,A(B),C===W)B.clear()},update:(J)=>{x.set(J(W))}};return x},h=($)=>q($,o);var u=($)=>{let B=y($),W=!1,x,J=E(()=>k(()=>{if(W)throw new I("effect");W=!0,x?.abort(),x=void 0;let F;try{if(B){x=new AbortController;let Z=x;$(x.signal).then((z)=>{if(j(z)&&x===Z)J.off(z)}).catch((z)=>{if(!S(z))console.error("Async effect error:",z)})}else if(F=$(),j(F))J.off(F)}catch(Z){if(!S(Z))console.error("Effect callback error:",Z)}W=!1},J));return J(),()=>{x?.abort(),J.cleanup()}};var i="Store",T=($)=>{let B=new Set,W=new EventTarget,x=new Map,J=new Map,F=U(0),Z=f(()=>{F.get();let L={};for(let[Q,G]of x)L[Q]=G.get();return L}),z=U(0),M=(L,Q)=>W.dispatchEvent(new CustomEvent(L,{detail:Q})),O=(L,Q)=>{let G=$$(Q);x.set(L,G);let X=u(()=>{let H=G.get();if(H)M("store-change",{[L]:H})});J.set(L,X)},_=(L)=>{x.delete(L);let Q=J.get(L);if(Q)Q();J.delete(L)},Y=(L,Q)=>{let G=t(L,Q);return n(()=>{if(Object.keys(G.add).length){for(let X in G.add){let H=G.add[X];if(H!=null)O(X,H)}M("store-add",G.add)}if(Object.keys(G.change).length){for(let X in G.change){let H=x.get(X),m=G.change[X];if(H&&m!=null&&e(H,"set"))H.set(m)}M("store-change",G.change)}if(Object.keys(G.remove).length){for(let X in G.remove)_(X);M("store-remove",G.remove)}if(G.changed)F.update((X)=>++X);z.set(x.size)}),G.changed};Y({},$),setTimeout(()=>{let L=new CustomEvent("store-add",{detail:$});W.dispatchEvent(L)},0);let V=["get","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(L,Q){let G=String(Q);if(Q===Symbol.toStringTag)return i;if(Q===Symbol.iterator)return function*(){for(let[X,H]of x)yield[X,H]};if(Q==="get")return()=>{return P(B),Z.get()};if(Q==="set")return(X)=>{if(Y(Z.get(),X)){if(A(B),C===X)B.clear()}};if(Q==="update")return(X)=>{let H=Z.get(),m=X(H);if(Y(H,m)){if(A(B),C===m)B.clear()}};if(Q==="addEventListener")return W.addEventListener.bind(W);if(Q==="removeEventListener")return W.removeEventListener.bind(W);if(Q==="dispatchEvent")return W.dispatchEvent.bind(W);if(Q==="size")return z;return x.get(G)},has(L,Q){let G=String(Q);return x.has(G)||V.includes(G)||Q===Symbol.toStringTag||Q===Symbol.iterator},ownKeys(){return Array.from(x.keys())},getOwnPropertyDescriptor(L,Q){let G=x.get(String(Q));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},p=($)=>q($,i);var C=Symbol(),B$=($)=>h($)||s($)||p($);function G$($){if(B$($))return $;if(l($))return f($);if(Array.isArray($))return T(c($));if(R($))return T($);return U($)}function $$($){if(h($)||p($))return $;if(Array.isArray($))return T(c($));if(R($))return T($);return U($)}var D=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new I("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let x=0;x<$.length;x++)if(!D($[x],B[x],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(R($)&&R(B)){let x=Object.keys($),J=Object.keys(B);if(x.length!==J.length)return!1;for(let F of x){if(!(F in B))return!1;if(!D($[F],B[F],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},t=($,B)=>{let W=new WeakSet;return((J,F)=>{let Z={},z={},M={},O=Object.keys(J),_=Object.keys(F),Y=new Set([...O,..._]);for(let L of Y){let Q=L in J,G=L in F;if(!Q&&G){Z[L]=F[L];continue}else if(Q&&!G){M[L]=C;continue}let X=J[L],H=F[L];if(!D(X,H,W))z[L]=H}return{changed:Object.keys(Z).length>0||Object.keys(z).length>0||Object.keys(M).length>0,add:Z,change:z,remove:M}})($,B)};var r="Computed",f=($)=>{let B=new Set,W=C,x,J,F=!0,Z=!1,z=!1,M=(G)=>{if(!D(G,W))W=G,Z=!0;x=void 0,F=!1},O=()=>{Z=C!==W,W=C,x=void 0},_=(G)=>{let X=K(G);Z=!x||X.name!==x.name||X.message!==x.message,W=C,x=X},Y=(G)=>(X)=>{if(z=!1,J=void 0,G(X),Z)A(B)},V=E(()=>{if(F=!0,J?.abort(),B.size)A(B);else V.cleanup()});V.off(()=>{J?.abort()});let L=()=>k(()=>{if(z)throw new I("computed");if(Z=!1,y($)){if(J)return W;J=new AbortController,J.signal.addEventListener("abort",()=>{z=!1,J=void 0,L()},{once:!0})}let G;z=!0;try{G=J?$(J.signal):$()}catch(X){if(S(X))O();else _(X);z=!1;return}if(G instanceof Promise)G.then(Y(M),Y(_));else if(G==null||C===G)O();else M(G);z=!1},V);return{[Symbol.toStringTag]:r,get:()=>{if(P(B),g(),F)L();if(x)throw x;return W}}},s=($)=>q($,r),l=($)=>j($)&&$.length<2;function J$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(K(W)))){let x=$.errors?[...$.errors,K(W)]:[K(W)];B.err(x)}else throw W}}function L$($){let B=[],W=!1,x={};for(let[J,F]of Object.entries($))try{let Z=F.get();if(Z===C)W=!0;else x[J]=Z}catch(Z){B.push(K(Z))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:x}}export{E as watch,G$ as toSignal,K as toError,P as subscribe,T as store,U as state,L$ as resolve,k as observe,A as notify,J$ as match,p as isStore,h as isState,B$ as isSignal,j as isFunction,D as isEqual,l as isComputedCallback,s as isComputed,y as isAsyncFunction,S as isAbortError,g as flush,x$ as enqueue,u as effect,t as diff,f as computed,n as batch,C as UNSET,i as TYPE_STORE,o as TYPE_STATE,r as TYPE_COMPUTED,I as CircularDependencyError};
