var C=(T)=>typeof T==="function",R=(T)=>C(T)&&/^async\s+/.test(T.toString()),Y=(T)=>C(T)&&T.length<2,D=(T)=>(y)=>y instanceof T,K=D(Error),O=D(Promise);var P="Computed",I=(T,y)=>{y=y??R(T);let F=[],H,j=null,J=!0,U=()=>{if(J=!0,y)A(F)},M={[Symbol.toStringTag]:P,get:()=>{if(y)z(F);if(!y||J)B(()=>{let q=(x)=>{H=x,J=!1,j=null},N=(x)=>{j=K(x)?x:new Error(`Computed function failed: ${x}`)};try{let x=T(H);O(x)?x.then(q).catch(N):q(x)}catch(x){N(x)}},U);if(K(j))throw j;return H},map:(q)=>I(()=>q(M.get()))};return M},Q=(T)=>!!T&&typeof T==="object"&&T[Symbol.toStringTag]===P;var L,V=!1,W=[],S=(T)=>Z(T)||Q(T),k=(T,y=!1)=>S(T)?T:Y(T)?I(T,y):X(T),z=(T)=>{if(L&&!T.includes(L))T.push(L)},A=(T)=>T.forEach((y)=>V?W.push(y):y()),B=(T,y)=>{let F=L;L=y,T(),L=F},E=(T)=>{V=!0,T(),V=!1,W.forEach((y)=>y()),W.length=0};var $=Symbol();class G{T;watchers=[];constructor(T){this.value=T}get(){return z(this.watchers),this.value}set(T){if($!==T){if(Object.is(this.value,T))return;this.value=T}if(A(this.watchers),$===T)this.watchers=[]}update(T){this.set(T(this.value))}map(T){return I(()=>T(this.get()))}}var X=(T)=>new G(T),Z=(T)=>T instanceof G;var g=(T)=>{let y=()=>B(()=>{try{T()}catch(F){console.error(F)}},y);y()};export{k as toSignal,X as state,Z as isState,S as isSignal,Q as isComputed,g as effect,I as computed,E as batch,$ as UNSET,G as State};
