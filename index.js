class P extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class v extends TypeError{constructor($,x){super(`Invalid signal value ${x} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class n extends Error{constructor($,x){super(`Could not add store key "${$}" with value ${x} because it already exists`);this.name="StoreKeyExistsError"}}class u extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class t extends Error{constructor($,x){super(`Could not set store key "${$}" to ${x} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),e=($)=>typeof $==="string",H$=($)=>typeof $==="number",g=($)=>typeof $==="symbol",A=($)=>typeof $==="function",b=($)=>A($)&&$.constructor.name==="AsyncFunction",U=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,L=($)=>U($,"Object"),s=($)=>L($)||Array.isArray($),D$=($)=>{if(!$.length)return null;let x=$.map((G)=>e(G)?parseInt(G,10):H$(G)?G:NaN);return x.every((G)=>Number.isFinite(G)&&G>=0)?x.sort((G,J)=>G-J):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",T=($)=>$ instanceof Error?$:Error(String($));var i=($)=>{let x=D$(Object.keys($));if(x===null)return $;let G=[];for(let J of x)G.push($[String(J)]);return G},k=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var _=($,x,G)=>{if(Object.is($,x))return!0;if(typeof $!==typeof x)return!1;if(typeof $!=="object"||$===null||x===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(x))throw new P("isEqual");G.add($),G.add(x);try{if(Array.isArray($)&&Array.isArray(x)){if($.length!==x.length)return!1;for(let J=0;J<$.length;J++)if(!_($[J],x[J],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(x))return!1;if(L($)&&L(x)){let J=Object.keys($),M=Object.keys(x);if(J.length!==M.length)return!1;for(let Q of J){if(!(Q in x))return!1;if(!_($[Q],x[Q],G))return!1}return!0}return!1}finally{G.delete($),G.delete(x)}},$$=($,x)=>{let G=s($),J=s(x);if(!G||!J){let I=!Object.is($,x);return{changed:I,add:I&&J?x:{},change:{},remove:I&&G?$:{}}}let M=new WeakSet,Q={},H={},D={},C=Object.keys($),m=Object.keys(x),V=new Set([...C,...m]);for(let I of V){let N=I in $,K=I in x;if(!N&&K){Q[I]=x[I];continue}else if(N&&!K){D[I]=q;continue}let B=$[I],R=x[I];if(!_(B,R,M))H[I]=R}return{changed:Object.keys(Q).length>0||Object.keys(H).length>0||Object.keys(D).length>0,add:Q,change:H,remove:D}};var S,r=new Set,x$=0,d=($)=>{let x=new Set,G=$;return G.off=(J)=>{x.add(J)},G.cleanup=()=>{for(let J of x)J();x.clear()},G},Y=($)=>{if(S&&!$.has(S)){let x=S;$.add(x),S.off(()=>{$.delete(x)})}},F=($)=>{for(let x of $)if(x$)r.add(x);else x()},l=()=>{while(r.size){let $=Array.from(r);r.clear();for(let x of $)x()}},R$=($)=>{x$++;try{$()}finally{l(),x$--}},h=($,x)=>{let G=S;S=x;try{$()}finally{S=G}};var B$="Computed",J$=($)=>{let x=new Set,G=q,J,M,Q=!0,H=!1,D=!1,C=(K)=>{if(!_(K,G))G=K,H=!0;J=void 0,Q=!1},m=()=>{H=q!==G,G=q,J=void 0},V=(K)=>{let B=T(K);H=!J||B.name!==J.name||B.message!==J.message,G=q,J=B},j=(K)=>(B)=>{if(D=!1,M=void 0,K(B),H)F(x)},I=d(()=>{if(Q=!0,M?.abort(),x.size)F(x);else I.cleanup()});I.off(()=>{M?.abort()});let N=()=>h(()=>{if(D)throw new P("computed");if(H=!1,b($)){if(M)return G;M=new AbortController,M.signal.addEventListener("abort",()=>{D=!1,M=void 0,N()},{once:!0})}let K;D=!0;try{K=M?$(M.signal):$()}catch(B){if(O(B))m();else V(B);D=!1;return}if(K instanceof Promise)K.then(j(C),j(V));else if(K==null||q===K)m();else C(K);D=!1},I);return{[Symbol.toStringTag]:B$,get:()=>{if(Y(x),l(),Q)N();if(J)throw J;return G}}},p=($)=>U($,B$),G$=($)=>A($)&&$.length<2;var M$=($)=>{let x=b($),G=!1,J,M=d(()=>h(()=>{if(G)throw new P("effect");G=!0,J?.abort(),J=void 0;let Q;try{if(x){J=new AbortController;let H=J;$(J.signal).then((D)=>{if(A(D)&&J===H)M.off(D)}).catch((D)=>{if(!O(D))console.error("Async effect error:",D)})}else if(Q=$(),A(Q))M.off(Q)}catch(H){if(!O(H))console.error("Effect callback error:",H)}G=!1},M));return M(),()=>{J?.abort(),M.cleanup()}};var Q$="State",E=($)=>{let x=new Set,G=$,J={[Symbol.toStringTag]:Q$,get:()=>{return Y(x),G},set:(M)=>{if(M==null)throw new f("state");if(_(G,M))return;if(G=M,F(x),q===G)x.clear()},update:(M)=>{J.set(M(G))}};return J},w=($)=>U($,Q$);var K$=($)=>w($)||p($)||o($),X$=($)=>w($)||o($);function I$($){if(K$($))return $;if(G$($))return J$($);if(Array.isArray($)||L($))return y($);return E($)}var a="Store",y=($)=>{let x=new Set,G={add:new Set,change:new Set,remove:new Set,sort:new Set},J=new Map,M=new Map,Q=Array.isArray($),H=E(0),D=()=>{let B={};for(let[R,X]of J)B[R]=X.get();return B},C=(B,R)=>{Object.freeze(R);for(let X of G[B])X(R)},m=()=>Array.from(J.keys()).map((B)=>Number(B)).filter((B)=>Number.isInteger(B)).sort((B,R)=>B-R),V=(B,R)=>{if(R==null)throw new f(`store for key "${B}"`);if(R===q)return!0;if(g(R)||A(R)||p(R))throw new v(`store for key "${B}"`,k(R));return!0},j=(B,R,X=!1)=>{if(!V(B,R))return!1;let Z=w(R)||o(R)?R:L(R)||Array.isArray(R)?y(R):E(R);J.set(B,Z);let W=M$(()=>{let z=Z.get();if(z!=null)C("change",{[B]:z})});if(M.set(B,W),X)H.set(J.size),F(x),C("add",{[B]:R});return!0},I=(B,R=!1)=>{let X=J.delete(B);if(X){let Z=M.get(B);if(Z)Z();M.delete(B)}if(R)H.set(J.size),F(x),C("remove",{[B]:q});return X},N=(B,R,X)=>{let Z=$$(B,R);return R$(()=>{if(Object.keys(Z.add).length){for(let W in Z.add){let z=Z.add[W]??q;j(W,z)}if(X)setTimeout(()=>{C("add",Z.add)},0);else C("add",Z.add)}if(Object.keys(Z.change).length){for(let W in Z.change){let z=Z.change[W];if(!V(W,z))continue;let c=J.get(W);if(X$(c))c.set(z);else throw new t(W,k(z))}C("change",Z.change)}if(Object.keys(Z.remove).length){for(let W in Z.remove)I(W);C("remove",Z.remove)}H.set(J.size)}),Z.changed};N({},$,!0);let K={add:Q?(B)=>{let R=J.size,X=String(R);j(X,B,!0)}:(B,R)=>{if(!J.has(B))j(B,R,!0);else throw new n(B,k(R))},get:()=>{return Y(x),i(D())},remove:Q?(B)=>{let R=i(D()),X=J.size;if(!Array.isArray(R)||B<=-X||B>=X)throw new u(B);let Z=[...R];if(Z.splice(B,1),N(R,Z))F(x)}:(B)=>{if(J.has(B))I(B,!0)},set:(B)=>{if(N(D(),B)){if(F(x),q===B)x.clear()}},update:(B)=>{let R=D(),X=B(i(R));if(N(R,X)){if(F(x),q===X)x.clear()}},sort:(B)=>{let R=Array.from(J.entries()).map(([W,z])=>[W,z.get()]).sort(B?(W,z)=>B(W[1],z[1]):(W,z)=>String(W[1]).localeCompare(String(z[1]))),X=R.map(([W])=>String(W)),Z=new Map;R.forEach(([W],z)=>{let c=String(W),q$=Q?String(z):String(W),W$=J.get(c);if(W$)Z.set(q$,W$)}),J.clear(),Z.forEach((W,z)=>J.set(z,W)),F(x),C("sort",X)},on:(B,R)=>{return G[B].add(R),()=>G[B].delete(R)},size:H};return new Proxy({},{get(B,R){if(R===Symbol.toStringTag)return a;if(R===Symbol.isConcatSpreadable)return Q;if(R===Symbol.iterator)return Q?function*(){let X=m();for(let Z of X){let W=J.get(String(Z));if(W)yield W}}:function*(){for(let[X,Z]of J)yield[X,Z]};if(g(R))return;if(R in K)return K[R];if(R==="length"&&Q)return Y(x),H.get();return J.get(R)},has(B,R){let X=String(R);return X&&J.has(X)||Object.keys(K).includes(X)||R===Symbol.toStringTag||R===Symbol.iterator||R===Symbol.isConcatSpreadable||R==="length"&&Q},ownKeys(){return Q?m().map((B)=>String(B)).concat(["length"]):Array.from(J.keys()).map((B)=>String(B))},getOwnPropertyDescriptor(B,R){let X=(W)=>({enumerable:!1,configurable:!0,writable:!1,value:W});if(R==="length"&&Q)return{enumerable:!0,configurable:!0,writable:!1,value:H.get()};if(R===Symbol.isConcatSpreadable)return X(Q);if(R===Symbol.toStringTag)return X(a);if(g(R))return;if(Object.keys(K).includes(R))return X(K[R]);let Z=J.get(R);return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},o=($)=>U($,a);var Z$="Collection",z$=($)=>{let x=new Set,G=y(q),J,M=()=>{try{G.set($(G))}catch(Q){J=Q}};return{[Symbol.toStringTag]:Z$,get:()=>{if(Y(x),J)throw J;let Q=G.get();if(Q!==q)return Q;return M(),G.get()}}},C$=($)=>U($,Z$);function F$($,x){try{if($.pending)x.nil?.();else if($.errors)x.err?.($.errors);else if($.ok)x.ok($.values)}catch(G){if(x.err&&(!$.errors||!$.errors.includes(T(G))))x.err($.errors?[...$.errors,T(G)]:[T(G)]);else throw G}}function N$($){let x=[],G=!1,J={};for(let[M,Q]of Object.entries($))try{let H=Q.get();if(H===q)G=!0;else J[M]=H}catch(H){x.push(T(H))}if(G)return{ok:!1,pending:!0};if(x.length>0)return{ok:!1,errors:x};return{ok:!0,values:J}}export{k as valueString,I$ as toSignal,T as toError,Y as subscribe,N$ as resolve,h as observe,F as notify,F$ as match,g as isSymbol,e as isString,o as isStore,w as isState,K$ as isSignal,s as isRecordOrArray,L as isRecord,H$ as isNumber,X$ as isMutableSignal,A as isFunction,_ as isEqual,G$ as isComputedCallback,p as isComputed,C$ as isCollection,b as isAsyncFunction,O as isAbortError,l as flush,$$ as diff,d as createWatcher,y as createStore,E as createState,M$ as createEffect,J$ as createComputed,z$ as createCollection,R$ as batch,q as UNSET,a as TYPE_STORE,Q$ as TYPE_STATE,B$ as TYPE_COMPUTED,Z$ as TYPE_COLLECTION,t as StoreKeyReadonlyError,u as StoreKeyRangeError,n as StoreKeyExistsError,f as NullishSignalValueError,v as InvalidSignalValueError,P as CircularDependencyError};
