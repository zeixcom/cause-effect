class P extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class f extends TypeError{constructor($,x){super(`Invalid ${$} callback ${x}`);this.name="InvalidCallbackError"}}class v extends TypeError{constructor($,x){super(`Invalid signal value ${x} in ${$}`);this.name="InvalidSignalValueError"}}class L extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class n extends Error{constructor($,x){super(`Could not add store key "${$}" with value ${x} because it already exists`);this.name="StoreKeyExistsError"}}class u extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class c extends Error{constructor($,x){super(`Could not set store key "${$}" to ${x} because it is readonly`);this.name="StoreKeyReadonlyError"}}var K=Symbol(),$$=($)=>typeof $==="string",X$=($)=>typeof $==="number",b=($)=>typeof $==="symbol",T=($)=>typeof $==="function",k=($)=>T($)&&$.constructor.name==="AsyncFunction",m=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,A=($)=>m($,"Object"),s=($)=>A($)||Array.isArray($),H$=($)=>{if(!$.length)return null;let x=$.map((z)=>$$(z)?parseInt(z,10):X$(z)?z:NaN);return x.every((z)=>Number.isFinite(z)&&z>=0)?x.sort((z,B)=>z-B):null};var y=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var t=($)=>{let x=H$(Object.keys($));if(x===null)return $;let z=[];for(let B of x)z.push($[String(B)]);return z},N=($)=>$$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var j=($,x,z)=>{if(Object.is($,x))return!0;if(typeof $!==typeof x)return!1;if(typeof $!=="object"||$===null||x===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(x))throw new P("isEqual");z.add($),z.add(x);try{if(Array.isArray($)&&Array.isArray(x)){if($.length!==x.length)return!1;for(let B=0;B<$.length;B++)if(!j($[B],x[B],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(x))return!1;if(A($)&&A(x)){let B=Object.keys($),M=Object.keys(x);if(B.length!==M.length)return!1;for(let Q of B){if(!(Q in x))return!1;if(!j($[Q],x[Q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(x)}},x$=($,x)=>{let z=s($),B=s(x);if(!z||!B){let C=!Object.is($,x);return{changed:C,add:C&&B?x:{},change:{},remove:C&&z?$:{}}}let M=new WeakSet,Q={},H={},I={},Y=Object.keys($),O=Object.keys(x),W=new Set([...Y,...O]);for(let C of W){let F=C in $,J=C in x;if(!F&&J){Q[C]=x[C];continue}else if(F&&!J){I[C]=K;continue}let R=$[C],G=x[C];if(!j(R,G,M))H[C]=G}return{changed:Object.keys(Q).length>0||Object.keys(H).length>0||Object.keys(I).length>0,add:Q,change:H,remove:I}};var g,i=new Set,R$=0,S=($)=>{let x=new Set,z=$;return z.unwatch=(B)=>{x.add(B)},z.cleanup=()=>{for(let B of x)B();x.clear()},z},_=($)=>{if(g&&!$.has(g)){let x=g;x.unwatch(()=>{$.delete(x)}),$.add(x)}},D=($)=>{for(let x of $)if(R$)i.add(x);else x()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let x of $)x()}},B$=($)=>{R$++;try{$()}finally{r(),R$--}},E=($,x)=>{let z=g;g=x;try{$()}finally{g=z}};var J$="Computed",z$=($,x=K)=>{if(!l($))throw new f("computed",N($));if(x==null)throw new L("computed");let z=new Set,B=x,M,Q,H=!0,I=!1,Y=!1,O=(R)=>{if(!j(R,B))B=R,I=!0;M=void 0,H=!1},W=()=>{I=K!==B,B=K,M=void 0},V=(R)=>{let G=U(R);I=!M||G.name!==M.name||G.message!==M.message,B=K,M=G},C=(R)=>(G)=>{if(Y=!1,Q=void 0,R(G),I)D(z)},F=S(()=>{if(H=!0,Q?.abort(),z.size)D(z);else F.cleanup()});F.unwatch(()=>{Q?.abort()});let J=()=>E(()=>{if(Y)throw new P("computed");if(I=!1,k($)){if(Q)return B;Q=new AbortController,Q.signal.addEventListener("abort",()=>{Y=!1,Q=void 0,J()},{once:!0})}let R;Y=!0;try{R=Q?$(B,Q.signal):$(B)}catch(G){if(y(G))W();else V(G);Y=!1;return}if(R instanceof Promise)R.then(C(O),C(V));else if(R==null||K===R)W();else O(R);Y=!1},F);return{[Symbol.toStringTag]:J$,get:()=>{if(_(z),r(),H)J();if(M)throw M;return B}}},p=($)=>m($,J$),l=($)=>T($)&&$.length<3;var C$=($)=>{if(!T($)||$.length>1)throw new f("effect",N($));let x=k($),z=!1,B,M=S(()=>E(()=>{if(z)throw new P("effect");z=!0,B?.abort(),B=void 0;let Q;try{if(x){B=new AbortController;let H=B;$(B.signal).then((I)=>{if(T(I)&&B===H)M.unwatch(I)}).catch((I)=>{if(!y(I))console.error("Async effect error:",I)})}else if(Q=$(),T(Q))M.unwatch(Q)}catch(H){if(!y(H))console.error("Effect callback error:",H)}z=!1},M));return M(),()=>{B?.abort(),M.cleanup()}};function K$($,x){try{if($.pending)x.nil?.();else if($.errors)x.err?.($.errors);else if($.ok)x.ok($.values)}catch(z){if(x.err&&(!$.errors||!$.errors.includes(U(z))))x.err($.errors?[...$.errors,U(z)]:[U(z)]);else throw z}}function q$($){let x=[],z=!1,B={};for(let[M,Q]of Object.entries($))try{let H=Q.get();if(H===K)z=!0;else B[M]=H}catch(H){x.push(U(H))}if(z)return{ok:!1,pending:!0};if(x.length>0)return{ok:!1,errors:x};return{ok:!0,values:B}}var G$="State",d=($)=>{if($==null)throw new L("state");let x=new Set,z=$,B={[Symbol.toStringTag]:G$,get:()=>{return _(x),z},set:(M)=>{if(M==null)throw new L("state");if(j(z,M))return;if(z=M,D(x),K===z)x.clear()},update:(M)=>{if(!T(M))throw new f("state update",N(M));B.set(M(z))}};return B},w=($)=>m($,G$);var a="Store",e=($)=>{if($==null)throw new L("store");let x=new Set,z={add:new Set,change:new Set,remove:new Set,sort:new Set},B=new Map,M=new Map,Q=Array.isArray($),H=()=>{let J={};for(let[R,G]of B)J[R]=G.get();return J},I=(J,R)=>{Object.freeze(R);for(let G of z[J])G(R)},Y=()=>Array.from(B.keys()).map((J)=>Number(J)).filter((J)=>Number.isInteger(J)).sort((J,R)=>J-R),O=(J,R)=>{if(R==null)throw new L(`store for key "${J}"`);if(R===K)return!0;if(b(R)||T(R)||p(R))throw new v(`store for key "${J}"`,N(R));return!0},W=(J,R,G=!1)=>{if(!O(J,R))return!1;let X=w(R)||o(R)?R:A(R)||Array.isArray(R)?e(R):d(R);B.set(J,X);let Z=S(()=>E(()=>{I("change",{[J]:X.get()})},Z));if(Z(),M.set(J,Z),G)D(x),I("add",{[J]:R});return!0},V=(J,R=!1)=>{let G=B.delete(J);if(G){let X=M.get(J);if(X)X.cleanup();M.delete(J)}if(R)D(x),I("remove",{[J]:K});return G},C=(J,R,G)=>{let X=x$(J,R);return B$(()=>{if(Object.keys(X.add).length){for(let Z in X.add)W(Z,X.add[Z]??K);if(G)setTimeout(()=>{I("add",X.add)},0);else I("add",X.add)}if(Object.keys(X.change).length){for(let Z in X.change){let q=X.change[Z];if(!O(Z,q))continue;let h=B.get(Z);if(M$(h))h.set(q);else throw new c(Z,N(q))}I("change",X.change)}if(Object.keys(X.remove).length){for(let Z in X.remove)V(Z);I("remove",X.remove)}}),X.changed};C({},$,!0);let F={add:Q?(J)=>{W(String(B.size),J,!0)}:(J,R)=>{if(!B.has(J))W(J,R,!0);else throw new n(J,N(R))},get:()=>{return _(x),t(H())},remove:Q?(J)=>{let R=t(H()),G=B.size;if(!Array.isArray(R)||J<=-G||J>=G)throw new u(J);let X=[...R];if(X.splice(J,1),C(R,X))D(x)}:(J)=>{if(B.has(J))V(J,!0)},set:(J)=>{if(C(H(),J)){if(D(x),K===J)x.clear()}},update:(J)=>{let R=H(),G=J(t(R));if(C(R,G)){if(D(x),K===G)x.clear()}},sort:(J)=>{let R=Array.from(B.entries()).map(([Z,q])=>[Z,q.get()]).sort(J?(Z,q)=>J(Z[1],q[1]):(Z,q)=>String(Z[1]).localeCompare(String(q[1]))),G=R.map(([Z])=>String(Z)),X=new Map;R.forEach(([Z],q)=>{let h=String(Z),I$=Q?String(q):String(Z),Q$=B.get(h);if(Q$)X.set(I$,Q$)}),B.clear(),X.forEach((Z,q)=>B.set(q,Z)),D(x),I("sort",G)},on:(J,R)=>{return z[J].add(R),()=>z[J].delete(R)}};return new Proxy({},{get(J,R){if(R===Symbol.toStringTag)return a;if(R===Symbol.isConcatSpreadable)return Q;if(R===Symbol.iterator)return Q?function*(){let G=Y();for(let X of G){let Z=B.get(String(X));if(Z)yield Z}}:function*(){for(let[G,X]of B)yield[G,X]};if(b(R))return;if(R in F)return F[R];if(R==="length")return _(x),B.size;return B.get(R)},has(J,R){let G=String(R);return G&&B.has(G)||Object.keys(F).includes(G)||R===Symbol.toStringTag||R===Symbol.iterator||R===Symbol.isConcatSpreadable||R==="length"},ownKeys(){return Q?Y().map((J)=>String(J)).concat(["length"]):Array.from(B.keys()).map((J)=>String(J)).concat(["length"])},getOwnPropertyDescriptor(J,R){let G=(Z)=>({enumerable:!1,configurable:!0,writable:!1,value:Z});if(R==="length")return{enumerable:Q,configurable:!0,get:()=>{return _(x),B.size}};if(R===Symbol.isConcatSpreadable)return G(Q);if(R===Symbol.toStringTag)return G(a);if(b(R))return;if(Object.keys(F).includes(R))return G(F[R]);let X=B.get(R);return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},o=($)=>m($,a);var Z$=($)=>w($)||p($)||o($),M$=($)=>w($)||o($);function D$($){if(Z$($))return $;if(l($))return z$($);if(Array.isArray($)||A($))return e($);return d($)}export{N as valueString,D$ as toSignal,U as toError,_ as subscribe,q$ as resolve,E as observe,D as notify,K$ as match,b as isSymbol,$$ as isString,o as isStore,w as isState,Z$ as isSignal,s as isRecordOrArray,A as isRecord,m as isObjectOfType,X$ as isNumber,M$ as isMutableSignal,T as isFunction,j as isEqual,l as isComputedCallback,p as isComputed,k as isAsyncFunction,y as isAbortError,r as flush,x$ as diff,S as createWatcher,e as createStore,d as createState,C$ as createEffect,z$ as createComputed,B$ as batch,K as UNSET,a as TYPE_STORE,G$ as TYPE_STATE,J$ as TYPE_COMPUTED,c as StoreKeyReadonlyError,u as StoreKeyRangeError,n as StoreKeyExistsError,L as NullishSignalValueError,v as InvalidSignalValueError,f as InvalidCallbackError,P as CircularDependencyError};
