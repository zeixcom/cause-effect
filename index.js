class L extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class c extends TypeError{constructor($,R){super(`Invalid signal value ${R} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class v extends Error{constructor($,R){super(`Could not add store key "${$}" with value ${R} because it already exists`);this.name="StoreKeyExistsError"}}class n extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class u extends Error{constructor($,R){super(`Could not set store key "${$}" to ${R} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),e=($)=>typeof $==="string",C$=($)=>typeof $==="number",y=($)=>typeof $==="symbol",Y=($)=>typeof $==="function",g=($)=>Y($)&&$.constructor.name==="AsyncFunction",V=($,R)=>Object.prototype.toString.call($)===`[object ${R}]`,T=($)=>V($,"Object"),t=($)=>T($)||Array.isArray($),I$=($)=>{if(!$.length)return null;let R=$.map((G)=>e(G)?parseInt(G,10):C$(G)?G:NaN);return R.every((G)=>Number.isFinite(G)&&G>=0)?R.sort((G,J)=>G-J):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var s=($)=>{let R=I$(Object.keys($));if(R===null)return $;let G=[];for(let J of R)G.push($[String(J)]);return G},b=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var A=($,R,G)=>{if(Object.is($,R))return!0;if(typeof $!==typeof R)return!1;if(typeof $!=="object"||$===null||R===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(R))throw new L("isEqual");G.add($),G.add(R);try{if(Array.isArray($)&&Array.isArray(R)){if($.length!==R.length)return!1;for(let J=0;J<$.length;J++)if(!A($[J],R[J],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(R))return!1;if(T($)&&T(R)){let J=Object.keys($),X=Object.keys(R);if(J.length!==X.length)return!1;for(let C of J){if(!(C in R))return!1;if(!A($[C],R[C],G))return!1}return!0}return!1}finally{G.delete($),G.delete(R)}},$$=($,R)=>{let G=t($),J=t(R);if(!G||!J){let K=!Object.is($,R);return{changed:K,add:K&&J?R:{},change:{},remove:K&&G?$:{}}}let X=new WeakSet,C={},W={},I={},N=Object.keys($),P=Object.keys(R),m=new Set([...N,...P]);for(let K of m){let F=K in $,H=K in R;if(!F&&H){C[K]=R[K];continue}else if(F&&!H){I[K]=q;continue}let B=$[K],x=R[K];if(!A(B,x,X))W[K]=x}return{changed:Object.keys(C).length>0||Object.keys(W).length>0||Object.keys(I).length>0,add:C,change:W,remove:I}};var S,i=new Set,R$=0,k=($)=>{let R=new Set,G=$;return G.off=(J)=>{R.add(J)},G.cleanup=()=>{for(let J of R)J();R.clear()},G},_=($)=>{if(S&&!$.has(S)){let R=S;$.add(R),S.off(()=>{$.delete(R)})}},z=($)=>{for(let R of $)if(R$)i.add(R);else R()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let R of $)R()}},x$=($)=>{R$++;try{$()}finally{r(),R$--}},h=($,R)=>{let G=S;S=R;try{$()}finally{S=G}};var B$="Computed",J$=($)=>{let R=new Set,G=q,J,X,C=!0,W=!1,I=!1,N=(H)=>{if(!A(H,G))G=H,W=!0;J=void 0,C=!1},P=()=>{W=q!==G,G=q,J=void 0},m=(H)=>{let B=U(H);W=!J||B.name!==J.name||B.message!==J.message,G=q,J=B},j=(H)=>(B)=>{if(I=!1,X=void 0,H(B),W)z(R)},K=k(()=>{if(C=!0,X?.abort(),R.size)z(R);else K.cleanup()});K.off(()=>{X?.abort()});let F=()=>h(()=>{if(I)throw new L("computed");if(W=!1,g($)){if(X)return G;X=new AbortController,X.signal.addEventListener("abort",()=>{I=!1,X=void 0,F()},{once:!0})}let H;I=!0;try{H=X?$(X.signal):$()}catch(B){if(O(B))P();else m(B);I=!1;return}if(H instanceof Promise)H.then(j(N),j(m));else if(H==null||q===H)P();else N(H);I=!1},K);return{[Symbol.toStringTag]:B$,get:()=>{if(_(R),r(),C)F();if(J)throw J;return G}}},d=($)=>V($,B$),G$=($)=>Y($)&&$.length<2;var M$=($)=>{let R=g($),G=!1,J,X=k(()=>h(()=>{if(G)throw new L("effect");G=!0,J?.abort(),J=void 0;let C;try{if(R){J=new AbortController;let W=J;$(J.signal).then((I)=>{if(Y(I)&&J===W)X.off(I)}).catch((I)=>{if(!O(I))console.error("Async effect error:",I)})}else if(C=$(),Y(C))X.off(C)}catch(W){if(!O(W))console.error("Effect callback error:",W)}G=!1},X));return X(),()=>{J?.abort(),X.cleanup()}};function K$($,R){try{if($.pending)R.nil?.();else if($.errors)R.err?.($.errors);else if($.ok)R.ok($.values)}catch(G){if(R.err&&(!$.errors||!$.errors.includes(U(G))))R.err($.errors?[...$.errors,U(G)]:[U(G)]);else throw G}}function q$($){let R=[],G=!1,J={};for(let[X,C]of Object.entries($))try{let W=C.get();if(W===q)G=!0;else J[X]=W}catch(W){R.push(U(W))}if(G)return{ok:!1,pending:!0};if(R.length>0)return{ok:!1,errors:R};return{ok:!0,values:J}}var Q$="State",E=($)=>{let R=new Set,G=$,J={[Symbol.toStringTag]:Q$,get:()=>{return _(R),G},set:(X)=>{if(X==null)throw new f("state");if(A(G,X))return;if(G=X,z(R),q===G)R.clear()},update:(X)=>{J.set(X(G))}};return J},w=($)=>V($,Q$);var l="Store",a=($)=>{let R=new Set,G={add:new Set,change:new Set,remove:new Set,sort:new Set},J=new Map,X=new Map,C=Array.isArray($),W=E(0),I=()=>{let B={};for(let[x,M]of J)B[x]=M.get();return B},N=(B,x)=>{Object.freeze(x);for(let M of G[B])M(x)},P=()=>Array.from(J.keys()).map((B)=>Number(B)).filter((B)=>Number.isInteger(B)).sort((B,x)=>B-x),m=(B,x)=>{if(x==null)throw new f(`store for key "${B}"`);if(x===q)return!0;if(y(x)||Y(x)||d(x))throw new c(`store for key "${B}"`,b(x));return!0},j=(B,x,M=!1)=>{if(!m(B,x))return!1;let Q=w(x)||p(x)?x:T(x)||Array.isArray(x)?a(x):E(x);J.set(B,Q);let Z=M$(()=>{let D=Q.get();if(D!=null)N("change",{[B]:D})});if(X.set(B,Z),M)W.set(J.size),z(R),N("add",{[B]:x});return!0},K=(B,x=!1)=>{let M=J.delete(B);if(M){let Q=X.get(B);if(Q)Q();X.delete(B)}if(x)W.set(J.size),z(R),N("remove",{[B]:q});return M},F=(B,x,M)=>{let Q=$$(B,x);return x$(()=>{if(Object.keys(Q.add).length){for(let Z in Q.add){let D=Q.add[Z]??q;j(Z,D)}if(M)setTimeout(()=>{N("add",Q.add)},0);else N("add",Q.add)}if(Object.keys(Q.change).length){for(let Z in Q.change){let D=Q.change[Z];if(!m(Z,D))continue;let o=J.get(Z);if(X$(o))o.set(D);else throw new u(Z,b(D))}N("change",Q.change)}if(Object.keys(Q.remove).length){for(let Z in Q.remove)K(Z);N("remove",Q.remove)}W.set(J.size)}),Q.changed};F({},$,!0);let H={add:C?(B)=>{let x=J.size,M=String(x);j(M,B,!0)}:(B,x)=>{if(!J.has(B))j(B,x,!0);else throw new v(B,b(x))},get:()=>{return _(R),s(I())},remove:C?(B)=>{let x=s(I()),M=J.size;if(!Array.isArray(x)||B<=-M||B>=M)throw new n(B);let Q=[...x];if(Q.splice(B,1),F(x,Q))z(R)}:(B)=>{if(J.has(B))K(B,!0)},set:(B)=>{if(F(I(),B)){if(z(R),q===B)R.clear()}},update:(B)=>{let x=I(),M=B(s(x));if(F(x,M)){if(z(R),q===M)R.clear()}},sort:(B)=>{let x=Array.from(J.entries()).map(([Z,D])=>[Z,D.get()]).sort(B?(Z,D)=>B(Z[1],D[1]):(Z,D)=>String(Z[1]).localeCompare(String(D[1]))),M=x.map(([Z])=>String(Z)),Q=new Map;x.forEach(([Z],D)=>{let o=String(Z),H$=C?String(D):String(Z),Z$=J.get(o);if(Z$)Q.set(H$,Z$)}),J.clear(),Q.forEach((Z,D)=>J.set(D,Z)),z(R),N("sort",M)},on:(B,x)=>{return G[B].add(x),()=>G[B].delete(x)},size:W};return new Proxy({},{get(B,x){if(x===Symbol.toStringTag)return l;if(x===Symbol.isConcatSpreadable)return C;if(x===Symbol.iterator)return C?function*(){let M=P();for(let Q of M){let Z=J.get(String(Q));if(Z)yield Z}}:function*(){for(let[M,Q]of J)yield[M,Q]};if(y(x))return;if(x in H)return H[x];if(x==="length"&&C)return _(R),W.get();return J.get(x)},has(B,x){let M=String(x);return M&&J.has(M)||Object.keys(H).includes(M)||x===Symbol.toStringTag||x===Symbol.iterator||x===Symbol.isConcatSpreadable||x==="length"&&C},ownKeys(){return C?P().map((B)=>String(B)).concat(["length"]):Array.from(J.keys()).map((B)=>String(B))},getOwnPropertyDescriptor(B,x){let M=(Z)=>({enumerable:!1,configurable:!0,writable:!1,value:Z});if(x==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:W.get()};if(x===Symbol.isConcatSpreadable)return M(C);if(x===Symbol.toStringTag)return M(l);if(y(x))return;if(Object.keys(H).includes(x))return M(H[x]);let Q=J.get(x);return Q?{enumerable:!0,configurable:!0,writable:!0,value:Q}:void 0}})},p=($)=>V($,l);var W$=($)=>w($)||d($)||p($),X$=($)=>w($)||p($);function D$($){if(W$($))return $;if(G$($))return J$($);if(Array.isArray($)||T($))return a($);return E($)}export{b as valueString,D$ as toSignal,U as toError,_ as subscribe,q$ as resolve,h as observe,z as notify,K$ as match,y as isSymbol,e as isString,p as isStore,w as isState,W$ as isSignal,t as isRecordOrArray,T as isRecord,C$ as isNumber,X$ as isMutableSignal,Y as isFunction,A as isEqual,G$ as isComputedCallback,d as isComputed,g as isAsyncFunction,O as isAbortError,r as flush,$$ as diff,k as createWatcher,a as createStore,E as createState,M$ as createEffect,J$ as createComputed,x$ as batch,q as UNSET,l as TYPE_STORE,Q$ as TYPE_STATE,B$ as TYPE_COMPUTED,u as StoreKeyReadonlyError,n as StoreKeyRangeError,v as StoreKeyExistsError,f as NullishSignalValueError,c as InvalidSignalValueError,L as CircularDependencyError};
