class A extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class S extends TypeError{constructor($,z){super(`Invalid ${$} callback ${z}`);this.name="InvalidCallbackError"}}class r extends TypeError{constructor($,z){super(`Invalid signal value ${z} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class l extends Error{constructor($,z){super(`Could not add store key "${$}" with value ${z} because it already exists`);this.name="StoreKeyExistsError"}}class a extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class e extends Error{constructor($,z){super(`Could not set store key "${$}" to ${z} because it is readonly`);this.name="StoreKeyReadonlyError"}}var N=Symbol(),u=($)=>typeof $==="string",C$=($)=>typeof $==="number",c=($)=>typeof $==="symbol",L=($)=>typeof $==="function",n=($)=>L($)&&$.constructor.name==="AsyncFunction",V=($,z)=>Object.prototype.toString.call($)===`[object ${z}]`,m=($)=>V($,"Object"),$$=($)=>m($)||Array.isArray($),U$=($)=>{if(!$.length)return null;let z=$.map((G)=>u(G)?parseInt(G,10):C$(G)?G:NaN);return z.every((G)=>Number.isFinite(G)&&G>=0)?z.sort((G,Q)=>G-Q):null};var d=($)=>$ instanceof DOMException&&$.name==="AbortError",E=($)=>$ instanceof Error?$:Error(String($));var X$=($)=>{let z=U$(Object.keys($));if(z===null)return $;let G=[];for(let Q of z)G.push($[String(Q)]);return G},K=($)=>u($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var p=($,z,G)=>{if(Object.is($,z))return!0;if(typeof $!==typeof z)return!1;if(typeof $!=="object"||$===null||z===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(z))throw new A("isEqual");G.add($),G.add(z);try{if(Array.isArray($)&&Array.isArray(z)){if($.length!==z.length)return!1;for(let Q=0;Q<$.length;Q++)if(!p($[Q],z[Q],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(z))return!1;if(m($)&&m(z)){let Q=Object.keys($),X=Object.keys(z);if(Q.length!==X.length)return!1;for(let H of Q){if(!(H in z))return!1;if(!p($[H],z[H],G))return!1}return!0}return!1}finally{G.delete($),G.delete(z)}},Z$=($,z)=>{let G=$$($),Q=$$(z);if(!G||!Q){let C=!Object.is($,z);return{changed:C,add:C&&Q?z:{},change:{},remove:C&&G?$:{}}}let X=new WeakSet,H={},q={},F={},I=Object.keys($),_=Object.keys(z),O=new Set([...I,..._]);for(let C of O){let j=C in $,U=C in z;if(!j&&U){H[C]=z[C];continue}else if(j&&!U){F[C]=N;continue}let w=$[C],B=z[C];if(!p(w,B,X))q[C]=B}return{changed:Object.keys(H).length>0||Object.keys(q).length>0||Object.keys(F).length>0,add:H,change:q,remove:F}};var y,R$=new Set,H$=0,g=($)=>{let z=new Set,G=$;return G.unwatch=(Q)=>{z.add(Q)},G.cleanup=()=>{for(let Q of z)Q();z.clear()},G},b=($)=>{if(y&&!$.has(y)){let z=y;z.unwatch(()=>{$.delete(z)}),$.add(z)}},W=($)=>{for(let z of $)if(H$)R$.add(z);else z()},J$=()=>{while(R$.size){let $=Array.from(R$);R$.clear();for(let z of $)z()}},q$=($)=>{H$++;try{$()}finally{J$(),H$--}},h=($,z)=>{let G=y;y=z;try{$()}finally{y=G}};var D$="Computed",Y$=($,z=N)=>{if(!z$($))throw new S("computed",K($));if(z==null)throw new f("computed");let G=new Set,Q=z,X,H,q=!0,F=!1,I=!1,_=(B)=>{if(!p(B,Q))Q=B,F=!0;X=void 0,q=!1},O=()=>{F=N!==Q,Q=N,X=void 0},o=(B)=>{let P=E(B);F=!X||P.name!==X.name||P.message!==X.message,Q=N,X=P},C=(B)=>(P)=>{if(I=!1,H=void 0,B(P),F)W(G)},j=g(()=>{if(q=!0,H?.abort(),G.size)W(G);else j.cleanup()});j.unwatch(()=>{H?.abort()});let U=()=>h(()=>{if(I)throw new A("computed");if(F=!1,n($)){if(H)return Q;H=new AbortController,H.signal.addEventListener("abort",()=>{I=!1,H=void 0,U()},{once:!0})}let B;I=!0;try{B=H?$(Q,H.signal):$(Q)}catch(P){if(d(P))O();else o(P);I=!1;return}if(B instanceof Promise)B.then(C(_),C(o));else if(B==null||N===B)O();else _(B);I=!1},j),w={};return Object.defineProperties(w,{[Symbol.toStringTag]:{value:D$},get:{value:()=>{if(b(G),J$(),q)U();if(X)throw X;return Q}}}),w},s=($)=>V($,D$),z$=($)=>L($)&&$.length<3;var _$=($)=>{if(!L($)||$.length>1)throw new S("effect",K($));let z=n($),G=!1,Q,X=g(()=>h(()=>{if(G)throw new A("effect");G=!0,Q?.abort(),Q=void 0;let H;try{if(z){Q=new AbortController;let q=Q;$(Q.signal).then((F)=>{if(L(F)&&Q===q)X.unwatch(F)}).catch((F)=>{if(!d(F))console.error("Async effect error:",F)})}else if(H=$(),L(H))X.unwatch(H)}catch(q){if(!d(q))console.error("Effect callback error:",q)}G=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function W$($,z){try{if($.pending)z.nil?.();else if($.errors)z.err?.($.errors);else if($.ok)z.ok($.values)}catch(G){if(z.err&&(!$.errors||!$.errors.includes(E(G))))z.err($.errors?[...$.errors,E(G)]:[E(G)]);else throw G}}function L$($){let z=[],G=!1,Q={};for(let[X,H]of Object.entries($))try{let q=H.get();if(q===N)G=!0;else Q[X]=q}catch(q){z.push(E(q))}if(G)return{ok:!1,pending:!0};if(z.length>0)return{ok:!1,errors:z};return{ok:!0,values:Q}}var T$="State",t=($)=>{if($==null)throw new f("state");let z=new Set,G=$,Q=(H)=>{if(H==null)throw new f("state");if(p(G,H))return;if(G=H,W(z),N===G)z.clear()},X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:T$},get:{value:()=>{return b(z),G}},set:{value:(H)=>{Q(H)}},update:{value:(H)=>{if(!L(H))throw new S("state update",K(H));Q(H(G))}}}),X},k=($)=>V($,T$);var I$="Store",G$=($,z)=>{if($==null)throw new f("store");let G=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,H=new Map,q=Array.isArray($),F=0,I=new Map,_=new Map,O=(R)=>{let J=R;if(q){let Z=Number(R);if(Number.isInteger(Z)&&Z>=0)J=I.get(Z)??R}return X.get(J)},o=(R)=>{if(!q)return"";let J=F++;return u(z)?`${z}${J}`:L(z)?z(R):String(J)},C=(R)=>{if(!q)return R;let J={},Z=R;for(let Y=0;Y<Z.length;Y++){let T=Z[Y];if(T===void 0)continue;let M=I.get(Y);if(!M)M=o(T),I.set(Y,M),_.set(M,Y);J[M]=T}return J},j=()=>{let R={};for(let[J,Z]of X)R[J]=Z.get();return R},U=(R,J)=>{Object.freeze(J);for(let Z of Q[R])Z(J)},w=()=>Array.from(I.keys()).sort((R,J)=>R-J),B=(R,J)=>{if(J==null)throw new f(`store for key "${R}"`);if(J===N)return!0;if(c(J)||L(J)||s(J))throw new r(`store for key "${R}"`,K(J));return!0},P=(R,J,Z=!1)=>{if(!B(R,J))return!1;let Y=k(J)||i(J)?J:m(J)||Array.isArray(J)?G$(J):t(J);X.set(R,Y);let T=g(()=>h(()=>{U("change",{[R]:Y.get()})},T));if(T(),H.set(R,T),Z)W(G),U("add",{[R]:J});return!0},M$=(R,J=!1)=>{if(q){let Y=_.get(R);if(Y!==void 0)_.delete(R),I.delete(Y)}let Z=X.delete(R);if(Z){let Y=H.get(R);if(Y)Y.cleanup();H.delete(R)}if(J)W(G),U("remove",{[R]:N});return Z},Q$=(R,J,Z)=>{let Y=q?C(R):R,T=q?C(J):J,M=Z$(Y,T);return q$(()=>{if(Object.keys(M.add).length){for(let D in M.add){let x=M.add[D];if(x===void 0)continue;P(D,x??N,!1)}if(Z)setTimeout(()=>{U("add",M.add)},0);else U("add",M.add)}if(Object.keys(M.change).length){for(let D in M.change){let x=M.change[D];if(!B(D,x))continue;let v=X.get(D);if(N$(v))v.set(x);else throw new e(D,K(x))}U("change",M.change)}if(Object.keys(M.remove).length){for(let D in M.remove)M$(D);U("remove",M.remove)}}),M.changed};Q$(q?[]:{},$,!0);let B$={};return Object.defineProperties(B$,{[Symbol.toStringTag]:{value:I$},[Symbol.isConcatSpreadable]:{value:q},[Symbol.iterator]:{value:q?function*(){let R=w();for(let J of R){let Z=I.get(J);if(Z)yield X.get(Z)}}:function*(){for(let[R,J]of X)yield[R,J]}},add:{value:q?(R)=>{let J=I.size,Z=o(R);I.set(J,Z),_.set(Z,J),P(Z,R,!0)}:(R,J)=>{if(!X.has(R))P(R,J,!0);else throw new l(R,K(J))}},byKey:{value(R){return O(R)}},keyAt:{value(R){if(!q)return;return I.get(R)}},indexByKey:{value(R){if(!q)return;return _.get(R)}},get:{value:()=>{if(b(G),q){let R=[];for(let[J,Z]of I.entries()){let Y=X.get(Z);if(Y)R[J]=Y.get()}return R}else return j()}},remove:{value:q?(R)=>{if(R<0||R>=X.size)throw new a(R);let J=I.get(R);if(!J)return;M$(J,!1);let Z=new Map,Y=new Map,T=0;for(let[M,D]of I.entries())if(M!==R)Z.set(T,D),Y.set(D,T),T++;I.clear(),_.clear(),Z.forEach((M,D)=>{I.set(D,M),_.set(M,D)}),W(G),U("remove",{[J]:N})}:(R)=>{if(X.has(R))M$(R,!0)}},set:{value:(R)=>{let J=q?X$(j()):j();if(Q$(J,R)){if(W(G),N===R)G.clear()}}},update:{value:(R)=>{let J=j(),Z=R(X$(J));if(Q$(J,Z)){if(W(G),N===Z)G.clear()}}},sort:{value:(R)=>{if(q){let J=Array.from(I.entries()).map(([M,D])=>{let x=X.get(D);return[M,D,x?x.get():void 0]}).sort(R?(M,D)=>R(M[2],D[2]):(M,D)=>String(M[2]).localeCompare(String(D[2]))),Z=new Map,Y=new Map;J.forEach(([M,D,x],v)=>{Z.set(v,D),Y.set(D,v)}),I.clear(),_.clear(),Z.forEach((M,D)=>{I.set(D,M),_.set(M,D)});let T=J.map(([M])=>String(M));W(G),U("sort",T)}else{let J=Array.from(X.entries()).map(([T,M])=>[T,M.get()]).sort(R?(T,M)=>R(T[1],M[1]):(T,M)=>String(T[1]).localeCompare(String(M[1]))),Z=new Map;J.forEach(([T])=>{let M=String(T),D=X.get(M);if(D)Z.set(M,D)}),X.clear(),Z.forEach((T,M)=>X.set(M,T));let Y=J.map(([T])=>String(T));W(G),U("sort",Y)}}},on:{value:(R,J)=>{return Q[R].add(J),()=>Q[R].delete(J)}},length:{get(){return b(G),X.size}}}),new Proxy(B$,{get(R,J){if(J in R)return Reflect.get(R,J);if(!c(J))return O(J)},has(R,J){if(J in R)return!0;return X.has(String(J))},ownKeys(R){let J=Reflect.ownKeys(R),Z=q?w().map((Y)=>String(Y)):Array.from(X.keys());return[...new Set([...Z,...J])]},getOwnPropertyDescriptor(R,J){if(J in R)return Reflect.getOwnPropertyDescriptor(R,J);if(c(J))return;let Z=O(J);return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},i=($)=>V($,I$);var F$=($)=>k($)||s($)||i($),N$=($)=>k($)||i($);function P$($){if(F$($))return $;if(z$($))return Y$($);if(Array.isArray($)||m($))return G$($);return t($)}export{K as valueString,P$ as toSignal,E as toError,b as subscribe,L$ as resolve,h as observe,W as notify,W$ as match,c as isSymbol,u as isString,i as isStore,k as isState,F$ as isSignal,$$ as isRecordOrArray,m as isRecord,V as isObjectOfType,C$ as isNumber,N$ as isMutableSignal,L as isFunction,p as isEqual,z$ as isComputedCallback,s as isComputed,n as isAsyncFunction,d as isAbortError,J$ as flush,Z$ as diff,g as createWatcher,G$ as createStore,t as createState,_$ as createEffect,Y$ as createComputed,q$ as batch,N as UNSET,I$ as TYPE_STORE,T$ as TYPE_STATE,D$ as TYPE_COMPUTED,e as StoreKeyReadonlyError,a as StoreKeyRangeError,l as StoreKeyExistsError,f as NullishSignalValueError,r as InvalidSignalValueError,S as InvalidCallbackError,A as CircularDependencyError};
