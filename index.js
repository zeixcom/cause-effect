var Q=(y)=>typeof y==="function";var g=(y)=>Q(y)&&y.length<2,q=(y,x)=>Object.prototype.toString.call(y)===`[object ${x}]`,w=(y)=>(x)=>x instanceof y,p=w(Error),o=w(Promise),C=(y)=>p(y)?y:new Error(String(y));if(!("requestAnimationFrame"in globalThis))globalThis.requestAnimationFrame=(y)=>setTimeout(y,16);var Z,D=new Set,O=new Set,F=new Map,E=!1,R,f=()=>{R=null;for(let y of F.values()){for(let x of y.values())x();y.clear()}},n=()=>{if(R)cancelAnimationFrame(R);R=requestAnimationFrame(f)};queueMicrotask(f);var _=()=>{E=!1;while(D.size||O.size){for(let y of D)y();D.clear();for(let y of O)y();O.clear()}},Y=(y)=>{if(Z&&!y.includes(Z))y.push(Z)},N=(y)=>{for(let x of y)D.add(x);if(!E)E=!0,queueMicrotask(_)},P=(y,x)=>{let L=Z;Z=x,y(),Z=L},i=(y,x)=>new Promise((L,$)=>{let B=()=>{try{L(y())}catch(z){$(z)}};if(x){let[z,J]=x;if(!F.has(z))F.set(z,new Map);F.get(z).set(J,B)}n()});function I(y,...x){let L=Q(y)?{ok:y}:y,{ok:$,nil:B,err:z}=L,J=()=>P(()=>{let A=[],X=[],K=!1;for(let G of x)try{let V=G.get();if(V===W)K=!0;A.push(V)}catch(V){X.push(C(V))}try{if(!K&&!X.length)$(...A);else if(X.length&&z)z(...X);else if(K&&B)B()}catch(G){z?.(C(G))}},J);J()}var b="Computed",j=(y)=>{let x=[],L=W,$=null,B=!0,z=!1,J=!1,A=()=>{if(B=!0,!z)N(x)},X=()=>P(()=>{if(!B)return;if(J)throw new Error("Circular dependency detected");let G=(H)=>{if(!Object.is(H,L))L=H,B=!1,$=null,z=!1;else z=!0},V=(H)=>{let T=C(H);z=Object.is(T,$),$=T};J=!0;try{let H=y(L);o(H)?H.then((T)=>{G(T),N(x)}).catch(V):G(H)}catch(H){V(H)}finally{J=!1}},A),K={[Symbol.toStringTag]:b,get:()=>{if(Y(x),X(),$)throw $;return L},map:(G)=>j(()=>G(K.get())),match:(G)=>I(G,K)};return K},M=(y)=>q(y,b);var m="State",S=(y)=>{let x=[],L=y,$={[Symbol.toStringTag]:m,get:()=>{return Y(x),L},set:(B)=>{if(Object.is(L,B))return;if(L=B,N(x),W===L)x.length=0},update:(B)=>{$.set(B(L))},map:(B)=>{return j(()=>B($.get()))},match:(B)=>I(B,$)};return $},U=(y)=>q(y,m);var W=Symbol(),k=(y)=>U(y)||M(y),h=(y)=>k(y)?y:g(y)?j(y):S(y);export{h as toSignal,S as state,U as isState,k as isSignal,M as isComputed,_ as flush,i as enqueue,I as effect,j as computed,W as UNSET};
