class f extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class m extends TypeError{constructor($,z){super(`Invalid ${$} callback ${z}`);this.name="InvalidCallbackError"}}class i extends TypeError{constructor($,z){super(`Invalid signal value ${z} in ${$}`);this.name="InvalidSignalValueError"}}class P extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class t extends Error{constructor($,z){super(`Could not add store key "${$}" with value ${z} because it already exists`);this.name="StoreKeyExistsError"}}class l extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class r extends Error{constructor($,z){super(`Could not set store key "${$}" to ${z} because it is readonly`);this.name="StoreKeyReadonlyError"}}var K=Symbol(),a=($)=>typeof $==="string",Z$=($)=>typeof $==="number",v=($)=>typeof $==="symbol",I=($)=>typeof $==="function",o=($)=>I($)&&$.constructor.name==="AsyncFunction",S=($,z)=>Object.prototype.toString.call($)===`[object ${z}]`,W=($)=>S($,"Object"),e=($)=>W($)||Array.isArray($);var g=($)=>$ instanceof DOMException&&$.name==="AbortError",C=($)=>$ instanceof Error?$:Error(String($)),U=($)=>a($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var O=($,z,G)=>{if(Object.is($,z))return!0;if(typeof $!==typeof z)return!1;if(typeof $!=="object"||$===null||z===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(z))throw new f("isEqual");G.add($),G.add(z);try{if(Array.isArray($)&&Array.isArray(z)){if($.length!==z.length)return!1;for(let Q=0;Q<$.length;Q++)if(!O($[Q],z[Q],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(z))return!1;if(W($)&&W(z)){let Q=Object.keys($),X=Object.keys(z);if(Q.length!==X.length)return!1;for(let Z of Q){if(!(Z in z))return!1;if(!O($[Z],z[Z],G))return!1}return!0}return!1}finally{G.delete($),G.delete(z)}},x$=($,z)=>{let G=e($),Q=e(z);if(!G||!Q){let Y=!Object.is($,z);return{changed:Y,add:Y&&Q?z:{},change:{},remove:Y&&G?$:{}}}let X=new WeakSet,Z={},H={},D={},x=Object.keys($),j=Object.keys(z),E=new Set([...x,...j]);for(let Y of E){let _=Y in $,F=Y in z;if(!_&&F){Z[Y]=z[Y];continue}else if(_&&!F){D[Y]=K;continue}let p=$[Y],T=z[Y];if(!O(p,T,X))H[Y]=T}return{add:Z,change:H,remove:D,changed:!!(Object.keys(Z).length||Object.keys(H).length||Object.keys(D).length)}};var k,$$=new Set,H$=0,w=($)=>{let z=new Set,G=$;return G.unwatch=(Q)=>{z.add(Q)},G.cleanup=()=>{for(let Q of z)Q();z.clear()},G},V=($)=>{if(k&&!$.has(k)){let z=k;z.unwatch(()=>{$.delete(z)}),$.add(z)}},L=($)=>{for(let z of $)if(H$)$$.add(z);else z()},B$=()=>{while($$.size){let $=Array.from($$);$$.clear();for(let z of $)z()}},R$=($)=>{H$++;try{$()}finally{B$(),H$--}},b=($,z)=>{let G=k;k=z;try{$()}finally{k=G}};var q$="Computed",K$=($,z=K)=>{if(!J$($))throw new m("computed",U($));if(z==null)throw new P("computed");let G=new Set,Q=z,X,Z,H=!0,D=!1,x=!1,j=(A)=>{if(!O(A,Q))Q=A,D=!0;X=void 0,H=!1},E=()=>{D=K!==Q,Q=K,X=void 0},Y=(A)=>{let N=C(A);D=!X||N.name!==X.name||N.message!==X.message,Q=K,X=N},_=(A)=>(N)=>{if(x=!1,Z=void 0,A(N),D)L(G)},F=w(()=>{if(H=!0,Z?.abort(),G.size)L(G);else F.cleanup()});F.unwatch(()=>{Z?.abort()});let p=()=>b(()=>{if(x)throw new f("computed");if(D=!1,o($)){if(Z)return Q;Z=new AbortController,Z.signal.addEventListener("abort",()=>{x=!1,Z=void 0,p()},{once:!0})}let A;x=!0;try{A=Z?$(Q,Z.signal):$(Q)}catch(N){if(g(N))E();else Y(N);x=!1;return}if(A instanceof Promise)A.then(_(j),_(Y));else if(A==null||K===A)E();else j(A);x=!1},F),T={};return Object.defineProperties(T,{[Symbol.toStringTag]:{value:q$},get:{value:()=>{if(V(G),B$(),H)p();if(X)throw X;return Q}}}),T},d=($)=>S($,q$),J$=($)=>I($)&&$.length<3;var P$=($)=>{if(!I($)||$.length>1)throw new m("effect",U($));let z=o($),G=!1,Q,X=w(()=>b(()=>{if(G)throw new f("effect");G=!0,Q?.abort(),Q=void 0;let Z;try{if(z){Q=new AbortController;let H=Q;$(Q.signal).then((D)=>{if(I(D)&&Q===H)X.unwatch(D)}).catch((D)=>{if(!g(D))console.error("Async effect error:",D)})}else if(Z=$(),I(Z))X.unwatch(Z)}catch(H){if(!g(H))console.error("Effect callback error:",H)}G=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function _$($,z){try{if($.pending)z.nil?.();else if($.errors)z.err?.($.errors);else if($.ok)z.ok($.values)}catch(G){if(z.err&&(!$.errors||!$.errors.includes(C(G))))z.err($.errors?[...$.errors,C(G)]:[C(G)]);else throw G}}function T$($){let z=[],G=!1,Q={};for(let[X,Z]of Object.entries($))try{let H=Z.get();if(H===K)G=!0;else Q[X]=H}catch(H){z.push(C(H))}if(G)return{ok:!1,pending:!0};if(z.length>0)return{ok:!1,errors:z};return{ok:!0,values:Q}}var Y$="State",n=($)=>{if($==null)throw new P("state");let z=new Set,G=$,Q=(Z)=>{if(Z==null)throw new P("state");if(O(G,Z))return;if(G=Z,L(z),K===G)z.clear()},X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:Y$},get:{value:()=>{return V(z),G}},set:{value:(Z)=>{Q(Z)}},update:{value:(Z)=>{if(!I(Z))throw new m("state update",U(Z));Q(Z(G))}}}),X},h=($)=>S($,Y$);var D$="Store",z$=($,z)=>{if($==null)throw new P("store");let G=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,Z=new Map,H=Array.isArray($),D=0,x=[],j=(B)=>{let J=B;if(H){let M=Number(B);if(Number.isInteger(M)&&M>=0)J=x[M]??B}return X.get(J)},E=(B)=>{if(!H)return"";let J=D++;return a(z)?`${z}${J}`:I(z)?z(B):String(J)},Y=(B)=>{if(!Array.isArray(B))return B;let J={};for(let M=0;M<B.length;M++){let R=B[M];if(R===void 0)continue;let q=x[M];if(!q)q=E(R),x[M]=q;J[q]=R}return J},_=()=>{if(H)return x.map((J)=>X.get(J)?.get()).filter((J)=>J!==void 0);let B={};for(let J of x){let M=X.get(J);if(M)B[J]=M.get()}return B},F=(B,J)=>{Object.freeze(J);for(let M of Q[B])M(J)},p=(B,J)=>{if(J==null)throw new P(`store for key "${B}"`);if(J===K)return!0;if(v(J)||I(J)||d(J))throw new i(`store for key "${B}"`,U(J));return!0},T=(B,J,M=!1)=>{if(!p(B,J))return!1;let R=h(J)||u(J)?J:W(J)||Array.isArray(J)?z$(J):n(J);if(X.set(B,R),!x.includes(B))x.push(B);let q=w(()=>b(()=>{F("change",{[B]:R.get()})},q));if(q(),Z.set(B,q),M)L(G),F("add",{[B]:J});return!0},A=(B,J=!1)=>{if(!X.delete(B))return;let R=x.indexOf(B);if(R>=0)x.splice(R,1);let q=Z.get(B);if(q)q.cleanup();if(Z.delete(B),J)x=x.filter(()=>!0),L(G),F("remove",{[B]:K})},N=(B,J)=>{if(Object.keys(B.add).length){for(let M in B.add)T(M,B.add[M]??K,!1);if(J)setTimeout(()=>{F("add",B.add)},0);else F("add",B.add)}if(Object.keys(B.change).length)R$(()=>{for(let M in B.change){let R=B.change[M];if(!p(M,R))continue;let q=X.get(M);if(A$(q))q.set(R);else throw new r(M,U(R))}F("change",B.change)});if(Object.keys(B.remove).length){for(let M in B.remove)A(M);x=x.filter(()=>!0),F("remove",B.remove)}return B.changed},G$=(B,J,M)=>N(x$(H?Y(B):B,H?Y(J):J),M);G$(H?[]:{},$,!0);let F$={};return Object.defineProperties(F$,{[Symbol.toStringTag]:{value:D$},[Symbol.isConcatSpreadable]:{value:H},[Symbol.iterator]:{value:function*(){for(let B of x){let J=X.get(B);if(J)yield H?J:[B,J]}}},add:{value:H?(B)=>{let J=x.length,M=E(B);x[J]=M,T(M,B,!0)}:(B,J)=>{if(!X.has(B))T(B,J,!0);else throw new t(B,U(J))}},byKey:{value(B){return j(B)}},keyAt:{value(B){return x[B]}},indexOfKey:{value(B){return x.indexOf(B)}},get:{value:()=>{return V(G),_()}},remove:{value:(B)=>{let J=String(B);if(Z$(B)){if(!x[B])throw new l(B);J=x[B]}if(X.has(J))A(J,!0)}},set:{value:(B)=>{if(G$(_(),B)){if(L(G),K===B)G.clear()}}},update:{value:(B)=>{let J=_(),M=B(J);if(G$(J,M)){if(L(G),K===M)G.clear()}}},sort:{value:(B)=>{x=x.map((M,R)=>{let q=X.get(M);return[R,M,q?q.get():void 0]}).sort(B?(M,R)=>B(M[2],R[2]):(M,R)=>String(M[2]).localeCompare(String(R[2]))).map(([M,R])=>R),L(G),F("sort",[...x])}},splice:{value:(B,J,...M)=>{if(!H)throw Error("Cannot splice non-array-like object");let R=X.size,q=B<0?Math.max(0,R+B):Math.min(B,R),I$=Math.max(0,Math.min(J??Math.max(0,R-Math.max(0,q)),R-q)),M$={},c={};for(let y=0;y<I$;y++){let s=q+y,X$=x[s];if(X$){let N$=X.get(X$);if(N$)c[X$]=N$.get()}}let Q$=x.slice(0,q);for(let y of M){let s=E(y);Q$.push(s),M$[s]=y}Q$.push(...x.slice(q+I$)),x=Q$.filter(()=>!0);let L$=!!(Object.keys(M$).length||Object.keys(c).length);if(L$)N({add:M$,change:{},remove:c,changed:L$});return L(G),Object.values(c)}},on:{value:(B,J)=>{return Q[B].add(J),()=>Q[B].delete(J)}},length:{get(){return V(G),X.size}}}),new Proxy(F$,{get(B,J){if(J in B)return Reflect.get(B,J);if(!v(J))return j(J)},has(B,J){if(J in B)return!0;return X.has(String(J))},ownKeys(B){let J=Reflect.ownKeys(B);return[...new Set([...x,...J])]},getOwnPropertyDescriptor(B,J){if(J in B)return Reflect.getOwnPropertyDescriptor(B,J);if(v(J))return;let M=j(J);return M?{enumerable:!0,configurable:!0,writable:!0,value:M}:void 0}})},u=($)=>S($,D$);var U$=($)=>h($)||d($)||u($),A$=($)=>h($)||u($);function W$($){if(U$($))return $;if(J$($))return K$($);if(Array.isArray($)||W($))return z$($);return n($)}export{U as valueString,W$ as toSignal,C as toError,V as subscribe,T$ as resolve,b as observe,L as notify,_$ as match,v as isSymbol,a as isString,u as isStore,h as isState,U$ as isSignal,e as isRecordOrArray,W as isRecord,S as isObjectOfType,Z$ as isNumber,A$ as isMutableSignal,I as isFunction,O as isEqual,J$ as isComputedCallback,d as isComputed,o as isAsyncFunction,g as isAbortError,B$ as flush,x$ as diff,w as createWatcher,z$ as createStore,n as createState,P$ as createEffect,K$ as createComputed,R$ as batch,K as UNSET,D$ as TYPE_STORE,Y$ as TYPE_STATE,q$ as TYPE_COMPUTED,r as StoreKeyReadonlyError,l as StoreKeyRangeError,t as StoreKeyExistsError,P as NullishSignalValueError,i as InvalidSignalValueError,m as InvalidCallbackError,f as CircularDependencyError};
