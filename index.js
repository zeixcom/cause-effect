var M,O=new Set,E=0,f=new Map,P,c=()=>{P=void 0;let $=Array.from(f.values());f.clear();for(let H of $)H()},n=()=>{if(P)cancelAnimationFrame(P);P=requestAnimationFrame(c)};queueMicrotask(c);var D=($)=>{let H=new Set,B=$;return B.off=(z)=>{H.add(z)},B.cleanup=()=>{for(let z of H)z();H.clear()},B},j=($)=>{if(M&&!$.has(M)){let H=M;$.add(H),M.off(()=>{$.delete(H)})}},Z=($)=>{for(let H of $)if(E)O.add(H);else H()},_=()=>{while(O.size){let $=Array.from(O);O.clear();for(let H of $)H()}},s=($)=>{E++;try{$()}finally{_(),E--}},I=($,H)=>{let B=M;M=H;try{$()}finally{M=B}},u=($,H)=>new Promise((B,z)=>{f.set(H||Symbol(),()=>{try{B($())}catch(G){z(G)}}),n()});var C=($)=>typeof $==="function",R=($)=>C($)&&$.constructor.name==="AsyncFunction",F=($,H)=>Object.prototype.toString.call($)===`[object ${H}]`,Y=($)=>$ instanceof DOMException&&$.name==="AbortError",V=($)=>$ instanceof Error?$:Error(String($));class q extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var b="State",N=($)=>{let H=new Set,B=$,z={[Symbol.toStringTag]:b,get:()=>{return j(H),B},set:(G)=>{if(Object.is(B,G))return;if(B=G,Z(H),Q===B)H.clear()},update:(G)=>{z.set(G(B))}};return z},U=($)=>F($,b);var g="Store",m=($)=>{let H=new Set,B=new Map,z=(K,W)=>{if(typeof W==="function")throw Error(`Functions are not allowed as store property values (property: ${String(K)})`);if(F(W,"Object"))return m(W);else return N(W)};for(let[K,W]of Object.entries($))B.set(K,z(K,W));let G=new Proxy({},{get(K,W){if(W===Symbol.toStringTag)return g;if(W==="get")return()=>{j(H);let J={};for(let[X,x]of B)J[X]=x.get();return J};if(W==="has")return(J)=>{return B.has(J)};if(W==="add")return(J,X)=>{if(B.has(J))throw Error(`Property '${J}' already exists`);let x=z(J,X);return B.set(J,x),Z(H),G};if(W==="delete")return(J)=>{if(!B.has(J))throw Error(`Property '${J}' does not exist`);let X=B.get(J);if(U(X))X.set(Q);return B.delete(J),Z(H),G};if(B.has(W))return B.get(W);throw Error(`Property '${String(W)}' does not exist on store`)},has(K,W){return B.has(W)||W==="get"||W==="has"||W==="add"||W==="delete"||W===Symbol.toStringTag},ownKeys(K){return Array.from(B.keys())},getOwnPropertyDescriptor(K,W){if(this.has?.(K,W))return{enumerable:!0,configurable:!0};return}});return G},k=($)=>F($,g);var Q=Symbol(),i=($)=>U($)||S($)||k($),o=($)=>i($)?$:y($)?w($):F($,"Object")?m($):N($);var d="Computed",w=($)=>{let H=new Set,B=Q,z,G,K=!0,W=!1,J=!1,X=(L)=>{if(!Object.is(L,B))B=L,W=!0;z=void 0,K=!1},x=()=>{W=Q!==B,B=Q,z=void 0},h=(L)=>{let A=V(L);W=!z||A.name!==z.name||A.message!==z.message,B=Q,z=A},v=(L)=>(A)=>{if(J=!1,G=void 0,L(A),W)Z(H)},T=D(()=>{if(K=!0,G?.abort(),H.size)Z(H);else T.cleanup()});T.off(()=>{G?.abort()});let p=()=>I(()=>{if(J)throw new q("computed");if(W=!1,R($)){if(G)return B;G=new AbortController,G.signal.addEventListener("abort",()=>{J=!1,G=void 0,p()},{once:!0})}let L;J=!0;try{L=G?$(G.signal):$()}catch(A){if(Y(A))x();else h(A);J=!1;return}if(L instanceof Promise)L.then(v(X),v(h));else if(L==null||Q===L)x();else X(L);J=!1},T);return{[Symbol.toStringTag]:d,get:()=>{if(j(H),_(),K)p();if(z)throw z;return B}}},S=($)=>F($,d),y=($)=>C($)&&$.length<2;var t=($)=>{let H=R($),B=!1,z,G=D(()=>I(()=>{if(B)throw new q("effect");B=!0,z?.abort(),z=void 0;let K;try{if(H){z=new AbortController;let W=z;$(z.signal).then((J)=>{if(C(J)&&z===W)G.off(J)}).catch((J)=>{if(!Y(J))console.error("Async effect error:",J)})}else if(K=$(),C(K))G.off(K)}catch(W){if(!Y(W))console.error("Effect callback error:",W)}B=!1},G));return G(),()=>{z?.abort(),G.cleanup()}};function l($,H){try{if($.pending)H.nil?.();else if($.errors)H.err?.($.errors);else H.ok?.($.values)}catch(B){if(H.err&&(!$.errors||!$.errors.includes(V(B)))){let z=$.errors?[...$.errors,V(B)]:[V(B)];H.err(z)}else throw B}}function a($){let H=[],B=!1,z={};for(let[G,K]of Object.entries($))try{let W=K.get();if(W===Q)B=!0;else z[G]=W}catch(W){H.push(V(W))}if(B)return{ok:!1,pending:!0};if(H.length>0)return{ok:!1,errors:H};return{ok:!0,values:z}}export{D as watch,o as toSignal,V as toError,j as subscribe,m as store,N as state,a as resolve,I as observe,Z as notify,l as match,k as isStore,U as isState,i as isSignal,C as isFunction,y as isComputedCallback,S as isComputed,R as isAsyncFunction,Y as isAbortError,_ as flush,u as enqueue,t as effect,w as computed,s as batch,Q as UNSET,g as TYPE_STORE,b as TYPE_STATE,d as TYPE_COMPUTED,q as CircularDependencyError};
