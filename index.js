var q,f=new Set,h=0,d=new Map,k,a=()=>{k=void 0;let $=Array.from(d.values());d.clear();for(let B of $)B()},G$=()=>{if(k)cancelAnimationFrame(k);k=requestAnimationFrame(a)};queueMicrotask(a);var O=($)=>{let B=new Set,W=$;return W.off=(A)=>{B.add(A)},W.cleanup=()=>{for(let A of B)A();B.clear()},W},P=($)=>{if(q&&!$.has(q)){let B=q;$.add(B),q.off(()=>{$.delete(B)})}},H=($)=>{for(let B of $)if(h)f.add(B);else B()},w=()=>{while(f.size){let $=Array.from(f);f.clear();for(let B of $)B()}},v=($)=>{h++;try{$()}finally{w(),h--}},E=($,B)=>{let W=q;q=B;try{$()}finally{q=W}},J$=($,B)=>new Promise((W,A)=>{d.set(B||Symbol(),()=>{try{W($())}catch(Q){A(Q)}}),G$()});var e=($)=>typeof $==="string",$$=($)=>typeof $==="number",Y=($)=>typeof $==="function",y=($)=>Y($)&&$.constructor.name==="AsyncFunction",_=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,D=($)=>_($,"Object"),g=($)=>D($)||Array.isArray($),B$=($)=>{if(!$.length)return null;let B=$.map((W)=>e(W)?parseInt(W,10):$$(W)?W:NaN);return B.every((W)=>Number.isFinite(W)&&W>=0)?B.sort((W,A)=>W-A):null},W$=($,B)=>(B in $)&&Y($[B]),V=($)=>$ instanceof DOMException&&$.name==="AbortError",M=($)=>$ instanceof Error?$:Error(String($));class N extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var o="State",S=($)=>{let B=new Set,W=$,A={[Symbol.toStringTag]:o,get:()=>{return P(B),W},set:(Q)=>{if(I(W,Q))return;if(W=Q,H(B),C===W)B.clear()},update:(Q)=>{A.set(Q(W))}};return A},p=($)=>_($,o);var c=($)=>{let B=y($),W=!1,A,Q=O(()=>E(()=>{if(W)throw new N("effect");W=!0,A?.abort(),A=void 0;let x;try{if(B){A=new AbortController;let Z=A;$(A.signal).then((F)=>{if(Y(F)&&A===Z)Q.off(F)}).catch((F)=>{if(!V(F))console.error("Async effect error:",F)})}else if(x=$(),Y(x))Q.off(x)}catch(Z){if(!V(Z))console.error("Effect callback error:",Z)}W=!1},Q));return Q(),()=>{A?.abort(),Q.cleanup()}};var n="Store",m=($)=>{let B=new Set,W=new EventTarget,A=new Map,Q=new Map,x=S(0),Z=()=>{let L=Array.from(A.keys()),R=B$(L);if(R)return R.map((J)=>A.get(String(J))?.get());let G={};for(let[J,X]of A)G[J]=X.get();return G},F=(L,R)=>W.dispatchEvent(new CustomEvent(L,{detail:R})),K=(L,R)=>{let G=String(L),J=u(R);A.set(G,J);let X=c(()=>{let j=J.get();if(j!=null)F("store-change",{[L]:j})});Q.set(G,X)},U=(L)=>{let R=String(L);A.delete(R);let G=Q.get(R);if(G)G();Q.delete(R)},z=(L,R)=>{let G=i(L,R);return v(()=>{if(Object.keys(G.add).length){for(let J in G.add){let X=G.add[J];if(X!=null)K(J,X)}F("store-add",G.add)}if(Object.keys(G.change).length){for(let J in G.change){let X=A.get(J),j=G.change[J];if(X&&j!=null&&W$(X,"set"))X.set(j)}F("store-change",G.change)}if(Object.keys(G.remove).length){for(let J in G.remove)U(J);F("store-remove",G.remove)}x.set(A.size)}),G.changed};z({},$),setTimeout(()=>{let L=new CustomEvent("store-add",{detail:$});W.dispatchEvent(L)},0);let T=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(L,R){switch(R){case"add":return(G,J)=>{if(!A.has(G))K(G,J),H(B),F("store-add",{[G]:J}),x.set(A.size)};case"get":return()=>{return P(B),Z()};case"remove":return(G)=>{if(A.has(G))U(G),H(B),F("store-remove",{[G]:C}),x.set(A.size)};case"set":return(G)=>{if(z(Z(),G)){if(H(B),C===G)B.clear()}};case"update":return(G)=>{let J=Z(),X=G(J);if(z(J,X)){if(H(B),C===X)B.clear()}};case"addEventListener":return W.addEventListener.bind(W);case"removeEventListener":return W.removeEventListener.bind(W);case"dispatchEvent":return W.dispatchEvent.bind(W);case"size":return x}if(R===Symbol.toStringTag)return n;if(R===Symbol.iterator)return function*(){for(let[G,J]of A)yield[G,J]};return A.get(String(R))},has(L,R){let G=String(R);return A.has(G)||T.includes(G)||R===Symbol.toStringTag||R===Symbol.iterator},ownKeys(){return Array.from(A.keys()).map((L)=>String(L))},getOwnPropertyDescriptor(L,R){let G=A.get(String(R));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},b=($)=>_($,n);var C=Symbol(),A$=($)=>p($)||s($)||b($);function L$($){if(A$($))return $;if(r($))return t($);if(Array.isArray($))return m($);if(Array.isArray($)||D($))return m($);return S($)}function u($){if(p($)||b($))return $;if(Array.isArray($))return m($);if(D($))return m($);return S($)}var I=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new N("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let A=0;A<$.length;A++)if(!I($[A],B[A],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(D($)&&D(B)){let A=Object.keys($),Q=Object.keys(B);if(A.length!==Q.length)return!1;for(let x of A){if(!(x in B))return!1;if(!I($[x],B[x],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},i=($,B)=>{let W=g($),A=g(B);if(!W||!A){let L=!Object.is($,B);return{changed:L,add:L&&A?B:{},change:{},remove:L&&W?$:{}}}let Q=new WeakSet,x={},Z={},F={},K=Object.keys($),U=Object.keys(B),z=new Set([...K,...U]);for(let L of z){let R=L in $,G=L in B;if(!R&&G){x[L]=B[L];continue}else if(R&&!G){F[L]=C;continue}let J=$[L],X=B[L];if(!I(J,X,Q))Z[L]=X}return{changed:Object.keys(x).length>0||Object.keys(Z).length>0||Object.keys(F).length>0,add:x,change:Z,remove:F}};var l="Computed",t=($)=>{let B=new Set,W=C,A,Q,x=!0,Z=!1,F=!1,K=(J)=>{if(!I(J,W))W=J,Z=!0;A=void 0,x=!1},U=()=>{Z=C!==W,W=C,A=void 0},z=(J)=>{let X=M(J);Z=!A||X.name!==A.name||X.message!==A.message,W=C,A=X},T=(J)=>(X)=>{if(F=!1,Q=void 0,J(X),Z)H(B)},L=O(()=>{if(x=!0,Q?.abort(),B.size)H(B);else L.cleanup()});L.off(()=>{Q?.abort()});let R=()=>E(()=>{if(F)throw new N("computed");if(Z=!1,y($)){if(Q)return W;Q=new AbortController,Q.signal.addEventListener("abort",()=>{F=!1,Q=void 0,R()},{once:!0})}let J;F=!0;try{J=Q?$(Q.signal):$()}catch(X){if(V(X))U();else z(X);F=!1;return}if(J instanceof Promise)J.then(T(K),T(z));else if(J==null||C===J)U();else K(J);F=!1},L);return{[Symbol.toStringTag]:l,get:()=>{if(P(B),w(),x)R();if(A)throw A;return W}}},s=($)=>_($,l),r=($)=>Y($)&&$.length<2;function Q$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(M(W))))B.err($.errors?[...$.errors,M(W)]:[M(W)]);else throw W}}function R$($){let B=[],W=!1,A={};for(let[Q,x]of Object.entries($))try{let Z=x.get();if(Z===C)W=!0;else A[Q]=Z}catch(Z){B.push(M(Z))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:A}}export{O as watch,L$ as toSignal,u as toMutableSignal,M as toError,P as subscribe,m as store,S as state,R$ as resolve,E as observe,H as notify,Q$ as match,e as isString,b as isStore,p as isState,A$ as isSignal,g as isRecordOrArray,D as isRecord,$$ as isNumber,Y as isFunction,I as isEqual,r as isComputedCallback,s as isComputed,y as isAsyncFunction,V as isAbortError,w as flush,J$ as enqueue,c as effect,i as diff,t as computed,v as batch,C as UNSET,n as TYPE_STORE,o as TYPE_STATE,l as TYPE_COMPUTED,N as CircularDependencyError};
