class A extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class c extends TypeError{constructor($,x){super(`Invalid signal value ${x} in ${$}`);this.name="InvalidSignalValueError"}}class V extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class v extends Error{constructor($,x){super(`Could not add store key "${$}" with value ${x} because it already exists`);this.name="StoreKeyExistsError"}}class n extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class t extends Error{constructor($,x){super(`Could not set store key "${$}" to ${x} because it is readonly`);this.name="StoreKeyReadonlyError"}}var H=Symbol(),e=($)=>typeof $==="string",I$=($)=>typeof $==="number",w=($)=>typeof $==="symbol",U=($)=>typeof $==="function",b=($)=>U($)&&$.constructor.name==="AsyncFunction",_=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,L=($)=>_($,"Object"),u=($)=>L($)||Array.isArray($),z$=($)=>{if(!$.length)return null;let x=$.map((Q)=>e(Q)?parseInt(Q,10):I$(Q)?Q:NaN);return x.every((Q)=>Number.isFinite(Q)&&Q>=0)?x.sort((Q,X)=>Q-X):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",N=($)=>$ instanceof Error?$:Error(String($));var s=($)=>{let x=z$(Object.keys($));if(x===null)return $;let Q=[];for(let X of x)Q.push($[String(X)]);return Q},g=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var P=($,x,Q)=>{if(Object.is($,x))return!0;if(typeof $!==typeof x)return!1;if(typeof $!=="object"||$===null||x===null)return!1;if(!Q)Q=new WeakSet;if(Q.has($)||Q.has(x))throw new A("isEqual");Q.add($),Q.add(x);try{if(Array.isArray($)&&Array.isArray(x)){if($.length!==x.length)return!1;for(let X=0;X<$.length;X++)if(!P($[X],x[X],Q))return!1;return!0}if(Array.isArray($)!==Array.isArray(x))return!1;if(L($)&&L(x)){let X=Object.keys($),M=Object.keys(x);if(X.length!==M.length)return!1;for(let C of X){if(!(C in x))return!1;if(!P($[C],x[C],Q))return!1}return!0}return!1}finally{Q.delete($),Q.delete(x)}},$$=($,x)=>{let Q=u($),X=u(x);if(!Q||!X){let q=!Object.is($,x);return{changed:q,add:q&&X?x:{},change:{},remove:q&&Q?$:{}}}let M=new WeakSet,C={},I={},K={},z=Object.keys($),j=Object.keys(x),f=new Set([...z,...j]);for(let q of f){let Y=q in $,D=q in x;if(!Y&&D){C[q]=x[q];continue}else if(Y&&!D){K[q]=H;continue}let J=$[q],B=x[q];if(!P(J,B,M))I[q]=B}return{changed:Object.keys(C).length>0||Object.keys(I).length>0||Object.keys(K).length>0,add:C,change:I,remove:K}};var T,i=new Set,x$=0,k=($)=>{let x=new Set,Q=$;return Q.off=(X)=>{x.add(X)},Q.cleanup=()=>{for(let X of x)X();x.clear()},Q},m=($)=>{if(T&&!$.has(T)){let x=T;$.add(x),T.off(()=>{$.delete(x)})}},F=($)=>{for(let x of $)if(x$)i.add(x);else x()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let x of $)x()}},B$=($)=>{x$++;try{$()}finally{r(),x$--}},h=($,x)=>{let Q=T;T=x;try{$()}finally{T=Q}};var J$="Computed",Q$=($)=>{let x=new Set,Q=H,X,M,C=!0,I=!1,K=!1,z=(J)=>{if(!P(J,Q))Q=J,I=!0;X=void 0,C=!1},j=()=>{I=H!==Q,Q=H,X=void 0},f=(J)=>{let B=N(J);I=!X||B.name!==X.name||B.message!==X.message,Q=H,X=B},S=(J)=>(B)=>{if(K=!1,M=void 0,J(B),I)F(x)},q=k(()=>{if(C=!0,M?.abort(),x.size)F(x);else q.cleanup()});q.off(()=>{M?.abort()});let Y=()=>h(()=>{if(K)throw new A("computed");if(I=!1,b($)){if(M)return Q;M=new AbortController,M.signal.addEventListener("abort",()=>{K=!1,M=void 0,Y()},{once:!0})}let J;K=!0;try{J=M?$(M.signal):$()}catch(B){if(O(B))j();else f(B);K=!1;return}if(J instanceof Promise)J.then(S(z),S(f));else if(J==null||H===J)j();else z(J);K=!1},q);return{[Symbol.toStringTag]:J$,get:()=>{if(m(x),r(),C)Y();if(X)throw X;return Q}}},p=($)=>_($,J$),X$=($)=>U($)&&$.length<2;var Z$=($)=>{let x=b($),Q=!1,X,M=k(()=>h(()=>{if(Q)throw new A("effect");Q=!0,X?.abort(),X=void 0;let C;try{if(x){X=new AbortController;let I=X;$(X.signal).then((K)=>{if(U(K)&&X===I)M.off(K)}).catch((K)=>{if(!O(K))console.error("Async effect error:",K)})}else if(C=$(),U(C))M.off(C)}catch(I){if(!O(I))console.error("Effect callback error:",I)}Q=!1},M));return M(),()=>{X?.abort(),M.cleanup()}};function F$($,x){try{if($.pending)x.nil?.();else if($.errors)x.err?.($.errors);else if($.ok)x.ok($.values)}catch(Q){if(x.err&&(!$.errors||!$.errors.includes(N(Q))))x.err($.errors?[...$.errors,N(Q)]:[N(Q)]);else throw Q}}function Y$($){let x=[],Q=!1,X={};for(let[M,C]of Object.entries($))try{let I=C.get();if(I===H)Q=!0;else X[M]=I}catch(I){x.push(N(I))}if(Q)return{ok:!1,pending:!0};if(x.length>0)return{ok:!1,errors:x};return{ok:!0,values:X}}var M$="State",y=($)=>{let x=new Set,Q=$,X={[Symbol.toStringTag]:M$,get:()=>{return m(x),Q},set:(M)=>{if(M==null)throw new V("state");if(P(Q,M))return;if(Q=M,F(x),H===Q)x.clear()},update:(M)=>{X.set(M(Q))}};return X},E=($)=>_($,M$);var l="Store",G$="store-add",K$="store-change",q$="store-remove",D$="store-sort",a=($)=>{let x=new Set,Q=new EventTarget,X=new Map,M=new Map,C=Array.isArray($),I=y(0),K=()=>{let J={};for(let[B,G]of X)J[B]=G.get();return J},z=(J,B)=>Q.dispatchEvent(new CustomEvent(J,{detail:B})),j=()=>Array.from(X.keys()).map((J)=>Number(J)).filter((J)=>Number.isInteger(J)).sort((J,B)=>J-B),f=(J,B)=>{if(B==null)throw new V(`store for key "${J}"`);if(B===H)return!0;if(w(B)||U(B)||p(B))throw new c(`store for key "${J}"`,g(B));return!0},S=(J,B,G=!1)=>{if(!f(J,B))return!1;let Z=E(B)||d(B)?B:L(B)||Array.isArray(B)?a(B):y(B);X.set(J,Z);let W=Z$(()=>{let R=Z.get();if(R!=null)z(K$,{[J]:R})});if(M.set(J,W),G)I.set(X.size),F(x),z(G$,{[J]:B});return!0},q=(J,B=!1)=>{let G=X.delete(J);if(G){let Z=M.get(J);if(Z)Z();M.delete(J)}if(B)I.set(X.size),F(x),z(q$,{[J]:H});return G},Y=(J,B,G)=>{let Z=$$(J,B);return B$(()=>{if(Object.keys(Z.add).length){for(let W in Z.add){let R=Z.add[W]??H;S(W,R)}if(G)setTimeout(()=>{z(G$,Z.add)},0);else z(G$,Z.add)}if(Object.keys(Z.change).length){for(let W in Z.change){let R=Z.change[W];if(!f(W,R))continue;let o=X.get(W);if(W$(o))o.set(R);else throw new t(W,g(R))}z(K$,Z.change)}if(Object.keys(Z.remove).length){for(let W in Z.remove)q(W);z(q$,Z.remove)}I.set(X.size)}),Z.changed};Y({},$,!0);let D={add:C?(J)=>{let B=X.size,G=String(B);S(G,J,!0)}:(J,B)=>{if(!X.has(J))S(J,B,!0);else throw new v(J,g(B))},get:()=>{return m(x),s(K())},remove:C?(J)=>{let B=s(K()),G=X.size;if(!Array.isArray(B)||J<=-G||J>=G)throw new n(J);let Z=[...B];if(Z.splice(J,1),Y(B,Z))F(x)}:(J)=>{if(X.has(J))q(J,!0)},set:(J)=>{if(Y(K(),J)){if(F(x),H===J)x.clear()}},update:(J)=>{let B=K(),G=J(s(B));if(Y(B,G)){if(F(x),H===G)x.clear()}},sort:(J)=>{let B=Array.from(X.entries()).map(([W,R])=>[W,R.get()]).sort(J?(W,R)=>J(W[1],R[1]):(W,R)=>String(W[1]).localeCompare(String(R[1]))),G=B.map(([W])=>String(W)),Z=new Map;B.forEach(([W],R)=>{let o=String(W),R$=C?String(R):String(W),C$=X.get(o);if(C$)Z.set(R$,C$)}),X.clear(),Z.forEach((W,R)=>X.set(R,W)),F(x),z(D$,G)},addEventListener:Q.addEventListener.bind(Q),removeEventListener:Q.removeEventListener.bind(Q),dispatchEvent:Q.dispatchEvent.bind(Q),size:I};return new Proxy({},{get(J,B){if(B===Symbol.toStringTag)return l;if(B===Symbol.isConcatSpreadable)return C;if(B===Symbol.iterator)return C?function*(){let G=j();for(let Z of G){let W=X.get(String(Z));if(W)yield W}}:function*(){for(let[G,Z]of X)yield[G,Z]};if(w(B))return;if(B in D)return D[B];if(B==="length"&&C)return m(x),I.get();return X.get(B)},has(J,B){let G=String(B);return G&&X.has(G)||Object.keys(D).includes(G)||B===Symbol.toStringTag||B===Symbol.iterator||B===Symbol.isConcatSpreadable||B==="length"&&C},ownKeys(){return C?j().map((J)=>String(J)).concat(["length"]):Array.from(X.keys()).map((J)=>String(J))},getOwnPropertyDescriptor(J,B){let G=(W)=>({enumerable:!1,configurable:!0,writable:!1,value:W});if(B==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:I.get()};if(B===Symbol.isConcatSpreadable)return G(C);if(B===Symbol.toStringTag)return G(l);if(w(B))return;if(Object.keys(D).includes(B))return G(D[B]);let Z=X.get(B);return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},d=($)=>_($,l);var H$=($)=>E($)||p($)||d($),W$=($)=>E($)||d($);function U$($){if(H$($))return $;if(X$($))return Q$($);if(Array.isArray($)||L($))return a($);return y($)}export{g as valueString,U$ as toSignal,N as toError,m as subscribe,Y$ as resolve,h as observe,F as notify,F$ as match,w as isSymbol,e as isString,d as isStore,E as isState,H$ as isSignal,u as isRecordOrArray,L as isRecord,I$ as isNumber,W$ as isMutableSignal,U as isFunction,P as isEqual,X$ as isComputedCallback,p as isComputed,b as isAsyncFunction,O as isAbortError,r as flush,$$ as diff,k as createWatcher,a as createStore,y as createState,Z$ as createEffect,Q$ as createComputed,B$ as batch,H as UNSET,l as TYPE_STORE,M$ as TYPE_STATE,J$ as TYPE_COMPUTED,t as StoreKeyReadonlyError,n as StoreKeyRangeError,v as StoreKeyExistsError,V as NullishSignalValueError,c as InvalidSignalValueError,A as CircularDependencyError};
