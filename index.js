function Y($){return typeof $==="function"}function v($){return Y($)&&$.constructor.name==="AsyncFunction"}function q$($){return Y($)&&$.constructor.name!=="AsyncFunction"}function C($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function O($){return C($,"Object")}function I$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function j$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class n extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class C$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class c extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class a extends TypeError{constructor($,J){super(`[${$}] Signal value ${j$(J)} is invalid`);this.name="InvalidSignalValueError"}}class V$ extends TypeError{constructor($,J){super(`[${$}] Callback ${j$(J)} is invalid`);this.name="InvalidCallbackError"}}class m$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class l extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function F($,J,z){if(J==null)throw new C$($);if(z&&!z(J))throw new a($,J)}function e($,J){if(J==null)throw new c($)}function _($,J,z=Y){if(!z(J))throw new V$($,J)}var h="State",p="Memo",y="Task",g="Sensor",w="List",S="Collection",k="Store",f=0,x$=1,D=2,X$=4,j=null,E=null,N$=[],V=0,A$=!1;function u($,J){return $===J}var S$=()=>!1;function h$($,J){let z=J.sourcesTail;if(z){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===z)break;Q=Q.nextSource}}return!1}function R($,J){let z=J.sourcesTail;if(z?.source===$)return;let Q=null,U=J.flags&X$;if(U){if(Q=z?z.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let B=$.sinksTail;if(B?.sink===J&&(!U||h$(B,J)))return;let M={source:$,sink:J,nextSource:Q,prevSink:B,nextSink:null};if(J.sourcesTail=$.sinksTail=M,z)z.nextSource=M;else J.sources=M;if(B)B.nextSink=M;else $.sinks=M}function p$($){let{source:J,nextSource:z,nextSink:Q,prevSink:U}=$;if(Q)Q.prevSink=U;else J.sinksTail=U;if(U)U.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function Z$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=p$(z);if(J)J.nextSource=null;else $.sources=null}function A($,J=D){let z=$.flags;if("sinks"in $){if((z&(D|x$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)A(Q.sink,x$)}else{if(z&D)return;$.flags=D,N$.push($)}}function H$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)A(z.sink);if(V===0)L()}function i($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function D$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function y$($){let J=j;j=$,$.sourcesTail=null,$.flags=X$;let z=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,z=!0}catch(Q){z=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{j=J,Z$($)}if(z){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&x$)Q.sink.flags|=D}$.flags=f}function g$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=j;j=$,$.sourcesTail=null,$.flags=X$;let Q;try{Q=$.fn($.value,J.signal)}catch(U){$.controller=void 0,$.error=U instanceof Error?U:Error(String(U));return}finally{j=z,Z$($)}Q.then((U)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(U,$.value)){$.value=U,$.error=void 0;for(let B=$.sinks;B;B=B.nextSink)A(B.sink);if(V===0)L()}},(U)=>{if(J.signal.aborted)return;$.controller=void 0;let B=U instanceof Error?U:Error(String(U));if(!$.error||B.name!==$.error.name||B.message!==$.error.message){$.error=B;for(let M=$.sinks;M;M=M.nextSink)A(M.sink);if(V===0)L()}}),$.flags=f}function Y$($){D$($);let J=j,z=E;j=E=$,$.sourcesTail=null,$.flags=X$;try{let Q=$.fn();if(typeof Q==="function")i($,Q)}finally{j=J,E=z,Z$($)}$.flags=f}function b($){if($.flags&x$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)b(J.source);if($.flags&D)break}if($.flags&X$)throw new n("controller"in $?y:("value"in $)?p:"Effect");if($.flags&D)if("controller"in $)g$($);else if("value"in $)y$($);else Y$($);else $.flags=f}function L(){if(A$)return;A$=!0;try{for(let $=0;$<N$.length;$++){let J=N$[$];if(J.flags&D)b(J)}N$.length=0}finally{A$=!1}}function o($){V++;try{$()}finally{if(V--,V===0)L()}}function d($){let J=j;j=null;try{return $()}finally{j=J}}function k$($){let J=E,z={cleanup:null};E=z;try{let Q=$();if(typeof Q==="function")i(z,Q);let U=()=>D$(z);if(J)i(J,U);return U}finally{E=J}}function T($,J){F(h,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard};return{[Symbol.toStringTag]:h,get(){if(j)R(z,j);return z.value},set(Q){F(h,Q,z.guard),H$(z,Q)},update(Q){_(h,Q);let U=Q(z.value);F(h,U,z.guard),H$(z,U)}}}function W$($){return C($,h)}function B$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function t($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new n("isEqual");z.add($),z.add(J);try{let Q=Array.isArray($);if(Q!==Array.isArray(J))return!1;if(Q){let U=$,B=J;if(U.length!==B.length)return!1;for(let M=0;M<U.length;M++)if(!t(U[M],B[M],z))return!1;return!0}if(O($)&&O(J)){let U=Object.keys($),B=Object.keys(J);if(U.length!==B.length)return!1;for(let M of U){if(!(M in J))return!1;if(!t($[M],J[M],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function v$($,J,z,Q,U){let B=new WeakSet,M={},K={},W={},Z=[],H=!1,m=new Map;for(let G=0;G<$.length;G++){let X=z[G];if(X&&$[G])m.set(X,$[G])}let P=new Set;for(let G=0;G<J.length;G++){let X=J[G];if(X===void 0)continue;let q=U?Q(X):z[G]??Q(X);if(P.has(q))throw new l(w,q,X);if(Z.push(q),P.add(q),!m.has(q))M[q]=X,H=!0;else{let N=m.get(q);if(!t(N,X,B))K[q]=X,H=!0}}for(let[G]of m)if(!P.has(G))W[G]=null,H=!0;if(!H&&!B$(z,Z))H=!0;return{add:M,change:K,remove:W,newKeys:Z,changed:H}}function $$($,J){F(w,$,Array.isArray);let z=new Map,Q=[],U=0,B=J?.keyConfig,M=Y(B),K=typeof B==="string"?()=>`${B}${U++}`:M?(X)=>B(X):()=>String(U++),W=()=>Q.map((X)=>z.get(X)?.get()).filter((X)=>X!==void 0),Z={fn:W,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:t,error:void 0},H=(X)=>{let q={};for(let N=0;N<X.length;N++){let x=X[N];if(x===void 0)continue;let I=Q[N];if(!I)I=K(x),Q[N]=I;q[I]=x}return q},m=(X)=>{let q=!1;for(let N in X.add){let x=X.add[N];F(`${w} item for key "${N}"`,x),z.set(N,T(x)),q=!0}if(Object.keys(X.change).length)o(()=>{for(let N in X.change){let x=X.change[N];F(`${w} item for key "${N}"`,x);let I=z.get(N);if(I)I.set(x)}});for(let N in X.remove){z.delete(N);let x=Q.indexOf(N);if(x!==-1)Q.splice(x,1);q=!0}if(q)Z.sources=null,Z.sourcesTail=null;return X.changed},P=H($);for(let X in P){let q=P[X];F(`${w} item for key "${X}"`,q),z.set(X,T(q))}Z.value=$,Z.flags=0;let G={[Symbol.toStringTag]:w,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of Q){let q=z.get(X);if(q)yield q}},get length(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();R(Z,j)}return Q.length},get(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();R(Z,j)}if(Z.sources){if(Z.flags)Z.value=d(W),Z.flags=f}else if(b(Z),Z.error)throw Z.error;return Z.value},set(X){let q=Z.flags&D?W():Z.value,N=v$(q,X,Q,K,M);if(N.changed){if(Q=N.newKeys,m(N),A(Z),Z.flags|=D,V===0)L()}},update(X){G.set(X(G.get()))},at(X){return z.get(Q[X])},keys(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();R(Z,j)}return Q.values()},byKey(X){return z.get(X)},keyAt(X){return Q[X]},indexOfKey(X){return Q.indexOf(X)},add(X){let q=K(X);if(z.has(q))throw new l(w,q,X);if(!Q.includes(q))Q.push(q);if(F(`${w} item for key "${q}"`,X),z.set(q,T(X)),Z.sources=null,Z.sourcesTail=null,A(Z),Z.flags|=D,V===0)L();return q},remove(X){let q=typeof X==="number"?Q[X]:X;if(z.delete(q)){let x=typeof X==="number"?X:Q.indexOf(q);if(x>=0)Q.splice(x,1);if(Z.sources=null,Z.sourcesTail=null,A(Z),Z.flags|=D,V===0)L()}},sort(X){let N=Q.map((x)=>[x,z.get(x)?.get()]).sort(Y(X)?(x,I)=>X(x[1],I[1]):(x,I)=>String(x[1]).localeCompare(String(I[1]))).map(([x])=>x);if(!B$(Q,N)){if(Q=N,A(Z),Z.flags|=D,V===0)L()}},splice(X,q,...N){let x=Q.length,I=X<0?Math.max(0,x+X):Math.min(X,x),_$=Math.max(0,Math.min(q??Math.max(0,x-Math.max(0,I)),x-I)),P$={},Q$={};for(let r=0;r<_$;r++){let s=I+r,R$=Q[s];if(R$){let b$=z.get(R$);if(b$)Q$[R$]=b$.get()}}let F$=Q.slice(0,I);for(let r of N){let s=K(r);if(z.has(s)&&!(s in Q$))throw new l(w,s,r);F$.push(s),P$[s]=r}F$.push(...Q.slice(I+_$));let w$=!!(Object.keys(P$).length||Object.keys(Q$).length);if(w$){if(m({add:P$,change:{},remove:Q$,changed:w$}),Q=F$,A(Z),Z.flags|=D,V===0)L()}return Object.values(Q$)},deriveCollection(X){return G$(G,X)}};return G}function U$($){return C($,w)}function J$($,J){if(_(p,$,q$),J?.value!==void 0)F(p,J.value,J?.guard);let z={fn:$,value:J?.value,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??u,error:void 0};return{[Symbol.toStringTag]:p,get(){if(j)R(z,j);if(b(z),z.error)throw z.error;return e(p,z.value),z.value}}}function L$($){return C($,p)}function z$($,J){if(_(y,$,v),J?.value!==void 0)F(y,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:D,equals:J?.equals??u,controller:void 0,error:void 0};return{[Symbol.toStringTag]:y,get(){if(j)R(z,j);if(b(z),z.error)throw z.error;return e(y,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function f$($){return C($,y)}function G$($,J){if(_(S,J),!u$($))throw TypeError(`[${S}] Invalid collection source: expected a List or Collection`);let z=v(J),Q=new Map,U=(H)=>{let m=z?z$(async(P,G)=>{let X=$.byKey(H)?.get();if(X==null)return P;return J(X,G)}):J$(()=>{let P=$.byKey(H)?.get();if(P==null)return;return J(P)});Q.set(H,m)};function B(){let H=Array.from($.keys()),m=M.value;if(!B$(m,H)){let P=new Set(m),G=new Set(H);for(let X of m)if(!G.has(X))Q.delete(X);for(let X of H)if(!P.has(X))U(X)}return H}let M={fn:B,value:[],flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:B$,error:void 0};function K(){if(M.sources){if(M.flags)M.value=d(B),M.flags=f}else if(b(M),M.error)throw M.error;return M.value}let W=Array.from($.keys());for(let H of W)U(H);M.value=W;let Z={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of M.value){let m=Q.get(H);if(m)yield m}},get length(){if(j)R(M,j);return K().length},keys(){if(j)R(M,j);return K().values()},get(){if(j)R(M,j);let H=K(),m=[];for(let P of H)try{let G=Q.get(P)?.get();if(G!=null)m.push(G)}catch(G){if(!(G instanceof c))throw G}return m},at(H){return Q.get(M.value[H])},byKey(H){return Q.get(H)},keyAt(H){return M.value[H]},indexOfKey(H){return M.value.indexOf(H)},deriveCollection(H){return G$(Z,H)}};return Z}function c$($,J){let z=J?.value??[];if(z.length)F(S,z,Array.isArray);_(S,$);let Q=new Map,U=[],B=0,M=J?.keyConfig,K=typeof M==="string"?()=>`${M}${B++}`:Y(M)?(X)=>M(X):()=>String(B++),W=J?.createItem??((X,q)=>T(q));function Z(){let X=[];for(let q of U)try{let N=Q.get(q)?.get();if(N!=null)X.push(N)}catch(N){if(!(N instanceof c))throw N}return X}let H={fn:Z,value:z,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:()=>!1,error:void 0};function m(X){if(!X.changed)return;let q=!1;o(()=>{for(let N in X.add){let x=X.add[N];if(Q.set(N,W(N,x)),!U.includes(N))U.push(N);q=!0}for(let N in X.change){let x=Q.get(N);if(x&&W$(x))x.set(X.change[N])}for(let N in X.remove){Q.delete(N);let x=U.indexOf(N);if(x!==-1)U.splice(x,1);q=!0}if(q)H.sources=null,H.sourcesTail=null;H.flags=f,A(H),H.flags|=D})}for(let X of z){let q=K(X);Q.set(q,W(q,X)),U.push(q)}H.value=z,H.flags=D;function P(){if(!H.sinks)H.stop=$(m)}let G={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of U){let q=Q.get(X);if(q)yield q}},get length(){if(j)P(),R(H,j);return U.length},keys(){if(j)P(),R(H,j);return U.values()},get(){if(j)P(),R(H,j);if(H.sources){if(H.flags)H.value=d(Z),H.flags=f}else if(b(H),H.error)throw H.error;return H.value},at(X){return Q.get(U[X])},byKey(X){return Q.get(X)},keyAt(X){return U[X]},indexOfKey(X){return U.indexOf(X)},deriveCollection(X){return G$(G,X)}};return G}function T$($){return C($,S)}function u$($){return U$($)||T$($)}function d$($){_("Effect",$);let J={fn:$,flags:D,sources:null,sourcesTail:null,cleanup:null},z=()=>{D$(J),J.fn=void 0,J.flags=f,J.sourcesTail=null,Z$(J)};if(E)i(E,z);return Y$(J),z}function t$($,J){if(!E)throw new m$("match");let{ok:z,err:Q=console.error,nil:U}=J,B,M=!1,K=Array($.length);for(let Z=0;Z<$.length;Z++)try{K[Z]=$[Z].get()}catch(H){if(H instanceof c){M=!0;continue}if(!B)B=[];B.push(H instanceof Error?H:Error(String(H)))}let W;try{if(M)W=U?.();else if(B)W=Q(B);else W=z(K)}catch(Z){Q([Z instanceof Error?Z:Error(String(Z))])}if(typeof W==="function")return W;if(W instanceof Promise){let Z=E,H=new AbortController;i(Z,()=>H.abort()),W.then((m)=>{if(!H.signal.aborted&&typeof m==="function")i(Z,m)}).catch((m)=>{Q([m instanceof Error?m:Error(String(m))])})}}function r$($,J){if(_(g,$,q$),J?.value!==void 0)F(g,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:g,get(){if(j){if(!z.sinks)z.stop=$((Q)=>{F(g,Q,z.guard),H$(z,Q)});R(z,j)}return e(g,z.value),z.value}}}function s$($){return C($,g)}function l$($,J){let z=O($)||Array.isArray($),Q=O(J)||Array.isArray(J);if(!z||!Q){let m=!Object.is($,J);return{changed:m,add:m&&Q?J:{},change:{},remove:m&&z?$:{}}}let U=new WeakSet,B={},M={},K={},W=!1,Z=Object.keys($),H=Object.keys(J);for(let m of H)if(m in $){if(!t($[m],J[m],U))M[m]=J[m],W=!0}else B[m]=J[m],W=!0;for(let m of Z)if(!(m in J))K[m]=void 0,W=!0;return{add:B,change:M,remove:K,changed:W}}function M$($,J){F(k,$,O);let z=new Map,Q=(W,Z)=>{if(F(`${k} for key "${W}"`,Z),Array.isArray(Z))z.set(W,$$(Z));else if(O(Z))z.set(W,M$(Z));else z.set(W,T(Z))},U=()=>{let W={};return z.forEach((Z,H)=>{W[H]=Z.get()}),W},B={fn:U,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:t,error:void 0},M=(W)=>{let Z=!1;for(let H in W.add)Q(H,W.add[H]),Z=!0;if(Object.keys(W.change).length)o(()=>{for(let H in W.change){let m=W.change[H];F(`${k} for key "${H}"`,m);let P=z.get(H);if(P)if(O(m)!==K$(P))Q(H,m),Z=!0;else P.set(m)}});for(let H in W.remove)z.delete(H),Z=!0;if(Z)B.sources=null,B.sourcesTail=null;return W.changed};for(let W of Object.keys($))Q(W,$[W]);let K={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let Z=z.get(W);if(Z)yield[W,Z]}},keys(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();R(B,j)}return z.keys()},byKey(W){return z.get(W)},get(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();R(B,j)}if(B.sources){if(B.flags)B.value=d(U),B.flags=f}else if(b(B),B.error)throw B.error;return B.value},set(W){let Z=B.flags&D?U():B.value,H=l$(Z,W);if(M(H)){if(A(B),B.flags|=D,V===0)L()}},update(W){K.set(W(K.get()))},add(W,Z){if(z.has(W))throw new l(k,W,Z);if(Q(W,Z),B.sources=null,B.sourcesTail=null,A(B),B.flags|=D,V===0)L();return W},remove(W){if(z.delete(W)){if(B.sources=null,B.sourcesTail=null,A(B),B.flags|=D,V===0)L()}}};return new Proxy(K,{get(W,Z){if(Z in W){let H=Reflect.get(W,Z);return Y(H)?H.bind(W):H}if(typeof Z!=="symbol")return W.byKey(Z)},has(W,Z){if(Z in W)return!0;return W.byKey(String(Z))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Z){if(Z in W)return Reflect.getOwnPropertyDescriptor(W,Z);if(typeof Z==="symbol")return;let H=W.byKey(String(Z));return H?{enumerable:!0,configurable:!0,writable:!0,value:H}:void 0}})}function K$($){return C($,k)}function i$($,J){return v($)?z$($,J):J$($,J)}function o$($){if(O$($))return $;if($==null)throw new a("createSignal",$);if(v($))return z$($);if(Y($))return J$($);if(I$($))return $$($);if(O($))return M$($);return T($)}function n$($){if(E$($))return $;if($==null||Y($)||O$($))throw new a("createMutableSignal",$);if(I$($))return $$($);if(O($))return M$($);return T($)}function a$($){return L$($)||f$($)}function O$($){let J=[h,p,y,g,w,S,k],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function E$($){return W$($)||K$($)||U$($)}export{j$ as valueString,d as untrack,t$ as match,f$ as isTask,K$ as isStore,W$ as isState,O$ as isSignal,s$ as isSensor,O as isRecord,C as isObjectOfType,E$ as isMutableSignal,L$ as isMemo,U$ as isList,Y as isFunction,t as isEqual,a$ as isComputed,T$ as isCollection,v as isAsyncFunction,z$ as createTask,M$ as createStore,T as createState,o$ as createSignal,r$ as createSensor,k$ as createScope,n$ as createMutableSignal,J$ as createMemo,$$ as createList,d$ as createEffect,i$ as createComputed,c$ as createCollection,o as batch,c as UnsetSignalValueError,S$ as SKIP_EQUALITY,m$ as RequiredOwnerError,C$ as NullishSignalValueError,a as InvalidSignalValueError,V$ as InvalidCallbackError,n as CircularDependencyError};
