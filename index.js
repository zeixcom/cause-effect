function g($){return typeof $==="function"}function r($){return g($)&&$.constructor.name==="AsyncFunction"}function J$($){return g($)&&$.constructor.name!=="AsyncFunction"}function A($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function L($){return A($,"Object")}function x$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function N$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class z$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class w$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class i extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class X$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${N$(J)} is invalid`);this.name="InvalidSignalValueError"}}class I$ extends TypeError{constructor($,J){super(`[${$}] Callback ${N$(J)} is invalid`);this.name="InvalidCallbackError"}}class m$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class a extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function K($,J,z){if(J==null)throw new w$($);if(z&&!z(J))throw new X$($,J)}function Z$($,J){if(J==null)throw new i($)}function T($,J,z=g){if(!z(J))throw new I$($,J)}var c="State",u="Memo",d="Task",t="Sensor",E="List",k="Collection",l="Store",S=0,D$=1,G=2,B$=4,b=8,N=null,y=null,P$=[],R=0,Y$=!1,s=($,J)=>$===J,f$=($,J)=>!1;function y$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function F($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,H=J.flags&B$;if(H){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let W=$.sinksTail;if(W?.sink===J&&(!H||y$(W,J)))return;let P={source:$,sink:J,nextSource:X,prevSink:W,nextSink:null};if(J.sourcesTail=$.sinksTail=P,z)z.nextSource=P;else J.sources=P;if(W)W.nextSink=P;else $.sinks=P}function g$($){let{source:J,nextSource:z,nextSink:X,prevSink:H}=$;if(X)X.prevSink=H;else J.sinksTail=H;if(H)H.nextSink=X;else J.sinks=X;if(!J.sinks){if(J.stop)J.stop(),J.stop=void 0;if("sources"in J&&J.sources){let W=J;W.sourcesTail=null,j$(W)}}return z}function j$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=g$(z);if(J)J.nextSource=null;else $.sources=null}function x($,J=G){let z=$.flags;if("sinks"in $){if((z&(G|D$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)x(X.sink,D$)}else{if(z&G)return;$.flags=G,P$.push($)}}function q$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)x(z.sink);if(R===0)I()}function e($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function G$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function k$($){let J=N;N=$,$.sourcesTail=null,$.flags=B$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{N=J,j$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&D$)X.sink.flags|=G}$.flags=S}function v$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=N;N=$,$.sourcesTail=null,$.flags=B$;let X;try{X=$.fn($.value,J.signal)}catch(H){$.controller=void 0,$.error=H instanceof Error?H:Error(String(H));return}finally{N=z,j$($)}X.then((H)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(H,$.value)){$.value=H,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)x(W.sink);if(R===0)I()}},(H)=>{if(J.signal.aborted)return;$.controller=void 0;let W=H instanceof Error?H:Error(String(H));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let P=$.sinks;P;P=P.nextSink)x(P.sink);if(R===0)I()}}),$.flags=S}function A$($){G$($);let J=N,z=y;N=y=$,$.sourcesTail=null,$.flags=B$;try{let X=$.fn();if(typeof X==="function")e($,X)}finally{N=J,y=z,j$($)}$.flags=S}function Y($){if($.flags&D$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)Y(J.source);if($.flags&G)break}if($.flags&B$)throw new z$("controller"in $?d:("value"in $)?u:"Effect");if($.flags&G)if("controller"in $)v$($);else if("value"in $)k$($);else A$($);else $.flags=S}function I(){if(Y$)return;Y$=!0;try{for(let $=0;$<P$.length;$++){let J=P$[$];if(J.flags&G)Y(J)}P$.length=0}finally{Y$=!1}}function $$($){R++;try{$()}finally{if(R--,R===0)I()}}function v($){let J=N;N=null;try{return $()}finally{N=J}}function c$($){let J=y,z={cleanup:null};y=z;try{let X=$();if(typeof X==="function")e(z,X);let H=()=>G$(z);if(J)e(J,H);return H}finally{y=J}}function p($,J){K(c,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??s,guard:J?.guard};return{[Symbol.toStringTag]:c,get(){if(N)F(z,N);return z.value},set(X){K(c,X,z.guard),q$(z,X)},update(X){T(c,X);let H=X(z.value);K(c,H,z.guard),q$(z,H)}}}function M$($){return A($,c)}function o($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new z$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let H=$,W=J;if(H.length!==W.length)return!1;for(let P=0;P<H.length;P++)if(!o(H[P],W[P],z))return!1;return!0}if(L($)&&L(J)){let H=Object.keys($),W=Object.keys(J);if(H.length!==W.length)return!1;for(let P of H){if(!(P in J))return!1;if(!o($[P],J[P],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function O$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function b$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function u$($,J,z,X,H){let W=new WeakSet,P={},M={},C={},V=[],Q=!1,j=new Map;for(let q=0;q<$.length;q++){let Z=z[q];if(Z&&$[q])j.set(Z,$[q])}let D=new Set;for(let q=0;q<J.length;q++){let Z=J[q];if(Z===void 0)continue;let B=H?X(Z):z[q]??X(Z);if(D.has(B))throw new a(E,B,Z);if(V.push(B),D.add(B),!j.has(B))P[B]=Z,Q=!0;else if(!o(j.get(B),Z,W))M[B]=Z,Q=!0}for(let[q]of j)if(!D.has(q))C[q]=null,Q=!0;if(!Q&&!O$(z,V))Q=!0;return{add:P,change:M,remove:C,newKeys:V,changed:Q}}function W$($,J){K(E,$,Array.isArray);let z=new Map,X=[],[H,W]=b$(J?.keyConfig),P=()=>X.map((Z)=>z.get(Z)?.get()).filter((Z)=>Z!==void 0),M={fn:P,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:o,error:void 0},C=(Z)=>{let B={};for(let U=0;U<Z.length;U++){let m=Z[U];if(m===void 0)continue;let O=X[U];if(!O)O=H(m),X[U]=O;B[O]=m}return B},V=(Z)=>{let B=!1;for(let U in Z.add){let m=Z.add[U];K(`${E} item for key "${U}"`,m),z.set(U,p(m)),B=!0}if(Object.keys(Z.change).length)$$(()=>{for(let U in Z.change){let m=Z.change[U];K(`${E} item for key "${U}"`,m);let O=z.get(U);if(O)O.set(m)}});for(let U in Z.remove){z.delete(U);let m=X.indexOf(U);if(m!==-1)X.splice(m,1);B=!0}if(B)M.flags|=b;return Z.changed},Q=J?.watched,j=Q?()=>{if(N){if(!M.sinks)M.stop=Q();F(M,N)}}:()=>{if(N)F(M,N)},D=C($);for(let Z in D){let B=D[Z];K(`${E} item for key "${Z}"`,B),z.set(Z,p(B))}M.value=$,M.flags=0;let q={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of X){let B=z.get(Z);if(B)yield B}},get length(){return j(),X.length},get(){if(j(),M.sources){if(M.flags){let Z=M.flags&b;if(M.value=v(P),Z){if(M.flags=G,Y(M),M.error)throw M.error}else M.flags=S}}else if(Y(M),M.error)throw M.error;return M.value},set(Z){let B=M.flags&G?P():M.value,U=u$(B,Z,X,H,W);if(U.changed){X=U.newKeys,V(U),M.flags|=G;for(let m=M.sinks;m;m=m.nextSink)x(m.sink);if(R===0)I()}},update(Z){q.set(Z(q.get()))},at(Z){return z.get(X[Z])},keys(){return j(),X.values()},byKey(Z){return z.get(Z)},keyAt(Z){return X[Z]},indexOfKey(Z){return X.indexOf(Z)},add(Z){let B=H(Z);if(z.has(B))throw new a(E,B,Z);if(!X.includes(B))X.push(B);K(`${E} item for key "${B}"`,Z),z.set(B,p(Z)),M.flags|=G|b;for(let U=M.sinks;U;U=U.nextSink)x(U.sink);if(R===0)I();return B},remove(Z){let B=typeof Z==="number"?X[Z]:Z;if(z.delete(B)){let m=typeof Z==="number"?Z:X.indexOf(B);if(m>=0)X.splice(m,1);M.flags|=G|b;for(let O=M.sinks;O;O=O.nextSink)x(O.sink);if(R===0)I()}},sort(Z){let U=X.map((m)=>[m,z.get(m)?.get()]).sort(g(Z)?(m,O)=>Z(m[1],O[1]):(m,O)=>String(m[1]).localeCompare(String(O[1]))).map(([m])=>m);if(!O$(X,U)){X=U,M.flags|=G;for(let m=M.sinks;m;m=m.nextSink)x(m.sink);if(R===0)I()}},splice(Z,B,...U){let m=X.length,O=Z<0?Math.max(0,m+Z):Math.min(Z,m),w=Math.max(0,Math.min(B??Math.max(0,m-Math.max(0,O)),m-O)),f={},_={};for(let h=0;h<w;h++){let n=O+h,R$=X[n];if(R$){let S$=z.get(R$);if(S$)_[R$]=S$.get()}}let F$=X.slice(0,O);for(let h of U){let n=H(h);if(z.has(n)&&!(n in _))throw new a(E,n,h);F$.push(n),f[n]=h}F$.push(...X.slice(O+w));let E$=!!(Object.keys(f).length||Object.keys(_).length);if(E$){V({add:f,change:{},remove:_,changed:E$}),X=F$,M.flags|=G;for(let h=M.sinks;h;h=h.nextSink)x(h.sink);if(R===0)I()}return Object.values(_)},deriveCollection(Z){return C$(q,Z)}};return q}function U$($){return A($,E)}function H$($,J){if(T(u,$,J$),J?.value!==void 0)K(u,J.value,J?.guard);let z={fn:$,value:J?.value,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??s,error:void 0,stop:void 0},X=J?.watched,H=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{z.flags|=G;for(let W=z.sinks;W;W=W.nextSink)x(W.sink);if(R===0)I()});F(z,N)}}:()=>{if(N)F(z,N)};return{[Symbol.toStringTag]:u,get(){if(H(),Y(z),z.error)throw z.error;return Z$(u,z.value),z.value}}}function _$($){return A($,u)}function Q$($,J){if(T(d,$,r),J?.value!==void 0)K(d,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:G,equals:J?.equals??s,controller:void 0,error:void 0,stop:void 0},X=J?.watched,H=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{z.flags|=G;for(let W=z.sinks;W;W=W.nextSink)x(W.sink);if(R===0)I()});F(z,N)}}:()=>{if(N)F(z,N)};return{[Symbol.toStringTag]:d,get(){if(H(),Y(z),z.error)throw z.error;return Z$(d,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function L$($){return A($,d)}function C$($,J){if(T(k,J),!t$($))throw TypeError(`[${k}] Invalid collection source: expected a List or Collection`);let z=r(J),X=new Map,H=[],W=(q)=>{let Z=z?Q$(async(B,U)=>{let m=$.byKey(q)?.get();if(m==null)return B;return J(m,U)}):H$(()=>{let B=$.byKey(q)?.get();if(B==null)return;return J(B)});X.set(q,Z)};function P(q){if(!O$(H,q)){let Z=new Set(H),B=new Set(q);for(let U of H)if(!B.has(U))X.delete(U);for(let U of q)if(!Z.has(U))W(U);H=q,V.flags|=b}}function M(){P(Array.from($.keys()));let q=[];for(let Z of H)try{let B=X.get(Z)?.get();if(B!=null)q.push(B)}catch(B){if(!(B instanceof i))throw B}return q}let V={fn:M,value:[],flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(q,Z)=>{if(q.length!==Z.length)return!1;for(let B=0;B<q.length;B++)if(q[B]!==Z[B])return!1;return!0},error:void 0};function Q(){if(V.sources){if(V.flags)if(V.value=v(M),V.flags&b){if(V.flags=G,Y(V),V.error)throw V.error}else V.flags=S}else if(V.sinks){if(Y(V),V.error)throw V.error}else V.value=v(M)}let j=Array.from(v(()=>$.keys()));for(let q of j)W(q);H=j;let D={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let q of H){let Z=X.get(q);if(Z)yield Z}},get length(){if(N)F(V,N);return Q(),H.length},keys(){if(N)F(V,N);return Q(),H.values()},get(){if(N)F(V,N);return Q(),V.value},at(q){return X.get(H[q])},byKey(q){return X.get(q)},keyAt(q){return H[q]},indexOfKey(q){return H.indexOf(q)},deriveCollection(q){return C$(D,q)}};return D}function d$($,J){let z=J?.value??[];if(z.length)K(k,z,Array.isArray);T(k,$,J$);let X=new Map,H=[],W=new Map,[P,M]=b$(J?.keyConfig),C=(Z)=>W.get(Z)??(M?P(Z):void 0),V=J?.createItem??p;function Q(){let Z=[];for(let B of H)try{let U=X.get(B)?.get();if(U!=null)Z.push(U)}catch(U){if(!(U instanceof i))throw U}return Z}let j={fn:Q,value:z,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:f$,error:void 0};for(let Z of z){let B=P(Z);X.set(B,V(Z)),W.set(Z,B),H.push(B)}j.value=z,j.flags=G;function D(){if(N){if(!j.sinks)j.stop=$((Z)=>{let{add:B,change:U,remove:m}=Z;if(!B?.length&&!U?.length&&!m?.length)return;let O=!1;$$(()=>{if(B)for(let w of B){let f=P(w);if(X.set(f,V(w)),W.set(w,f),!H.includes(f))H.push(f);O=!0}if(U)for(let w of U){let f=C(w);if(!f)continue;let _=X.get(f);if(_&&M$(_))W.delete(_.get()),_.set(w),W.set(w,f)}if(m)for(let w of m){let f=C(w);if(!f)continue;W.delete(w),X.delete(f);let _=H.indexOf(f);if(_!==-1)H.splice(_,1);O=!0}j.flags=G|(O?b:0);for(let w=j.sinks;w;w=w.nextSink)x(w.sink)})});F(j,N)}}let q={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of H){let B=X.get(Z);if(B)yield B}},get length(){return D(),H.length},keys(){return D(),H.values()},get(){if(D(),j.sources){if(j.flags){let Z=j.flags&b;if(j.value=v(Q),Z){if(j.flags=G,Y(j),j.error)throw j.error}else j.flags=S}}else if(Y(j),j.error)throw j.error;return j.value},at(Z){return X.get(H[Z])},byKey(Z){return X.get(Z)},keyAt(Z){return H[Z]},indexOfKey(Z){return H.indexOf(Z)},deriveCollection(Z){return C$(q,Z)}};return q}function h$($){return A($,k)}function t$($){return U$($)||h$($)}function l$($){T("Effect",$);let J={fn:$,flags:G,sources:null,sourcesTail:null,cleanup:null},z=()=>{G$(J),J.fn=void 0,J.flags=S,J.sourcesTail=null,j$(J)};if(y)e(y,z);return A$(J),z}function r$($,J){if(!y)throw new m$("match");let{ok:z,err:X=console.error,nil:H}=J,W,P=!1,M=Array($.length);for(let V=0;V<$.length;V++)try{M[V]=$[V].get()}catch(Q){if(Q instanceof i){P=!0;continue}if(!W)W=[];W.push(Q instanceof Error?Q:Error(String(Q)))}let C;try{if(P)C=H?.();else if(W)C=X(W);else C=z(M)}catch(V){X([V instanceof Error?V:Error(String(V))])}if(typeof C==="function")return C;if(C instanceof Promise){let V=y,Q=new AbortController;e(V,()=>Q.abort()),C.then((j)=>{if(!Q.signal.aborted&&typeof j==="function")e(V,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function i$($,J){if(T(t,$,J$),J?.value!==void 0)K(t,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??s,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:t,get(){if(N){if(!z.sinks)z.stop=$((X)=>{K(t,X,z.guard),q$(z,X)});F(z,N)}return Z$(t,z.value),z.value}}}function s$($){return A($,t)}function o$($,J){let z=L($)||Array.isArray($),X=L(J)||Array.isArray(J);if(!z||!X){let j=!Object.is($,J);return{changed:j,add:j&&X?J:{},change:{},remove:j&&z?$:{}}}let H=new WeakSet,W={},P={},M={},C=!1,V=Object.keys($),Q=Object.keys(J);for(let j of Q)if(j in $){if(!o($[j],J[j],H))P[j]=J[j],C=!0}else W[j]=J[j],C=!0;for(let j of V)if(!(j in J))M[j]=void 0,C=!0;return{add:W,change:P,remove:M,changed:C}}function V$($,J){K(l,$,L);let z=new Map,X=(Q,j)=>{if(K(`${l} for key "${Q}"`,j),Array.isArray(j))z.set(Q,W$(j));else if(L(j))z.set(Q,V$(j));else z.set(Q,p(j))},H=()=>{let Q={};return z.forEach((j,D)=>{Q[D]=j.get()}),Q},W={fn:H,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:o,error:void 0},P=(Q)=>{let j=!1;for(let D in Q.add)X(D,Q.add[D]),j=!0;if(Object.keys(Q.change).length)$$(()=>{for(let D in Q.change){let q=Q.change[D];K(`${l} for key "${D}"`,q);let Z=z.get(D);if(Z)if(L(q)!==K$(Z))X(D,q),j=!0;else Z.set(q)}});for(let D in Q.remove)z.delete(D),j=!0;if(j)W.flags|=b;return Q.changed},M=J?.watched,C=M?()=>{if(N){if(!W.sinks)W.stop=M();F(W,N)}}:()=>{if(N)F(W,N)};for(let Q of Object.keys($))X(Q,$[Q]);let V={[Symbol.toStringTag]:l,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let Q of Array.from(z.keys())){let j=z.get(Q);if(j)yield[Q,j]}},keys(){return C(),z.keys()},byKey(Q){return z.get(Q)},get(){if(C(),W.sources){if(W.flags){let Q=W.flags&b;if(W.value=v(H),Q){if(W.flags=G,Y(W),W.error)throw W.error}else W.flags=S}}else if(Y(W),W.error)throw W.error;return W.value},set(Q){let j=W.flags&G?H():W.value,D=o$(j,Q);if(P(D)){W.flags|=G;for(let q=W.sinks;q;q=q.nextSink)x(q.sink);if(R===0)I()}},update(Q){V.set(Q(V.get()))},add(Q,j){if(z.has(Q))throw new a(l,Q,j);X(Q,j),W.flags|=G|b;for(let D=W.sinks;D;D=D.nextSink)x(D.sink);if(R===0)I();return Q},remove(Q){if(z.delete(Q)){W.flags|=G|b;for(let D=W.sinks;D;D=D.nextSink)x(D.sink);if(R===0)I()}}};return new Proxy(V,{get(Q,j){if(j in Q)return Reflect.get(Q,j);if(typeof j!=="symbol")return Q.byKey(j)},has(Q,j){if(j in Q)return!0;return Q.byKey(String(j))!==void 0},ownKeys(Q){return Array.from(Q.keys())},getOwnPropertyDescriptor(Q,j){if(j in Q)return Reflect.getOwnPropertyDescriptor(Q,j);if(typeof j==="symbol")return;let D=Q.byKey(String(j));return D?{enumerable:!0,configurable:!0,writable:!0,value:D}:void 0}})}function K$($){return A($,l)}function n$($,J){return r($)?Q$($,J):H$($,J)}function a$($){if(T$($))return $;if($==null)throw new X$("createSignal",$);if(r($))return Q$($);if(g($))return H$($);if(x$($))return W$($);if(L($))return V$($);return p($)}function e$($){if(p$($))return $;if($==null||g($)||T$($))throw new X$("createMutableSignal",$);if(x$($))return W$($);if(L($))return V$($);return p($)}function $J($){return _$($)||L$($)}function T$($){let J=[c,u,d,t,E,k,l],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function p$($){return M$($)||K$($)||U$($)}export{N$ as valueString,v as untrack,r$ as match,L$ as isTask,K$ as isStore,M$ as isState,T$ as isSignal,s$ as isSensor,L as isRecord,A as isObjectOfType,p$ as isMutableSignal,_$ as isMemo,U$ as isList,g as isFunction,o as isEqual,$J as isComputed,h$ as isCollection,r as isAsyncFunction,Q$ as createTask,V$ as createStore,p as createState,a$ as createSignal,i$ as createSensor,c$ as createScope,e$ as createMutableSignal,H$ as createMemo,W$ as createList,l$ as createEffect,n$ as createComputed,d$ as createCollection,$$ as batch,i as UnsetSignalValueError,f$ as SKIP_EQUALITY,m$ as RequiredOwnerError,w$ as NullishSignalValueError,X$ as InvalidSignalValueError,I$ as InvalidCallbackError,z$ as CircularDependencyError};
