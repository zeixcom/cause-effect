var F=($)=>typeof $==="function",w=($)=>F($)&&$.constructor.name==="AsyncFunction",o=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,c=($)=>$ instanceof Error,D=($)=>$ instanceof DOMException&&$.name==="AbortError",h=($)=>$ instanceof Promise,q=($)=>c($)?$:Error(String($));class j extends Error{constructor($){super(`Circular dependency in ${$} detected`);return this}}var A,U=new Set,E=0,g=new Map,b,i=()=>{b=void 0;let $=Array.from(g.values());g.clear();for(let x of $)x()},t=()=>{if(b)cancelAnimationFrame(b);b=requestAnimationFrame(i)};queueMicrotask(i);var Y=($)=>{if(A&&!$.has(A)){let x=A;$.add(x),A.cleanups.add(()=>{$.delete(x)})}},y=($)=>{for(let x of $)if(E)U.add(x);else x()},P=()=>{while(U.size){let $=Array.from(U);U.clear();for(let x of $)x()}},r=($)=>{E++;try{$()}finally{P(),E--}},O=($,x)=>{let z=A;A=x;try{$()}finally{A=z}},a=($,x)=>new Promise((z,B)=>{g.set(x,()=>{try{z($())}catch(H){B(H)}}),t()});function R($){let{signals:x,ok:z,err:B=console.error,nil:H=()=>{}}=F($)?{signals:[],ok:$}:$,W=!1,K=()=>O(()=>{if(W)throw new j("effect");W=!0;let Q=void 0;try{let X=[],J=!1,_=x.map((V)=>{try{let Z=V.get();if(Z===L)J=!0;return Z}catch(Z){if(D(Z))throw Z;return X.push(q(Z)),L}});try{Q=J?H():X.length?B(...X):z(..._)}catch(V){if(D(V))throw V;let Z=q(V);Q=B(Z)}}catch(X){B(q(X))}if(F(Q))K.cleanups.add(Q);W=!1},K);return K.cleanups=new Set,K(),()=>{K.cleanups.forEach((Q)=>Q()),K.cleanups.clear()}}var k=($)=>{let x=new Set,z=L,B,H=!0,W=!1,K=()=>{if(H=!0,x.size)y(x);else K.cleanups.forEach((J)=>J()),K.cleanups.clear()};K.cleanups=new Set;let Q=()=>O(()=>{if(W)throw new j("memo");W=!0;try{let J=$();if(J==null||L===J)z=L,B=void 0;else z=J,H=!1,B=void 0}catch(J){z=L,B=J instanceof Error?J:new Error(String(J))}finally{W=!1}},K),X={[Symbol.toStringTag]:N,get:()=>{if(Y(x),P(),H)Q();if(B)throw B;return z},map:(J)=>M(X,J),tap:(J)=>R({signals:[X],...typeof J==="function"?{ok:J}:J})};return X};var S=($)=>{let x=new Set,z=L,B,H=!0,W=!1,K=!1,Q,X=(G)=>{if(!Object.is(G,z))z=G,H=!1,B=void 0,W=!0},J=()=>{W=L!==z,z=L,B=void 0},_=(G)=>{let I=q(G);W=!(B&&I.name===B.name&&I.message===B.message),z=L,B=I},V=(G)=>{if(K=!1,Q=void 0,X(G),W)y(x)},Z=(G)=>{if(K=!1,Q=void 0,_(G),W)y(x)},u=()=>{K=!1,Q=void 0,v()},C=()=>{if(H=!0,Q?.abort("Aborted because source signal changed"),x.size)y(x);else C.cleanups.forEach((G)=>G()),C.cleanups.clear()};C.cleanups=new Set;let v=()=>O(()=>{if(K)throw new j("task");W=!1,Q=new AbortController,Q.signal.addEventListener("abort",u,{once:!0});let G;K=!0;try{G=$(Q.signal)}catch(I){if(D(I))J();else _(I);K=!1;return}if(h(G))G.then(V,Z);else if(G==null||L===G)J();else X(G);K=!1},C),T={[Symbol.toStringTag]:N,get:()=>{if(Y(x),P(),H)v();if(B)throw B;return z},map:(G)=>M(T,G),tap:(G)=>R({signals:[T],...typeof G==="function"?{ok:G}:G})};return T};var N="Computed",d=($)=>w($)?S($):k($),M=($,x)=>w(x)?S(()=>x($.get())):k(()=>x($.get())),p=($)=>{if(!$||typeof $!=="object")return!1;return $[Symbol.toStringTag]===N};var s="State",f=($)=>{let x=new Set,z=$,B={[Symbol.toStringTag]:s,get:()=>{return Y(x),z},set:(H)=>{if(Object.is(z,H))return;if(z=H,y(x),L===z)x.clear()},update:(H)=>{B.set(H(z))},map:(H)=>M(B,H),tap:(H)=>R({signals:[B],...typeof H==="function"?{ok:H}:H})};return B},m=($)=>o($,s);var L=Symbol(),n=($)=>m($)||p($),l=($)=>F($)&&$.length<2,e=($)=>n($)?$:l($)?d($):f($);export{O as watch,e as toSignal,S as task,f as state,k as memo,m as isState,n as isSignal,l as isComputedCallback,p as isComputed,a as enqueue,R as effect,d as computed,r as batch,L as UNSET,j as CircularDependencyError};
