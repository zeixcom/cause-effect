function s($){return typeof $==="string"}function q$($){return typeof $==="number"}function j$($){return typeof $==="symbol"}function V($){return typeof $==="function"}function v($){return V($)&&$.constructor.name==="AsyncFunction"}function m$($){return V($)&&$.constructor.name!=="AsyncFunction"}function C$($){return $!=null&&typeof $==="object"}function I($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function w($){return I($,"Object")}function N$($){return w($)||Array.isArray($)}function V$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function g$($){return $ instanceof DOMException&&$.name==="AbortError"}function x$($){return s($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class l extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class Y$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class $$ extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class o extends TypeError{constructor($,J){super(`[${$}] Signal value ${x$(J)} is invalid`);this.name="InvalidSignalValueError"}}class f$ extends TypeError{constructor($,J){super(`[${$}] Callback ${x$(J)} is invalid`);this.name="InvalidCallbackError"}}class D$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class J$ extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function P($,J,z){if(J==null)throw new Y$($);if(z&&!z(J))throw new o($,J)}function i($,J){if(J==null)throw new $$($)}function L($,J,z=V){if(!z(J))throw new f$($,J)}var S="State",h="Memo",p="Task",y="Sensor",T="List",E="Collection",g="Store",f=0,K$=1,G=2,z$=4,j=null,b=null,G$=[],A=0,L$=!1;function c($,J){return $===J}var k$=()=>!1;function v$($,J){let z=J.sourcesTail;if(z){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===z)break;Q=Q.nextSource}}return!1}function F($,J){let z=J.sourcesTail;if(z?.source===$)return;let Q=null,M=J.flags&z$;if(M){if(Q=z?z.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let H=$.sinksTail;if(H?.sink===J&&(!M||v$(H,J)))return;let q={source:$,sink:J,nextSource:Q,prevSink:H,nextSink:null};if(J.sourcesTail=$.sinksTail=q,z)z.nextSource=q;else J.sources=q;if(H)H.nextSink=q;else $.sinks=q}function c$($){let{source:J,nextSource:z,nextSink:Q,prevSink:M}=$;if(Q)Q.prevSink=M;else J.sinksTail=M;if(M)M.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function Q$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=c$(z);if(J)J.nextSource=null;else $.sources=null}function C($,J=G){let z=$.flags;if("sinks"in $){if((z&(G|K$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)C(Q.sink,K$)}else{if(z&G)return;$.flags=G,G$.push($)}}function X$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)C(z.sink);if(A===0)Y()}function d($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function P$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function u$($){let J=j;j=$,$.sourcesTail=null,$.flags=z$;let z=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,z=!0}catch(Q){z=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{j=J,Q$($)}if(z){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&K$)Q.sink.flags|=G}$.flags=f}function d$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=j;j=$,$.sourcesTail=null,$.flags=z$;let Q;try{Q=$.fn($.value,J.signal)}catch(M){$.controller=void 0,$.error=M instanceof Error?M:Error(String(M));return}finally{j=z,Q$($)}Q.then((M)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(M,$.value)){$.value=M,$.error=void 0;for(let H=$.sinks;H;H=H.nextSink)C(H.sink);if(A===0)Y()}},(M)=>{if(J.signal.aborted)return;$.controller=void 0;let H=M instanceof Error?M:Error(String(M));if(!$.error||H.name!==$.error.name||H.message!==$.error.message){$.error=H;for(let q=$.sinks;q;q=q.nextSink)C(q.sink);if(A===0)Y()}}),$.flags=f}function O$($){P$($);let J=j,z=b;j=b=$,$.sourcesTail=null,$.flags=z$;try{let Q=$.fn();if(typeof Q==="function")d($,Q)}finally{j=J,b=z,Q$($)}$.flags=f}function O($){if($.flags&K$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)O(J.source);if($.flags&G)break}if($.flags&z$)throw new l("controller"in $?p:("value"in $)?h:"Effect");if($.flags&G)if("controller"in $)d$($);else if("value"in $)u$($);else O$($);else $.flags=f}function Y(){if(L$)return;L$=!0;try{for(let $=0;$<G$.length;$++){let J=G$[$];if(J.flags&G)O(J)}G$.length=0}finally{L$=!1}}function r($){A++;try{$()}finally{if(A--,A===0)Y()}}function u($){let J=j;j=null;try{return $()}finally{j=J}}function r$($){let J=b,z={cleanup:null};b=z;try{let Q=$();if(typeof Q==="function")d(z,Q);let M=()=>P$(z);if(J)d(J,M);return M}finally{b=J}}function _($,J){P(S,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??c,guard:J?.guard};return{[Symbol.toStringTag]:S,get(){if(j)F(z,j);return z.value},set(Q){P(S,Q,z.guard),X$(z,Q)},update(Q){L(S,Q);let M=Q(z.value);P(S,M,z.guard),X$(z,M)}}}function Z$($){return I($,S)}function k($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!C$($)||!C$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new l("isEqual");z.add($),z.add(J);try{let Q=Array.isArray($);if(Q!==Array.isArray(J))return!1;if(Q){let M=$,H=J;if(M.length!==H.length)return!1;for(let q=0;q<M.length;q++)if(!k(M[q],H[q],z))return!1;return!0}if(w($)&&w(J)){let M=Object.keys($),H=Object.keys(J);if(M.length!==H.length)return!1;for(let q of M){if(!(q in J))return!1;if(!k($[q],J[q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function t$($,J,z,Q){let M=new WeakSet,H={},q={},R={},X=[],U=!1,Z=new Map;for(let D=0;D<$.length;D++){let W=z[D];if(W&&$[D])Z.set(W,$[D])}let m=new Set;for(let D=0;D<J.length;D++){let W=J[D];if(W===void 0)continue;let B=z[D];if(!B)B=Q(W);if(X.push(B),m.add(B),!Z.has(B))H[B]=W,U=!0;else{let N=Z.get(B);if(!k(N,W,M))q[B]=W,U=!0}}for(let[D]of Z)if(!m.has(D))R[D]=null,U=!0;return{add:H,change:q,remove:R,newKeys:X,changed:U}}function n($,J){P(T,$,Array.isArray);let z=new Map,Q=[],M=0,H=J?.keyConfig,q=s(H)?()=>`${H}${M++}`:V(H)?(W)=>H(W):()=>String(M++),R=()=>Q.map((W)=>z.get(W)?.get()).filter((W)=>W!==void 0),X={fn:R,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:k,error:void 0},U=(W)=>{let B={};for(let N=0;N<W.length;N++){let x=W[N];if(x===void 0)continue;let K=Q[N];if(!K)K=q(x),Q[N]=K;B[K]=x}return B},Z=(W)=>{let B=!1;for(let N in W.add){let x=W.add[N];P(`${T} item for key "${N}"`,x),z.set(N,_(x)),B=!0}if(Object.keys(W.change).length)r(()=>{for(let N in W.change){let x=W.change[N];P(`${T} item for key "${N}"`,x);let K=z.get(N);if(K)K.set(x)}});for(let N in W.remove){z.delete(N);let x=Q.indexOf(N);if(x!==-1)Q.splice(x,1);B=!0}if(B)X.sources=null,X.sourcesTail=null;return W.changed},m=U($);for(let W in m){let B=m[W];P(`${T} item for key "${W}"`,B),z.set(W,_(B))}X.value=$,X.flags=0;let D={[Symbol.toStringTag]:T,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let W of Q){let B=z.get(W);if(B)yield B}},get length(){if(j){if(!X.sinks&&J?.watched)X.stop=J.watched();F(X,j)}return Q.length},get(){if(j){if(!X.sinks&&J?.watched)X.stop=J.watched();F(X,j)}if(X.sources){if(X.flags)X.value=u(R),X.flags=f}else if(O(X),X.error)throw X.error;return X.value},set(W){let B=X.flags&G?R():X.value,N=t$(B,W,Q,q);if(N.changed){if(Q=N.newKeys,Z(N),C(X),X.flags|=G,A===0)Y()}},update(W){D.set(W(D.get()))},at(W){return z.get(Q[W])},keys(){if(j){if(!X.sinks&&J?.watched)X.stop=J.watched();F(X,j)}return Q.values()},byKey(W){return z.get(W)},keyAt(W){return Q[W]},indexOfKey(W){return Q.indexOf(W)},add(W){let B=q(W);if(z.has(B))throw new J$(T,B,W);if(!Q.includes(B))Q.push(B);if(P(`${T} item for key "${B}"`,W),z.set(B,_(W)),X.sources=null,X.sourcesTail=null,C(X),X.flags|=G,A===0)Y();return B},remove(W){let B=q$(W)?Q[W]:W;if(z.delete(B)){let x=q$(W)?W:Q.indexOf(B);if(x>=0)Q.splice(x,1);if(X.sources=null,X.sourcesTail=null,C(X),X.flags|=G,A===0)Y()}},sort(W){let N=Q.map((x)=>[x,z.get(x)?.get()]).sort(V(W)?(x,K)=>W(x[1],K[1]):(x,K)=>String(x[1]).localeCompare(String(K[1]))).map(([x])=>x);if(!k(Q,N)){if(Q=N,C(X),X.flags|=G,A===0)Y()}},splice(W,B,...N){let x=Q.length,K=W<0?Math.max(0,x+W):Math.min(W,x),T$=Math.max(0,Math.min(B??Math.max(0,x-Math.max(0,K)),x-K)),F$={},U$={};for(let t=0;t<T$;t++){let M$=K+t,A$=Q[M$];if(A$){let S$=z.get(A$);if(S$)U$[A$]=S$.get()}}let I$=Q.slice(0,K);for(let t of N){let M$=q(t);I$.push(M$),F$[M$]=t}I$.push(...Q.slice(K+T$));let E$=!!(Object.keys(F$).length||Object.keys(U$).length);if(E$){if(Z({add:F$,change:{},remove:U$,changed:E$}),Q=I$,C(X),X.flags|=G,A===0)Y()}return Object.values(U$)},deriveCollection(W){return H$(D,W)}};return D}function B$($){return I($,T)}function a($,J){if(L(h,$,m$),J?.value!==void 0)P(h,J.value,J?.guard);let z={fn:$,value:J?.value,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??c,error:void 0};return{[Symbol.toStringTag]:h,get(){if(j)F(z,j);if(O(z),z.error)throw z.error;return i(h,z.value),z.value}}}function w$($){return I($,h)}function e($,J){if(L(p,$,v),J?.value!==void 0)P(p,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:G,equals:J?.equals??c,controller:void 0,error:void 0};return{[Symbol.toStringTag]:p,get(){if(j)F(z,j);if(O(z),z.error)throw z.error;return i(p,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function _$($){return I($,p)}function h$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function H$($,J){if(L(E,J),!l$($))throw TypeError(`[${E}] Invalid collection source: expected a List or Collection`);let z=v(J),Q=new Map,M=(Z)=>{let m=z?e(async(D,W)=>{let B=$.byKey(Z)?.get();if(B==null)return D;return J(B,W)}):a(()=>{let D=$.byKey(Z)?.get();if(D==null)return;return J(D)});Q.set(Z,m)};function H(){let Z=Array.from($.keys()),m=q.value;if(!h$(m,Z)){let D=new Set(m),W=new Set(Z);for(let B of m)if(!W.has(B))Q.delete(B);for(let B of Z)if(!D.has(B))M(B)}return Z}let q={fn:H,value:[],flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:h$,error:void 0};function R(){if(q.sources){if(q.flags)q.value=u(H),q.flags=f}else if(O(q),q.error)throw q.error;return q.value}let X=Array.from($.keys());for(let Z of X)M(Z);q.value=X;let U={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of q.value){let m=Q.get(Z);if(m)yield m}},get length(){if(j)F(q,j);return R().length},keys(){if(j)F(q,j);return R().values()},get(){if(j)F(q,j);return R().map((m)=>{try{return Q.get(m)?.get()}catch{return}}).filter((m)=>m!=null)},at(Z){return Q.get(q.value[Z])},byKey(Z){return Q.get(Z)},keyAt(Z){return q.value[Z]},indexOfKey(Z){return q.value.indexOf(Z)},deriveCollection(Z){return H$(U,Z)}};return U}function s$($,J,z){P(E,$,Array.isArray),L(E,J);let Q=new Map,M=[],H=0,q=z?.keyConfig,R=s(q)?()=>`${q}${H++}`:V(q)?(B)=>q(B):()=>String(H++),X=z?.createItem??((B,N)=>_(N));function U(){return M.map((B)=>{try{return Q.get(B)?.get()}catch{return}}).filter((B)=>B!=null)}let Z={fn:U,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:()=>!1,error:void 0};function m(B){if(!B.changed)return;let N=!1;r(()=>{for(let x in B.add){let K=B.add[x];if(Q.set(x,X(x,K)),!M.includes(x))M.push(x);N=!0}for(let x in B.change){let K=Q.get(x);if(K&&Z$(K))K.set(B.change[x])}for(let x in B.remove){Q.delete(x);let K=M.indexOf(x);if(K!==-1)M.splice(K,1);N=!0}if(N)Z.sources=null,Z.sourcesTail=null;Z.flags=f,C(Z),Z.flags|=G})}for(let B of $){let N=R(B);Q.set(N,X(N,B)),M.push(N)}Z.value=$,Z.flags=G;function D(){if(!Z.sinks)Z.stop=J(m)}let W={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of M){let N=Q.get(B);if(N)yield N}},get length(){if(j)D(),F(Z,j);return M.length},keys(){if(j)D(),F(Z,j);return M.values()},get(){if(j)D(),F(Z,j);if(Z.sources){if(Z.flags)Z.value=u(U),Z.flags=f}else if(O(Z),Z.error)throw Z.error;return Z.value},at(B){return Q.get(M[B])},byKey(B){return Q.get(B)},keyAt(B){return M[B]},indexOfKey(B){return M.indexOf(B)},deriveCollection(B){return H$(W,B)}};return W}function p$($){return I($,E)}function l$($){return B$($)||p$($)}function o$($){L("Effect",$);let J={fn:$,flags:G,sources:null,sourcesTail:null,cleanup:null},z=()=>{P$(J),J.fn=void 0,J.flags=f,J.sourcesTail=null,Q$(J)};if(b)d(b,z);return O$(J),z}function i$($,J){if(!b)throw new D$("match");let{ok:z,err:Q=console.error,nil:M}=J,H,q=!1,R=Array($.length);for(let U=0;U<$.length;U++)try{R[U]=$[U].get()}catch(Z){if(Z instanceof $$){q=!0;continue}if(!H)H=[];H.push(Z instanceof Error?Z:Error(String(Z)))}let X;try{if(q)X=M?.();else if(H)X=Q(H);else X=z(R)}catch(U){Q([U instanceof Error?U:Error(String(U))])}if(typeof X==="function")return X;if(X instanceof Promise){let U=b,Z=new AbortController;d(U,()=>Z.abort()),X.then((m)=>{if(!Z.signal.aborted&&typeof m==="function")d(U,m)}).catch((m)=>{Q([m instanceof Error?m:Error(String(m))])})}}function n$($,J){if(L(y,$,m$),J?.value!==void 0)P(y,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??c,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:y,get(){if(j){if(!z.sinks)z.stop=$((Q)=>{P(y,Q,z.guard),X$(z,Q)});F(z,j)}return i(y,z.value),z.value}}}function a$($){return I($,y)}function e$($,J){let z=N$($),Q=N$(J);if(!z||!Q){let m=!Object.is($,J);return{changed:m,add:m&&Q?J:{},change:{},remove:m&&z?$:{}}}let M=new WeakSet,H={},q={},R={},X=!1,U=Object.keys($),Z=Object.keys(J);for(let m of Z)if(m in $){if(!k($[m],J[m],M))q[m]=J[m],X=!0}else H[m]=J[m],X=!0;for(let m of U)if(!(m in J))R[m]=void 0,X=!0;return{add:H,change:q,remove:R,changed:X}}function W$($,J){P(g,$,w);let z=new Map,Q=(X,U)=>{if(P(`${g} for key "${X}"`,U),Array.isArray(U))z.set(X,n(U));else if(w(U))z.set(X,W$(U));else z.set(X,_(U))},M=()=>{let X={};return z.forEach((U,Z)=>{X[Z]=U.get()}),X},H={fn:M,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:k,error:void 0},q=(X)=>{let U=!1;for(let Z in X.add)Q(Z,X.add[Z]),U=!0;if(Object.keys(X.change).length)r(()=>{for(let Z in X.change){let m=X.change[Z];P(`${g} for key "${Z}"`,m);let D=z.get(Z);if(D)if(w(m)!==R$(D))Q(Z,m),U=!0;else D.set(m)}});for(let Z in X.remove)z.delete(Z),U=!0;if(U)H.sources=null,H.sourcesTail=null;return X.changed};for(let X of Object.keys($))Q(X,$[X]);let R={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let X of Array.from(z.keys())){let U=z.get(X);if(U)yield[X,U]}},keys(){if(j){if(!H.sinks&&J?.watched)H.stop=J.watched();F(H,j)}return z.keys()},byKey(X){return z.get(X)},get(){if(j){if(!H.sinks&&J?.watched)H.stop=J.watched();F(H,j)}if(H.sources){if(H.flags)H.value=u(M),H.flags=f}else if(O(H),H.error)throw H.error;return H.value},set(X){let U=H.flags&G?M():H.value,Z=e$(U,X);if(q(Z)){if(C(H),H.flags|=G,A===0)Y()}},update(X){R.set(X(R.get()))},add(X,U){if(z.has(X))throw new J$(g,X,U);if(Q(X,U),H.sources=null,H.sourcesTail=null,C(H),H.flags|=G,A===0)Y();return X},remove(X){if(z.delete(X)){if(H.sources=null,H.sourcesTail=null,C(H),H.flags|=G,A===0)Y()}}};return new Proxy(R,{get(X,U){if(U in X){let Z=Reflect.get(X,U);return V(Z)?Z.bind(X):Z}if(!j$(U))return X.byKey(U)},has(X,U){if(U in X)return!0;return X.byKey(String(U))!==void 0},ownKeys(X){return Array.from(X.keys())},getOwnPropertyDescriptor(X,U){if(U in X)return Reflect.getOwnPropertyDescriptor(X,U);if(j$(U))return;let Z=X.byKey(String(U));return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})}function R$($){return I($,g)}function $J($,J){return v($)?e($,J):a($,J)}function JJ($){if(b$($))return $;if($==null)throw new o("createSignal",$);if(v($))return e($);if(V($))return a($);if(V$($))return n($);if(w($))return W$($);return _($)}function zJ($){if(y$($))return $;if($==null||V($)||b$($))throw new o("createMutableSignal",$);if(V$($))return n($);if(w($))return W$($);return _($)}function QJ($){return w$($)||_$($)}function b$($){let J=[S,h,p,y,T,E,g],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function y$($){return Z$($)||R$($)||B$($)}export{x$ as valueString,u as untrack,i$ as match,_$ as isTask,j$ as isSymbol,s as isString,R$ as isStore,Z$ as isState,b$ as isSignal,a$ as isSensor,N$ as isRecordOrArray,w as isRecord,I as isObjectOfType,q$ as isNumber,y$ as isMutableSignal,w$ as isMemo,B$ as isList,V as isFunction,k as isEqual,QJ as isComputed,p$ as isCollection,v as isAsyncFunction,g$ as isAbortError,e as createTask,W$ as createStore,_ as createState,s$ as createSourceCollection,JJ as createSignal,n$ as createSensor,r$ as createScope,zJ as createMutableSignal,a as createMemo,n as createList,o$ as createEffect,$J as createComputed,H$ as createCollection,r as batch,$$ as UnsetSignalValueError,k$ as SKIP_EQUALITY,D$ as RequiredOwnerError,Y$ as NullishSignalValueError,o as InvalidSignalValueError,f$ as InvalidCallbackError,l as CircularDependencyError};
