var j,C=new Set,O=0,k=new Map,D,v=()=>{D=void 0;let $=Array.from(k.values());k.clear();for(let H of $)H()},o=()=>{if(D)cancelAnimationFrame(D);D=requestAnimationFrame(v)};queueMicrotask(v);var M=($)=>{let H=new Set,W=$;return W.off=(z)=>{H.add(z)},W.cleanup=()=>{for(let z of H)z();H.clear()},W},B=($)=>{if(j&&!$.has(j)){let H=j;$.add(H),j.off(()=>{$.delete(H)})}},L=($)=>{for(let H of $)if(O)C.add(H);else H()},I=()=>{while(C.size){let $=Array.from(C);C.clear();for(let H of $)H()}},c=($)=>{O++;try{$()}finally{I(),O--}},q=($,H)=>{let W=j;j=H;try{$()}finally{j=W}},n=($,H)=>new Promise((W,z)=>{k.set(H||Symbol(),()=>{try{W($())}catch(G){z(G)}}),o()});var F=($)=>typeof $==="function",P=($)=>F($)&&$.constructor.name==="AsyncFunction",U=($,H)=>Object.prototype.toString.call($)===`[object ${H}]`,Y=($)=>$ instanceof DOMException&&$.name==="AbortError",V=($)=>$ instanceof Error?$:Error(String($));class y extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var R="State",A=($)=>{let H=new Set,W=$,z={[Symbol.toStringTag]:R,get:()=>{return B(H),W},set:(G)=>{if(Object.is(W,G))return;if(W=G,L(H),Q===W)H.clear()},update:(G)=>{z.set(G(W))}};return z},m=($)=>U($,R);var Q=Symbol(),i=($)=>m($)||T($),s=($)=>i($)?$:f($)?S($):A($);var _="Computed",g="Aborted because source signal changed",b="Aborted because cleanup was called",S=($)=>{let H=new Set,W=Q,z,G,X=!0,J=!1,x=!1,w=(K)=>{if(!Object.is(K,W))W=K,J=!0;z=void 0,X=!1},E=()=>{J=Q!==W,W=Q,z=void 0},p=(K)=>{let Z=V(K);J=!z||Z.name!==z.name||Z.message!==z.message,W=Q,z=Z},h=(K)=>(Z)=>{if(x=!1,G=void 0,K(Z),J)L(H)},N=M(()=>{if(X=!0,G?.abort(g),H.size)L(H);else N.cleanup()});N.off(()=>{G?.abort(b)});let d=()=>q(()=>{if(x)throw new y("computed");if(J=!1,P($)){if(G)return W;G=new AbortController,G.signal.addEventListener("abort",()=>{x=!1,G=void 0,d()},{once:!0})}let K;x=!0;try{K=G?$(G.signal):$()}catch(Z){if(Y(Z))E();else p(Z);x=!1;return}if(K instanceof Promise)K.then(h(w),h(p));else if(K==null||Q===K)E();else w(K);x=!1},N);return{[Symbol.toStringTag]:_,get:()=>{if(B(H),I(),X)d();if(z)throw z;return W}}},T=($)=>U($,_),f=($)=>F($)&&$.length<2;function u($){let H=P($),W=!1,z,G=M(()=>q(()=>{if(W)throw new y("effect");W=!0,z?.abort(g),z=void 0;let X;try{if(H)z=new AbortController,$(z.signal).then((J)=>{if(F(J))G.off(J)}).catch((J)=>{if(!Y(J))console.error("Async effect error:",J)});else if(X=$(),F(X))G.off(X)}catch(J){if(!Y(J))console.error("Effect callback error:",J)}W=!1},G));return G(),()=>{z?.abort(b),G.cleanup()}}function t($,H){try{if($.pending)H.nil?.();else if($.errors)H.err?.($.errors);else H.ok?.($.values)}catch(W){if(H.err&&(!$.errors||!$.errors.includes(V(W)))){let z=$.errors?[...$.errors,V(W)]:[V(W)];H.err(z)}else throw W}}function l($){let H=[],W=!1,z={};for(let[G,X]of Object.entries($))try{let J=X.get();if(J===Q)W=!0;else z[G]=J}catch(J){H.push(V(J))}if(W)return{ok:!1,pending:!0};if(H.length>0)return{ok:!1,errors:H};return{ok:!0,values:z}}export{M as watch,s as toSignal,B as subscribe,A as state,l as resolve,q as observe,L as notify,t as match,m as isState,i as isSignal,F as isFunction,f as isComputedCallback,T as isComputed,I as flush,n as enqueue,u as effect,S as computed,c as batch,Q as UNSET,R as TYPE_STATE,_ as TYPE_COMPUTED,y as CircularDependencyError};
