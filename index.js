var N=Symbol(),a=($)=>typeof $==="string",R$=($)=>typeof $==="number",w=($)=>typeof $==="symbol",T=($)=>typeof $==="function",o=($)=>T($)&&$.constructor.name==="AsyncFunction",S=($,M)=>Object.prototype.toString.call($)===`[object ${M}]`,E=($)=>S($,"Object"),e=($)=>E($)||Array.isArray($);var v=($)=>$ instanceof DOMException&&$.name==="AbortError",m=($)=>$ instanceof Error?$:Error(String($)),y=($)=>a($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);class b extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class h extends Error{constructor($,M,z){super(`Could not add ${$} key "${M}" ${z&&`with value ${y(z)}`}because it already exists`);this.name="StoreKeyExistsError"}}class c extends Error{constructor($,M,z){super(`Forbidden method call ${$} in ${M} because ${z}`);this.name="ForbiddenMethodCallError"}}class g extends TypeError{constructor($,M){super(`Invalid ${$} callback ${y(M)}`);this.name="InvalidCallbackError"}}class $$ extends TypeError{constructor($,M){super(`Invalid signal value ${y(M)} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class B$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class J$ extends Error{constructor($,M){super(`Could not set store key "${$}" to ${y(M)} because it is read-only`);this.name="StoreKeyReadonlyError"}}var p=($,M,z)=>{if(Object.is($,M))return!0;if(typeof $!==typeof M)return!1;if(typeof $!=="object"||$===null||M===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(M))throw new b("isEqual");z.add($),z.add(M);try{if(Array.isArray($)&&Array.isArray(M)){if($.length!==M.length)return!1;for(let Q=0;Q<$.length;Q++)if(!p($[Q],M[Q],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(M))return!1;if(E($)&&E(M)){let Q=Object.keys($),X=Object.keys(M);if(Q.length!==X.length)return!1;for(let q of Q){if(!(q in M))return!1;if(!p($[q],M[q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(M)}},q$=($,M)=>{let z=e($),Q=e(M);if(!z||!Q){let A=!Object.is($,M);return{changed:A,add:A&&Q?M:{},change:{},remove:A&&z?$:{}}}let X=new WeakSet,q={},H={},U={},D=Object.keys($),_=Object.keys(M),C=new Set([...D,..._]);for(let A of C){let G=A in $,Z=A in M;if(!G&&Z){q[A]=M[A];continue}else if(G&&!Z){U[A]=N;continue}let K=$[A],I=M[A];if(!p(K,I,X))H[A]=I}return{add:q,change:H,remove:U,changed:!!(Object.keys(q).length||Object.keys(H).length||Object.keys(U).length)}};var d,M$=new Set,D$=0,V=($)=>{let M=new Set,z=$;return z.unwatch=(Q)=>{M.add(Q)},z.cleanup=()=>{for(let Q of M)Q();M.clear()},z},j=($)=>{if(d&&!$.has(d)){let M=d;M.unwatch(()=>{$.delete(M)}),$.add(M)}},L=($)=>{for(let M of $)if(D$)M$.add(M);else M()},z$=()=>{while(M$.size){let $=Array.from(M$);M$.clear();for(let M of $)M()}},K$=($)=>{D$++;try{$()}finally{z$(),D$--}},O=($,M)=>{let z=d;d=M;try{$()}finally{d=z}},W=($,M)=>{Object.freeze(M);for(let z of $)z(M)};var Y$="Computed",n=($,M=N)=>{if(!G$($))throw new g("computed",$);if(M==null)throw new f("computed");let z=new Set,Q=M,X,q,H=!0,U=!1,D=!1,_=(F)=>{if(!p(F,Q))Q=F,U=!0;X=void 0,H=!1},C=()=>{U=N!==Q,Q=N,X=void 0},A=(F)=>{let P=m(F);U=!X||P.name!==X.name||P.message!==X.message,Q=N,X=P},G=(F)=>(P)=>{if(D=!1,q=void 0,F(P),U)L(z)},Z=V(()=>{if(H=!0,q?.abort(),z.size)L(z);else Z.cleanup()});Z.unwatch(()=>{q?.abort()});let K=()=>O(()=>{if(D)throw new b("computed");if(U=!1,o($)){if(q)return Q;q=new AbortController,q.signal.addEventListener("abort",()=>{D=!1,q=void 0,K()},{once:!0})}let F;D=!0;try{F=q?$(Q,q.signal):$(Q)}catch(P){if(v(P))C();else A(P);D=!1;return}if(F instanceof Promise)F.then(G(_),G(A));else if(F==null||N===F)C();else _(F);D=!1},Z),I={};return Object.defineProperties(I,{[Symbol.toStringTag]:{value:Y$},get:{value:()=>{if(j(z),z$(),H)K();if(X)throw X;return Q}}}),I},s=($)=>S($,Y$),G$=($)=>T($)&&$.length<3;var P$=($)=>{if(!T($)||$.length>1)throw new g("effect",$);let M=o($),z=!1,Q,X=V(()=>O(()=>{if(z)throw new b("effect");z=!0,Q?.abort(),Q=void 0;let q;try{if(M){Q=new AbortController;let H=Q;$(Q.signal).then((U)=>{if(T(U)&&Q===H)X.unwatch(U)}).catch((U)=>{if(!v(U))console.error("Async effect error:",U)})}else if(q=$(),T(q))X.unwatch(q)}catch(H){if(!v(H))console.error("Effect callback error:",H)}z=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function j$($,M){try{if($.pending)M.nil?.();else if($.errors)M.err?.($.errors);else if($.ok)M.ok($.values)}catch(z){if(M.err&&(!$.errors||!$.errors.includes(m(z))))M.err($.errors?[...$.errors,m(z)]:[m(z)]);else throw z}}function C$($){let M=[],z=!1,Q={};for(let[X,q]of Object.entries($))try{let H=q.get();if(H===N)z=!0;else Q[X]=H}catch(H){M.push(m(H))}if(z)return{ok:!1,pending:!0};if(M.length>0)return{ok:!1,errors:M};return{ok:!0,values:Q}}var x$="State",t=($)=>{if($==null)throw new f("state");let M=new Set,z=$,Q=(q)=>{if(q==null)throw new f("state");if(p(z,q))return;if(z=q,L(M),N===z)M.clear()},X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:x$},get:{value:()=>{return j(M),z}},set:{value:(q)=>{Q(q)}},update:{value:(q)=>{if(!T(q))throw new g("state update",q);Q(q(z))}}}),X},u=($)=>S($,x$);var f$="Collection",T$=($,M)=>{let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,q=new Map,H=[],U=(G)=>{let Z=n(M);if(X.set(G,Z),!H.includes(G))H.push(G);let K=V(()=>O(()=>{W(Q.change,[G])},K));return K(),q.set(G,K),!0},D=(G)=>{if(!X.delete(G))return;let K=H.indexOf(G);if(K>=0)H.splice(K,1);let I=q.get(G);if(I)I.cleanup();q.delete(G)};for(let G=0;G<$.length;G++){let Z=$.keyAt(G);if(!Z)continue;U(Z)}$.on("add",(G)=>{for(let Z of G)if(!X.has(Z))U(Z);else throw new h("collection",Z);L(z),W(Q.add,G)}),$.on("remove",(G)=>{for(let Z of Object.keys(G)){if(!X.has(Z))continue;D(Z)}H=H.filter(()=>!0),L(z),W(Q.remove,G)}),$.on("sort",(G)=>{H=[...G],L(z),W(Q.sort,G)});let _=(G)=>{let Z=G,K=Number(G);if(Number.isInteger(K)&&K>=0)Z=H[K]??G;return X.get(Z)},C=()=>H.map((G)=>X.get(G)?.get()).filter((G)=>G!==void 0),A={};return Object.defineProperties(A,{[Symbol.toStringTag]:{value:f$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let G of H){let Z=X.get(G);if(Z)yield Z}}},byKey:{value(G){return _(G)}},keyAt:{value(G){return H[G]}},indexOfKey:{value(G){return H.indexOf(G)}},get:{value:()=>{return j(z),C()}},sort:{value:(G)=>{H=H.map((K,I)=>{let F=X.get(K);return[I,K,F?F.get():void 0]}).sort(G?(K,I)=>G(K[2],I[2]):(K,I)=>String(K[2]).localeCompare(String(I[2]))).map(([K,I])=>I),L(z),W(Q.sort,[...H])}},on:{value:(G,Z)=>{return Q[G].add(Z),()=>Q[G].delete(Z)}},length:{get(){return j(z),X.size}}}),new Proxy(A,{get(G,Z){if(Z in G)return Reflect.get(G,Z);if(!w(Z))return _(Z)},has(G,Z){if(Z in G)return!0;return X.has(String(Z))},ownKeys(G){let Z=Reflect.ownKeys(G);return[...new Set([...H,...Z])]},getOwnPropertyDescriptor(G,Z){if(Z in G)return Reflect.getOwnPropertyDescriptor(G,Z);if(w(Z))return;let K=_(Z);return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})};var A$="Store",Q$=($,M)=>{if($==null)throw new f("store");let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,q=new Map,H=Array.isArray($),U=0,D=[],_=(B)=>{let J=B;if(H){let R=Number(B);if(Number.isInteger(R)&&R>=0)J=D[R]??B}return X.get(J)},C=(B)=>{if(!H)return"";let J=U++;return a(M)?`${M}${J}`:T(M)?M(B):String(J)},A=(B)=>{if(!Array.isArray(B))return B;let J={};for(let R=0;R<B.length;R++){let Y=B[R];if(Y===void 0)continue;let x=D[R];if(!x)x=C(Y),D[R]=x;J[x]=Y}return J},G=()=>{if(H)return D.map((J)=>X.get(J)?.get()).filter((J)=>J!==void 0);let B={};for(let J of D){let R=X.get(J);if(R)B[J]=R.get()}return B},Z=(B,J)=>{if(J==null)throw new f(`store for key "${B}"`);if(J===N)return!0;if(w(J)||T(J)||s(J))throw new $$(`store for key "${B}"`,J);return!0},K=(B,J,R=!1)=>{if(!Z(B,J))return!1;let Y=u(J)||i(J)?J:E(J)||Array.isArray(J)?Q$(J):t(J);if(X.set(B,Y),!D.includes(B))D.push(B);let x=V(()=>O(()=>{Y.get(),W(Q.change,[B])},x));if(x(),q.set(B,x),R)L(z),W(Q.add,[B]);return!0},I=(B,J=!1)=>{if(!X.delete(B))return;let Y=D.indexOf(B);if(Y>=0)D.splice(Y,1);let x=q.get(B);if(x)x.cleanup();if(q.delete(B),J)D=D.filter(()=>!0),L(z),W(Q.remove,[B])},F=(B,J)=>{if(Object.keys(B.add).length){for(let R in B.add)K(R,B.add[R]??N,!1);if(J)setTimeout(()=>{W(Q.add,Object.keys(B.add))},0);else W(Q.add,Object.keys(B.add))}if(Object.keys(B.change).length)K$(()=>{for(let R in B.change){let Y=B.change[R];if(!Z(R,Y))continue;let x=X.get(R);if(U$(x))x.set(Y);else throw new J$(R,Y)}W(Q.change,Object.keys(B.change))});if(Object.keys(B.remove).length){for(let R in B.remove)I(R);D=D.filter(()=>!0),W(Q.remove,Object.keys(B.remove))}return B.changed},P=(B,J,R)=>F(q$(H?A(B):B,H?A(J):J),R);P(H?[]:{},$,!0);let I$={};Object.defineProperties(I$,{[Symbol.toStringTag]:{value:A$},[Symbol.isConcatSpreadable]:{value:H},[Symbol.iterator]:{value:function*(){for(let B of D){let J=X.get(B);if(J)yield H?J:[B,J]}}},add:{value:H?(B)=>{let J=C(B);if(!X.has(J))return K(J,B,!0),J;else throw new h("store",J,B)}:(B,J)=>{if(!X.has(B))return K(B,J,!0),B;else throw new h("store",B,J)}},byKey:{value:(B)=>{return _(B)}},deriveCollection:{value:(B)=>{if(!H)throw new c("deriveCollection","store","it is only supported for array-like stores");return T$(F$,B)}},keyAt:{value(B){return D[B]}},indexOfKey:{value(B){return D.indexOf(B)}},get:{value:()=>{return j(z),G()}},remove:{value:(B)=>{let J=String(B);if(R$(B)){if(!D[B])throw new B$(B);J=D[B]}if(X.has(J))I(J,!0)}},set:{value:(B)=>{if(P(G(),B)){if(L(z),N===B)z.clear()}}},update:{value:(B)=>{let J=G(),R=B(J);if(P(J,R)){if(L(z),N===R)z.clear()}}},sort:{value:(B)=>{D=D.map((R,Y)=>{let x=X.get(R);return[Y,R,x?x.get():void 0]}).sort(B?(R,Y)=>B(R[2],Y[2]):(R,Y)=>String(R[2]).localeCompare(String(Y[2]))).map(([R,Y])=>Y),L(z),W(Q.sort,[...D])}},splice:{value:(B,J,...R)=>{if(!H)throw new c("splice","store","it is only supported for array-like stores");let Y=X.size,x=B<0?Math.max(0,Y+B):Math.min(B,Y),N$=Math.max(0,Math.min(J??Math.max(0,Y-Math.max(0,x)),Y-x)),X$={},l={};for(let k=0;k<N$;k++){let r=x+k,H$=D[r];if(H$){let W$=X.get(H$);if(W$)l[H$]=W$.get()}}let Z$=D.slice(0,x);for(let k of R){let r=C(k);Z$.push(r),X$[r]=k}Z$.push(...D.slice(x+N$)),D=Z$.filter(()=>!0);let L$=!!(Object.keys(X$).length||Object.keys(l).length);if(L$)F({add:X$,change:{},remove:l,changed:L$});return L(z),Object.values(l)}},on:{value:(B,J)=>{return Q[B].add(J),()=>Q[B].delete(J)}},length:{get(){return j(z),X.size}}});let F$=new Proxy(I$,{get(B,J){if(J in B)return Reflect.get(B,J);if(!w(J))return _(J)},has(B,J){if(J in B)return!0;return X.has(String(J))},ownKeys(B){let J=Reflect.ownKeys(B);return[...new Set([...D,...J])]},getOwnPropertyDescriptor(B,J){if(J in B)return Reflect.getOwnPropertyDescriptor(B,J);if(w(J))return;let R=_(J);return R?{enumerable:!0,configurable:!0,writable:!0,value:R}:void 0}});return F$},i=($)=>S($,A$);var _$=($)=>u($)||s($)||i($),U$=($)=>u($)||i($);function S$($){if(_$($))return $;if(G$($))return n($);if(Array.isArray($)||E($))return Q$($);return t($)}export{y as valueString,S$ as toSignal,m as toError,j as subscribe,C$ as resolve,O as observe,L as notify,j$ as match,w as isSymbol,a as isString,i as isStore,u as isState,_$ as isSignal,e as isRecordOrArray,E as isRecord,S as isObjectOfType,R$ as isNumber,U$ as isMutableSignal,T as isFunction,p as isEqual,G$ as isComputedCallback,s as isComputed,o as isAsyncFunction,v as isAbortError,z$ as flush,W as emit,q$ as diff,V as createWatcher,Q$ as createStore,t as createState,P$ as createEffect,n as createComputed,K$ as batch,N as UNSET,A$ as TYPE_STORE,x$ as TYPE_STATE,Y$ as TYPE_COMPUTED,J$ as StoreKeyReadonlyError,B$ as StoreIndexRangeError,f as NullishSignalValueError,$$ as InvalidSignalValueError,g as InvalidCallbackError,c as ForbiddenMethodCallError,h as DuplicateKeyError,b as CircularDependencyError};
