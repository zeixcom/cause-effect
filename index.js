var F,O=new Set,N=0,P=new Map,R,h=()=>{R=void 0;let $=Array.from(P.values());P.clear();for(let B of $)B()},v=()=>{if(R)cancelAnimationFrame(R);R=requestAnimationFrame(h)};queueMicrotask(h);var A=($)=>{let B=new Set,H=$;return H.off=(W)=>{B.add(W)},H.cleanup=()=>{for(let W of B)W();B.clear()},H},C=($)=>{if(F&&!$.has(F)){let B=F;$.add(B),F.off(()=>{$.delete(B)})}},j=($)=>{for(let B of $)if(N)O.add(B);else B()},q=()=>{while(O.size){let $=Array.from(O);O.clear();for(let B of $)B()}},o=($)=>{N++;try{$()}finally{q(),N--}},M=($,B)=>{let H=F;F=B;try{$()}finally{F=H}},i=($,B)=>new Promise((H,W)=>{P.set(B||Symbol(),()=>{try{H($())}catch(z){W(z)}}),v()});var V=($)=>typeof $==="function",Y=($)=>V($)&&$.constructor.name==="AsyncFunction",D=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,y=($)=>$ instanceof DOMException&&$.name==="AbortError",X=($)=>$ instanceof Error?$:Error(String($));class x extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var U="State",k=($)=>{let B=new Set,H=$,W={[Symbol.toStringTag]:U,get:()=>{return C(B),H},set:(z)=>{if(Object.is(H,z))return;if(H=z,j(B),L===H)B.clear()},update:(z)=>{W.set(z(H))}};return W},_=($)=>D($,U);var L=Symbol(),d=($)=>_($)||S($),c=($)=>d($)?$:m($)?T($):k($);var f="Computed",T=($)=>{let B=new Set,H=L,W,z,Q=!0,G=!1,K=!1,E=(J)=>{if(!Object.is(J,H))H=J,G=!0;W=void 0,Q=!1},b=()=>{G=L!==H,H=L,W=void 0},g=(J)=>{let Z=X(J);G=!W||Z.name!==W.name||Z.message!==W.message,H=L,W=Z},w=(J)=>(Z)=>{if(K=!1,z=void 0,J(Z),G)j(B)},I=A(()=>{if(Q=!0,z?.abort(),B.size)j(B);else I.cleanup()});I.off(()=>{z?.abort()});let p=()=>M(()=>{if(K)throw new x("computed");if(G=!1,Y($)){if(z)return H;z=new AbortController,z.signal.addEventListener("abort",()=>{K=!1,z=void 0,p()},{once:!0})}let J;K=!0;try{J=z?$(z.signal):$()}catch(Z){if(y(Z))b();else g(Z);K=!1;return}if(J instanceof Promise)J.then(w(E),w(g));else if(J==null||L===J)b();else E(J);K=!1},I);return{[Symbol.toStringTag]:f,get:()=>{if(C(B),q(),Q)p();if(W)throw W;return H}}},S=($)=>D($,f),m=($)=>V($)&&$.length<2;var n=($)=>{let B=Y($),H=!1,W,z=A(()=>M(()=>{if(H)throw new x("effect");H=!0,W?.abort(),W=void 0;let Q;try{if(B){W=new AbortController;let G=W;$(W.signal).then((K)=>{if(V(K)&&W===G)z.off(K)}).catch((K)=>{if(!y(K))console.error("Async effect error:",K)})}else if(Q=$(),V(Q))z.off(Q)}catch(G){if(!y(G))console.error("Effect callback error:",G)}H=!1},z));return z(),()=>{W?.abort(),z.cleanup()}};function s($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(H){if(B.err&&(!$.errors||!$.errors.includes(X(H)))){let W=$.errors?[...$.errors,X(H)]:[X(H)];B.err(W)}else throw H}}function u($){let B=[],H=!1,W={};for(let[z,Q]of Object.entries($))try{let G=Q.get();if(G===L)H=!0;else W[z]=G}catch(G){B.push(X(G))}if(H)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:W}}export{A as watch,c as toSignal,X as toError,C as subscribe,k as state,u as resolve,M as observe,j as notify,s as match,_ as isState,d as isSignal,V as isFunction,m as isComputedCallback,S as isComputed,Y as isAsyncFunction,y as isAbortError,q as flush,i as enqueue,n as effect,T as computed,o as batch,L as UNSET,U as TYPE_STATE,f as TYPE_COMPUTED,x as CircularDependencyError};
