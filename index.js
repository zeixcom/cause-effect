var D,A=new Set,E=0,O=new Map,g,s=()=>{g=void 0;let $=Array.from(O.values());O.clear();for(let W of $)W()},u=()=>{if(g)cancelAnimationFrame(g);g=requestAnimationFrame(s)};queueMicrotask(s);var N=($)=>{let W=new Set,G=$;return G.off=(J)=>{W.add(J)},G.cleanup=()=>{for(let J of W)J();W.clear()},G},R=($)=>{if(D&&!$.has(D)){let W=D;$.add(W),D.off(()=>{$.delete(W)})}},P=($)=>{for(let W of $)if(E)A.add(W);else W()},_=()=>{while(A.size){let $=Array.from(A);A.clear();for(let W of $)W()}},n=($)=>{E++;try{$()}finally{_(),E--}},f=($,W)=>{let G=D;D=W;try{$()}finally{D=G}},c=($,W)=>new Promise((G,J)=>{O.set(W||Symbol(),()=>{try{G($())}catch(H){J(H)}}),u()});var X=($)=>typeof $==="function",M=($)=>X($)&&$.constructor.name==="AsyncFunction",w=($,W)=>Object.prototype.toString.call($)===`[object ${W}]`,S=($)=>$ instanceof DOMException&&$.name==="AbortError",Y=($)=>$ instanceof Error?$:Error(String($));class F extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var C="State",k=($)=>{let W=new Set,G=$,J={[Symbol.toStringTag]:C,get:()=>{return R(W),G},set:(H)=>{if(Object.is(G,H))return;if(G=H,P(W),x===G)W.clear()},update:(H)=>{J.set(H(G))}};return J},m=($)=>w($,C);var x=Symbol(),o=($)=>m($)||b($),t=($)=>o($)?$:d($)?p($):k($);var h="Computed",v="Aborted because source signal changed",i="Aborted because cleanup was called",p=($)=>{let W=new Set,G=x,J,H,K=!0,Z=!1,L=!1,q=(z)=>{if(!Object.is(z,G))G=z,Z=!0;J=void 0,K=!1},B=()=>{Z=x!==G,G=x,J=void 0},V=(z)=>{let Q=Y(z);Z=!J||Q.name!==J.name||Q.message!==J.message,G=x,J=Q},U=(z)=>(Q)=>{if(L=!1,H=void 0,z(Q),Z)P(W)},I=N(()=>{if(K=!0,H?.abort(v),W.size)P(W);else I.cleanup()});I.off(()=>{H?.abort(i)});let j=()=>f(()=>{if(L)throw new F("computed");if(Z=!1,M($)){if(H)return G;H=new AbortController,H.signal.addEventListener("abort",()=>{L=!1,H=void 0,j()},{once:!0})}let z;L=!0;try{z=H?$(H.signal):$()}catch(Q){if(S(Q))B();else V(Q);L=!1;return}if(z instanceof Promise)z.then(U(q),U(V));else if(z==null||x===z)B();else q(z);L=!1},I);return{[Symbol.toStringTag]:h,get:()=>{if(R(W),_(),K)j();if(J)throw J;return G}}},b=($)=>w($,h),d=($)=>X($)&&$.length<2;function l($){let W=M($),G=X($),J=G||W?{}:$.signals,H=G?$:W?$:$.ok,K=$.err?$.err:console.error,Z=$.nil?$.nil:()=>{},L=!1,q,B=N(()=>f(()=>{if(L)throw new F("effect");L=!0,q?.abort(v),q=void 0;let V=[],U=!1,I={};for(let[z,Q]of Object.entries(J))try{let T=Q.get();if(T===x)U=!0;I[z]=T}catch(T){V.push(Y(T))}let j;if([H,Z,K].some(M))q=new AbortController;let y=q?.signal;try{if(U)j=M(Z)?Z(y):X(Z)?Z():void 0;else if(V.length)j=M(K)?K(V,y):X(K)?K(V):void 0;else j=M(H)?H(I,y):X(H)?H(I):void 0}catch(z){j=S(z)||!K?void 0:M(K)?K([...V,Y(z)],y):K([...V,Y(z)])}finally{if(j instanceof Promise)j.then((z)=>{if(X(z))B.off(z)}).catch((z)=>{if(!S(z)){let Q=!K?void 0:M(K)?K([...V,Y(z)],y):K([...V,Y(z)]);if(Q instanceof Promise)Q.catch(console.error);else if(X(Q))B.off(Q)}});else if(X(j))B.off(j)}L=!1},B));return B(),()=>{q?.abort(i),B.cleanup()}}export{N as watch,t as toSignal,R as subscribe,k as state,f as observe,P as notify,m as isState,o as isSignal,X as isFunction,d as isComputedCallback,b as isComputed,_ as flush,c as enqueue,l as effect,p as computed,n as batch,x as UNSET,C as TYPE_STATE,h as TYPE_COMPUTED,F as CircularDependencyError};
