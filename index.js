class _ extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class m extends TypeError{constructor($,x){super(`Invalid ${$} callback ${x}`);this.name="InvalidCallbackError"}}class h extends TypeError{constructor($,x){super(`Invalid signal value ${x} in ${$}`);this.name="InvalidSignalValueError"}}class L extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class v extends Error{constructor($,x){super(`Could not add store key "${$}" with value ${x} because it already exists`);this.name="StoreKeyExistsError"}}class n extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class u extends Error{constructor($,x){super(`Could not set store key "${$}" to ${x} because it is readonly`);this.name="StoreKeyReadonlyError"}}var q=Symbol(),e=($)=>typeof $==="string",X$=($)=>typeof $==="number",c=($)=>typeof $==="symbol",K=($)=>typeof $==="function",b=($)=>K($)&&$.constructor.name==="AsyncFunction",W=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,A=($)=>W($,"Object"),s=($)=>A($)||Array.isArray($),H$=($)=>{if(!$.length)return null;let x=$.map((z)=>e(z)?parseInt(z,10):X$(z)?z:NaN);return x.every((z)=>Number.isFinite(z)&&z>=0)?x.sort((z,J)=>z-J):null};var y=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var t=($)=>{let x=H$(Object.keys($));if(x===null)return $;let z=[];for(let J of x)z.push($[String(J)]);return z},F=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var f=($,x,z)=>{if(Object.is($,x))return!0;if(typeof $!==typeof x)return!1;if(typeof $!=="object"||$===null||x===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(x))throw new _("isEqual");z.add($),z.add(x);try{if(Array.isArray($)&&Array.isArray(x)){if($.length!==x.length)return!1;for(let J=0;J<$.length;J++)if(!f($[J],x[J],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(x))return!1;if(A($)&&A(x)){let J=Object.keys($),M=Object.keys(x);if(J.length!==M.length)return!1;for(let Q of J){if(!(Q in x))return!1;if(!f($[Q],x[Q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(x)}},$$=($,x)=>{let z=s($),J=s(x);if(!z||!J){let C=!Object.is($,x);return{changed:C,add:C&&J?x:{},change:{},remove:C&&z?$:{}}}let M=new WeakSet,Q={},H={},I={},Y=Object.keys($),E=Object.keys(x),P=new Set([...Y,...E]);for(let C of P){let N=C in $,B=C in x;if(!N&&B){Q[C]=x[C];continue}else if(N&&!B){I[C]=q;continue}let R=$[C],G=x[C];if(!f(R,G,M))H[C]=G}return{changed:Object.keys(Q).length>0||Object.keys(H).length>0||Object.keys(I).length>0,add:Q,change:H,remove:I}};var p,i=new Set,x$=0,O=($)=>{let x=new Set,z=$;return z.unwatch=(J)=>{x.add(J)},z.cleanup=()=>{for(let J of x)J();x.clear()},z},j=($)=>{if(p&&!$.has(p)){let x=p;x.unwatch(()=>{$.delete(x)}),$.add(x)}},T=($)=>{for(let x of $)if(x$)i.add(x);else x()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let x of $)x()}},R$=($)=>{x$++;try{$()}finally{r(),x$--}},S=($,x)=>{let z=p;p=x;try{$()}finally{p=z}};var B$="Computed",J$=($,x=q)=>{if(!l($))throw new m("computed",F($));if(x==null)throw new L("computed");let z=new Set,J=x,M,Q,H=!0,I=!1,Y=!1,E=(R)=>{if(!f(R,J))J=R,I=!0;M=void 0,H=!1},P=()=>{I=q!==J,J=q,M=void 0},V=(R)=>{let G=U(R);I=!M||G.name!==M.name||G.message!==M.message,J=q,M=G},C=(R)=>(G)=>{if(Y=!1,Q=void 0,R(G),I)T(z)},N=O(()=>{if(H=!0,Q?.abort(),z.size)T(z);else N.cleanup()});N.unwatch(()=>{Q?.abort()});let B=()=>S(()=>{if(Y)throw new _("computed");if(I=!1,b($)){if(Q)return J;Q=new AbortController,Q.signal.addEventListener("abort",()=>{Y=!1,Q=void 0,B()},{once:!0})}let R;Y=!0;try{R=Q?$(J,Q.signal):$(J)}catch(G){if(y(G))P();else V(G);Y=!1;return}if(R instanceof Promise)R.then(C(E),C(V));else if(R==null||q===R)P();else E(R);Y=!1},N);return{[Symbol.toStringTag]:B$,get:()=>{if(j(z),r(),H)B();if(M)throw M;return J}}},g=($)=>W($,B$),l=($)=>K($)&&$.length<3;var C$=($)=>{if(!K($)||$.length>1)throw new m("effect",F($));let x=b($),z=!1,J,M=O(()=>S(()=>{if(z)throw new _("effect");z=!0,J?.abort(),J=void 0;let Q;try{if(x){J=new AbortController;let H=J;$(J.signal).then((I)=>{if(K(I)&&J===H)M.unwatch(I)}).catch((I)=>{if(!y(I))console.error("Async effect error:",I)})}else if(Q=$(),K(Q))M.unwatch(Q)}catch(H){if(!y(H))console.error("Effect callback error:",H)}z=!1},M));return M(),()=>{J?.abort(),M.cleanup()}};function q$($,x){try{if($.pending)x.nil?.();else if($.errors)x.err?.($.errors);else if($.ok)x.ok($.values)}catch(z){if(x.err&&(!$.errors||!$.errors.includes(U(z))))x.err($.errors?[...$.errors,U(z)]:[U(z)]);else throw z}}function D$($){let x=[],z=!1,J={};for(let[M,Q]of Object.entries($))try{let H=Q.get();if(H===q)z=!0;else J[M]=H}catch(H){x.push(U(H))}if(z)return{ok:!1,pending:!0};if(x.length>0)return{ok:!1,errors:x};return{ok:!0,values:J}}var z$="State",k=($)=>{if($==null)throw new L("state");let x=new Set,z=$,J={[Symbol.toStringTag]:z$,get:()=>{return j(x),z},set:(M)=>{if(M==null)throw new L("state");if(f(z,M))return;if(z=M,T(x),q===z)x.clear()},update:(M)=>{if(!K(M))throw new m("state update",F(M));J.set(M(z))}};return J},w=($)=>W($,z$);var G$="Store",a=($)=>{if($==null)throw new L("store");let x=new Set,z={add:new Set,change:new Set,remove:new Set,sort:new Set},J=new Map,M=new Map,Q=Array.isArray($),H=()=>{let B={};for(let[R,G]of J)B[R]=G.get();return B},I=(B,R)=>{Object.freeze(R);for(let G of z[B])G(R)},Y=()=>Array.from(J.keys()).map((B)=>Number(B)).filter((B)=>Number.isInteger(B)).sort((B,R)=>B-R),E=(B,R)=>{if(R==null)throw new L(`store for key "${B}"`);if(R===q)return!0;if(c(R)||K(R)||g(R))throw new h(`store for key "${B}"`,F(R));return!0},P=(B,R,G=!1)=>{if(!E(B,R))return!1;let X=w(R)||o(R)?R:A(R)||Array.isArray(R)?a(R):k(R);J.set(B,X);let Z=O(()=>S(()=>{I("change",{[B]:X.get()})},Z));if(Z(),M.set(B,Z),G)T(x),I("add",{[B]:R});return!0},V=(B,R=!1)=>{let G=J.delete(B);if(G){let X=M.get(B);if(X)X.cleanup();M.delete(B)}if(R)T(x),I("remove",{[B]:q});return G},C=(B,R,G)=>{let X=$$(B,R);return R$(()=>{if(Object.keys(X.add).length){for(let Z in X.add)P(Z,X.add[Z]??q);if(G)setTimeout(()=>{I("add",X.add)},0);else I("add",X.add)}if(Object.keys(X.change).length){for(let Z in X.change){let D=X.change[Z];if(!E(Z,D))continue;let d=J.get(Z);if(M$(d))d.set(D);else throw new u(Z,F(D))}I("change",X.change)}if(Object.keys(X.remove).length){for(let Z in X.remove)V(Z);I("remove",X.remove)}}),X.changed};C({},$,!0);let N={};return Object.defineProperties(N,{[Symbol.toStringTag]:{value:G$},[Symbol.isConcatSpreadable]:{value:Q},[Symbol.iterator]:{value:Q?function*(){let B=Y();for(let R of B){let G=J.get(String(R));if(G)yield G}}:function*(){for(let[B,R]of J)yield[B,R]}},add:{value:Q?(B)=>{P(String(J.size),B,!0)}:(B,R)=>{if(!J.has(B))P(B,R,!0);else throw new v(B,F(R))}},get:{value:()=>{return j(x),t(H())}},remove:{value:Q?(B)=>{let R=t(H()),G=J.size;if(!Array.isArray(R)||B<=-G||B>=G)throw new n(B);let X=[...R];if(X.splice(B,1),C(R,X))T(x)}:(B)=>{if(J.has(B))V(B,!0)}},set:{value:(B)=>{if(C(H(),B)){if(T(x),q===B)x.clear()}}},update:{value:(B)=>{let R=H(),G=B(t(R));if(C(R,G)){if(T(x),q===G)x.clear()}}},sort:{value:(B)=>{let R=Array.from(J.entries()).map(([Z,D])=>[Z,D.get()]).sort(B?(Z,D)=>B(Z[1],D[1]):(Z,D)=>String(Z[1]).localeCompare(String(D[1]))),G=R.map(([Z])=>String(Z)),X=new Map;R.forEach(([Z],D)=>{let d=String(Z),I$=Q?String(D):String(Z),Q$=J.get(d);if(Q$)X.set(I$,Q$)}),J.clear(),X.forEach((Z,D)=>J.set(D,Z)),T(x),I("sort",G)}},on:{value:(B,R)=>{return z[B].add(R),()=>z[B].delete(R)}},length:{get(){return j(x),J.size}}}),new Proxy(N,{get(B,R){if(R in B)return Reflect.get(B,R);if(c(R))return;return J.get(R)},has(B,R){if(R in B)return!0;return J.has(String(R))},ownKeys(B){let R=Reflect.ownKeys(B),G=Q?Y().map((X)=>String(X)):Array.from(J.keys());return[...new Set([...G,...R])]},getOwnPropertyDescriptor(B,R){if(R in B)return Reflect.getOwnPropertyDescriptor(B,R);let G=J.get(String(R));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},o=($)=>W($,G$);var Z$=($)=>w($)||g($)||o($),M$=($)=>w($)||o($);function T$($){if(Z$($))return $;if(l($))return J$($);if(Array.isArray($)||A($))return a($);return k($)}export{F as valueString,T$ as toSignal,U as toError,j as subscribe,D$ as resolve,S as observe,T as notify,q$ as match,c as isSymbol,e as isString,o as isStore,w as isState,Z$ as isSignal,s as isRecordOrArray,A as isRecord,W as isObjectOfType,X$ as isNumber,M$ as isMutableSignal,K as isFunction,f as isEqual,l as isComputedCallback,g as isComputed,b as isAsyncFunction,y as isAbortError,r as flush,$$ as diff,O as createWatcher,a as createStore,k as createState,C$ as createEffect,J$ as createComputed,R$ as batch,q as UNSET,G$ as TYPE_STORE,z$ as TYPE_STATE,B$ as TYPE_COMPUTED,u as StoreKeyReadonlyError,n as StoreKeyRangeError,v as StoreKeyExistsError,L as NullishSignalValueError,h as InvalidSignalValueError,m as InvalidCallbackError,_ as CircularDependencyError};
