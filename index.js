var w,p=new Set,c=0,x=($)=>{let J=new Set,G=$;return G.onCleanup=(X)=>{J.add(X)},G.stop=()=>{for(let X of J)X();J.clear()},G},K=($)=>{if(w&&!$.has(w)){let J=w;J.onCleanup(()=>$.delete(J)),$.add(J)}},B=($)=>{for(let J of $)if(c)p.add(J);else J()},V=()=>{while(p.size){let $=Array.from(p);p.clear();for(let J of $)J()}},Q$=($)=>{c++;try{$()}finally{V(),c--}},R=($,J)=>{let G=w;w=$||void 0;try{J()}finally{w=G}},M=($,J)=>{for(let G of $)if(c)p.add(()=>G(J));else G(J)};var H=Symbol(),i=($)=>typeof $==="string",l=($)=>typeof $==="number",D=($)=>typeof $==="symbol",F=($)=>typeof $==="function",f=($)=>F($)&&$.constructor.name==="AsyncFunction",R$=($)=>F($)&&$.constructor.name!=="AsyncFunction",z$=($)=>$!=null&&typeof $==="object",L=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,T=($)=>L($,"Object"),t=($)=>T($)||Array.isArray($),H$=($,J=(G)=>G!=null)=>Array.isArray($)&&$.every(J);var E=($)=>$ instanceof DOMException&&$.name==="AbortError",j=($)=>$ instanceof Error?$:Error(String($)),b=($)=>i($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var r="Computed";class h{#G=new Set;#J;#X;#$;#Q=!0;#z=!1;#Z;constructor($,J=H){d("memo",$,a),U("memo",J),this.#J=$,this.#X=J,this.#Z=x(()=>{if(this.#Q=!0,this.#G.size)B(this.#G);else this.#Z.stop()})}get[Symbol.toStringTag](){return r}get(){if(K(this.#G),V(),this.#Q)R(this.#Z,()=>{if(this.#z)throw new N("memo");let $;this.#z=!0;try{$=this.#J(this.#X)}catch(J){this.#X=H,this.#$=j(J),this.#z=!1;return}if($==null||H===$)this.#X=H,this.#$=void 0;else this.#X=$,this.#$=void 0,this.#Q=!1;this.#z=!1});if(this.#$)throw this.#$;return this.#X}}class v{#G=new Set;#J;#X;#$;#Q=!0;#z=!1;#Z=!1;#q;#H;constructor($,J=H){d("task",$,e),U("task",J),this.#J=$,this.#X=J,this.#q=x(()=>{if(this.#Q=!0,this.#H?.abort(),this.#G.size)B(this.#G);else this.#q.stop()}),this.#q.onCleanup(()=>{this.#H?.abort()})}get[Symbol.toStringTag](){return r}get(){K(this.#G),V();let $=(Q)=>{if(!P(Q,this.#X))this.#X=Q,this.#Z=!0;this.#$=void 0,this.#Q=!1},J=()=>{this.#Z=H!==this.#X,this.#X=H,this.#$=void 0},G=(Q)=>{let z=j(Q);this.#Z=!this.#$||z.name!==this.#$.name||z.message!==this.#$.message,this.#X=H,this.#$=z},X=(Q)=>(z)=>{if(this.#z=!1,this.#H=void 0,Q(z),this.#Z)B(this.#G)},Z=()=>R(this.#q,()=>{if(this.#z)throw new N("task");if(this.#Z=!1,this.#H)return this.#X;this.#H=new AbortController,this.#H.signal.addEventListener("abort",()=>{this.#z=!1,this.#H=void 0,Z()},{once:!0});let Q;this.#z=!0;try{Q=this.#J(this.#X,this.#H.signal)}catch(z){if(E(z))J();else G(z);this.#z=!1;return}if(Q instanceof Promise)Q.then(X($),X(G));else if(Q==null||H===Q)J();else $(Q);this.#z=!1});if(this.#Q)Z();if(this.#$)throw this.#$;return this.#X}}var T$=($,J=H)=>f($)?new v($,J):new h($,J),q$=($)=>L($,r),a=($)=>R$($)&&$.length<2,e=($)=>f($)&&$.length<3;class u{#G;#J=new Map;#X=new Map;#$={add:new Set,change:new Set,remove:new Set};#Q=!1;constructor($,J){this.#G=J,this.change({add:$,change:{},remove:{},changed:!0},!0)}#z($){let J=x(()=>{R(J,()=>{if(this.#J.get($)?.get(),!this.#Q)M(this.#$.change,[$])})});this.#X.set($,J),J()}#Z($){let J=this.#X.get($);if(J)J.stop(),this.#X.delete($)}keys(){return this.#J.keys()}values(){return this.#J.values()}entries(){return this.#J.entries()}has($){return this.#J.has($)}get($){return this.#J.get($)}add($,J){if(!this.#G($,J))return!1;let G=j$(J);if(this.#J.set($,G),this.#$.change.size)this.#z($);if(!this.#Q)M(this.#$.add,[$]);return!0}remove($){if(!this.#J.delete($))return!1;if(this.#Z($),!this.#Q)M(this.#$.remove,[$]);return!0}change($,J){if(this.#Q=!0,Object.keys($.add).length){for(let X in $.add)this.add(X,$.add[X]);let G=()=>M(this.#$.add,Object.keys($.add));if(J)setTimeout(G,0);else G()}if(Object.keys($.change).length)Q$(()=>{for(let G in $.change){let X=$.change[G];if(!this.#G(G,X))continue;let Z=this.#J.get(G);if(U$(`list item "${G}"`,X,Z))Z.set(X)}}),M(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let G in $.remove)this.remove(G);M(this.#$.remove,Object.keys($.remove))}return this.#Q=!1,$.changed}clear(){let $=Array.from(this.#J.keys());return this.#J.clear(),this.#X.clear(),M(this.#$.remove,$),!0}on($,J){if(this.#$[$].add(J),$==="change"&&!this.#X.size){this.#Q=!0;for(let G of this.#J.keys())this.#z(G);this.#Q=!1}return()=>{if(this.#$[$].delete(J),$==="change"&&!this.#$.change.size){if(this.#X.size){for(let G of this.#X.values())G.stop();this.#X.clear()}}}}}var B$="List";class A${#G;#J=new Set;#X={sort:new Set};#$=[];#Q;constructor($,J){U("list",$,Array.isArray);let G=0;this.#Q=i(J)?()=>`${J}${G++}`:F(J)?(X)=>J(X):()=>String(G++),this.#G=new u(this.#z($),(X,Z)=>{return U(`list for key "${X}"`,Z),!0})}#z($){let J={};for(let G=0;G<$.length;G++){let X=$[G];if(X===void 0)continue;let Z=this.#$[G];if(!Z)Z=this.#Q(X),this.#$[G]=Z;J[Z]=X}return J}get#Z(){return this.#$.map(($)=>this.#G.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return B$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let J=this.#G.get($);if(J)yield J}}get length(){return K(this.#J),this.#$.length}get(){return K(this.#J),this.#Z}set($){if(H===$){this.#G.clear(),B(this.#J),this.#J.clear();return}let J=this.#Z,G=n(this.#z(J),this.#z($)),X=Object.keys(G.remove);if(this.#G.change(G)){for(let Q of X){let z=this.#$.indexOf(Q);if(z!==-1)this.#$.splice(z,1)}this.#$=this.#$.filter(()=>!0),B(this.#J)}}update($){this.set($(this.get()))}at($){return this.#G.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#G.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let J=this.#Q($);if(this.#G.has(J))throw new g("store",J,$);if(!this.#$.includes(J))this.#$.push(J);if(this.#G.add(J,$))B(this.#J);return J}remove($){let J=l($)?this.#$[$]:$;if(this.#G.remove(J)){let X=l($)?$:this.#$.indexOf(J);if(X>=0)this.#$.splice(X,1);this.#$=this.#$.filter(()=>!0),B(this.#J)}}sort($){let G=this.#$.map((X)=>[X,this.#G.get(X)?.get()]).sort(F($)?(X,Z)=>$(X[1],Z[1]):(X,Z)=>String(X[1]).localeCompare(String(Z[1]))).map(([X])=>X);if(!P(this.#$,G))this.#$=G,B(this.#J),M(this.#X.sort,this.#$)}splice($,J,...G){let X=this.#$.length,Z=$<0?Math.max(0,X+$):Math.min($,X),Q=Math.max(0,Math.min(J??Math.max(0,X-Math.max(0,Z)),X-Z)),z={},q={};for(let _=0;_<Q;_++){let A=Z+_,C=this.#$[A];if(C){let W=this.#G.get(C);if(W)q[C]=W.get()}}let Y=this.#$.slice(0,Z);for(let _ of G){let A=this.#Q(_);Y.push(A),z[A]=_}Y.push(...this.#$.slice(Z+Q));let S=!!(Object.keys(z).length||Object.keys(q).length);if(S)this.#G.change({add:z,change:{},remove:q,changed:S}),this.#$=Y.filter(()=>!0),B(this.#J);return Object.values(q)}on($,J){if($==="sort")return this.#X.sort.add(J),()=>this.#X.sort.delete(J);return this.#G.on($,J)}deriveCollection($){return J$(this,$)}}var $$=($,J)=>{let G=new A$($,J),X=(Z)=>{let Q=Number(Z);return Number.isInteger(Q)&&Q>=0?G.at(Q):G.byKey(Z)};return new Proxy(G,{get(Z,Q){if(Q in Z){let z=Reflect.get(Z,Q);return F(z)?z.bind(Z):z}return!D(Q)?X(Q):void 0},has(Z,Q){if(Q in Z)return!0;return!D(Q)?X(Q)!==void 0:!1},ownKeys(Z){return Object.getOwnPropertyNames(Z.keys())},getOwnPropertyDescriptor(Z,Q){if(D(Q))return;if(Q==="length")return{enumerable:!1,configurable:!1,writable:!1,value:Z.length};let z=Number(Q);if(Number.isInteger(z)&&z>=0&&z<Z.length){let q=Z.at(z);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}return}})},F$=($)=>L($,B$);var K$="State";class y{#G=new Set;#J;constructor($){U("state",$),this.#J=$}get[Symbol.toStringTag](){return K$}get(){return K(this.#G),this.#J}set($){if(U("state",$),P(this.#J,$))return;if(this.#J=$,B(this.#G),H===this.#J)this.#G.clear()}update($){d("state update",$),this.set($(this.#J))}}var C$=($)=>new y($),G$=($)=>L($,K$);var M$="Store";class D${#G;#J=new Set;constructor($){U("store",$,T),this.#G=new u($,(J,G)=>{return U(`store for key "${J}"`,G),!0})}get#X(){let $={};for(let[J,G]of this.#G.entries())$[J]=G.get();return $}get[Symbol.toStringTag](){return M$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,J]of this.#G.entries())yield[$,J]}get(){return K(this.#J),this.#X}set($){if(H===$){this.#G.clear(),B(this.#J),this.#J.clear();return}let J=this.#X;if(this.#G.change(n(J,$)))B(this.#J)}keys(){return this.#G.keys()}byKey($){return this.#G.get($)}update($){this.set($(this.get()))}add($,J){if(this.#G.has($))throw new g("store",$,J);if(this.#G.add($,J))B(this.#J);return $}remove($){if(this.#G.remove($))B(this.#J)}on($,J){return this.#G.on($,J)}}var X$=($)=>{let J=new D$($);return new Proxy(J,{get(G,X){if(X in G){let Z=Reflect.get(G,X);return F(Z)?Z.bind(G):Z}if(!D(X))return G.byKey(X)},has(G,X){if(X in G)return!0;return G.byKey(String(X))!==void 0},ownKeys(G){return Array.from(G.keys())},getOwnPropertyDescriptor(G,X){if(X in G)return Reflect.getOwnPropertyDescriptor(G,X);if(D(X))return;let Z=G.byKey(String(X));return Z?{enumerable:!0,configurable:!0,writable:!0,value:Z}:void 0}})},Z$=($)=>L($,M$);var W$=($)=>G$($)||q$($)||Z$($),I$=($)=>G$($)||Z$($)||F$($);function O$($){if(a($))return new h($);if(e($))return new v($);if(H$($))return $$($);if(T($))return X$($);return new y($)}function j$($){if(H$($))return $$($);if(T($))return X$($);return new y($)}class N extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class g extends Error{constructor($,J,G){super(`Could not add ${$} key "${J}"${G?` with value ${b(G)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class m extends TypeError{constructor($,J){super(`Invalid ${$} callback ${b(J)}`);this.name="InvalidCallbackError"}}class L$ extends TypeError{constructor($,J){super(`Invalid signal value ${b(J)} in ${$}`);this.name="InvalidSignalValueError"}}class o extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class Y$ extends Error{constructor($,J){super(`Could not set ${$} to ${b(J)} because signal is read-only`);this.name="ReadonlySignalError"}}var d=($,J,G=F)=>{if(!G(J))throw new m($,J)},U=($,J,G=()=>!(D(J)&&J!==H)||F(J))=>{if(J==null)throw new o($);if(!G(J))throw new L$($,J)},U$=($,J,G)=>{if(!I$(G))throw new Y$($,J);return!0};var P=($,J,G)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!z$($)||!z$(J))return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(J))throw new N("isEqual");G.add($),G.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let X=0;X<$.length;X++)if(!P($[X],J[X],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(T($)&&T(J)){let X=Object.keys($),Z=Object.keys(J);if(X.length!==Z.length)return!1;for(let Q of X){if(!(Q in J))return!1;if(!P($[Q],J[Q],G))return!1}return!0}return!1}finally{G.delete($),G.delete(J)}},n=($,J)=>{let G=t($),X=t(J);if(!G||!X){let A=!Object.is($,J);return{changed:A,add:A&&X?J:{},change:{},remove:A&&G?$:{}}}let Z=new WeakSet,Q={},z={},q={},Y=Object.keys($),S=Object.keys(J),_=new Set([...Y,...S]);for(let A of _){let C=A in $,W=A in J;if(!C&&W){Q[A]=J[A];continue}else if(C&&!W){q[A]=H;continue}let s=$[A],k=J[A];if(!P(s,k,Z))z[A]=k}return{add:Q,change:z,remove:q,changed:!!(Object.keys(Q).length||Object.keys(z).length||Object.keys(q).length)}};var f$="Computed",P$=($,J=H)=>{if(!E$($))throw new m("computed",$);if(J==null)throw new o("computed");let G=new Set,X=J,Z,Q,z=!0,q=!1,Y=!1,S=(I)=>{if(!P(I,X))X=I,q=!0;Z=void 0,z=!1},_=()=>{q=H!==X,X=H,Z=void 0},A=(I)=>{let O=j(I);q=!Z||O.name!==Z.name||O.message!==Z.message,X=H,Z=O},C=(I)=>(O)=>{if(Y=!1,Q=void 0,I(O),q)B(G)},W=x(()=>{if(z=!0,Q?.abort(),G.size)B(G);else W.stop()});W.onCleanup(()=>{Q?.abort()});let s=()=>R(W,()=>{if(Y)throw new N("computed");if(q=!1,f($)){if(Q)return X;Q=new AbortController,Q.signal.addEventListener("abort",()=>{Y=!1,Q=void 0,s()},{once:!0})}let I;Y=!0;try{I=Q?$(X,Q.signal):$(X)}catch(O){if(E(O))_();else A(O);Y=!1;return}if(I instanceof Promise)I.then(C(S),C(A));else if(I==null||H===I)_();else S(I);Y=!1}),k={};return Object.defineProperties(k,{[Symbol.toStringTag]:{value:f$},get:{value:()=>{if(K(G),V(),z)s();if(Z)throw Z;return X}}}),k};var E$=($)=>F($)&&$.length<3;var x$="Collection",_$=($)=>$.length===2;class N${#G=new Set;#J;#X;#$=new Map;#Q=new Map;#z={add:new Set,change:new Set,remove:new Set,sort:new Set};#Z=[];constructor($,J){this.#J=$,this.#X=J;for(let G=0;G<this.#J.length;G++){let X=this.#J.keyAt(G);if(!X)continue;this.#H(X)}this.#J.on("add",(G)=>{for(let X of G)if(!this.#$.has(X)){this.#H(X);let Z=this.#$.get(X);if(Z&&_$(this.#X))Z.get()}B(this.#G),M(this.#z.add,G)}),this.#J.on("remove",(G)=>{for(let X of G){if(!this.#$.has(X))continue;this.#$.delete(X);let Z=this.#Z.indexOf(X);if(Z>=0)this.#Z.splice(Z,1);this.#A(X)}this.#Z=this.#Z.filter(()=>!0),B(this.#G),M(this.#z.remove,G)}),this.#J.on("sort",(G)=>{this.#Z=[...G],B(this.#G),M(this.#z.sort,G)})}get#q(){return this.#Z.map(($)=>this.#$.get($)?.get()).filter(($)=>$!=null&&$!==H)}#H($){let J=_$(this.#X)?async(X,Z)=>{let Q=this.#J.byKey($);if(!Q)return H;let z=Q.get();return this.#X(z,Z)}:()=>{let X=this.#J.byKey($);if(!X)return H;let Z=X.get();return this.#X(Z)},G=P$(J);if(this.#$.set($,G),!this.#Z.includes($))this.#Z.push($);if(this.#z.change.size)this.#B($);return!0}#B($){let J=x(()=>{R(J,()=>{this.#$.get($)?.get()})});this.#Q.set($,J),J()}#A($){let J=this.#Q.get($);if(J)J.stop(),this.#Q.delete($)}get[Symbol.toStringTag](){return x$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#Z){let J=this.#$.get($);if(J)yield J}}get length(){return K(this.#G),this.#Z.length}get(){return K(this.#G),this.#q}at($){return this.#$.get(this.#Z[$])}keys(){return this.#Z.values()}byKey($){return this.#$.get($)}keyAt($){return this.#Z[$]}indexOfKey($){return this.#Z.indexOf($)}on($,J){if(this.#z[$].add(J),$==="change"&&!this.#Q.size)for(let G of this.#$.keys())this.#B(G);return()=>{if(this.#z[$].delete(J),$==="change"&&!this.#z.change.size){if(this.#Q.size){for(let G of this.#Q.values())G.stop();this.#Q.clear()}}}}deriveCollection($){return J$(this,$)}}function J$($,J){let G=new N$($,J),X=(Z)=>{let Q=Number(Z);return Number.isInteger(Q)&&Q>=0?G.at(Q):G.byKey(Z)};return new Proxy(G,{get(Z,Q){if(Q in Z){let z=Reflect.get(Z,Q);return F(z)?z.bind(Z):z}if(!D(Q))return X(Q)},has(Z,Q){if(Q in Z)return!0;return!D(Q)?X(Q)!==void 0:!1},ownKeys(Z){return Object.getOwnPropertyNames(Z.keys())},getOwnPropertyDescriptor(Z,Q){if(D(Q))return;if(Q==="length")return{enumerable:!1,configurable:!1,writable:!1,value:Z.length};let z=Number(Q);if(Number.isInteger(z)&&z>=0&&z<Z.length){let q=Z.at(z);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}return}})}var S$=($)=>L($,x$);var V$=($)=>{if(!F($)||$.length>1)throw new m("effect",$);let J=f($),G=!1,X,Z=x(()=>R(Z,()=>{if(G)throw new N("effect");G=!0,X?.abort(),X=void 0;let Q;try{if(J){X=new AbortController;let z=X;$(X.signal).then((q)=>{if(F(q)&&X===z)Z.onCleanup(q)}).catch((q)=>{if(!E(q))console.error("Async effect error:",q)})}else if(Q=$(),F(Q))Z.onCleanup(Q)}catch(z){if(!E(z))console.error("Effect callback error:",z)}G=!1}));return Z(),()=>{X?.abort(),Z.stop()}};function m$($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(G){if(J.err&&(!$.errors||!$.errors.includes(j(G))))J.err($.errors?[...$.errors,j(G)]:[j(G)]);else throw G}}function w$($){let J=[],G=!1,X={};for(let[Z,Q]of Object.entries($))try{let z=Q.get();if(z===H)G=!0;else X[Z]=z}catch(z){J.push(j(z))}if(G)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:X}}export{b as valueString,R as trackSignalReads,j as toError,K as subscribeActiveWatcher,w$ as resolve,B as notifyWatchers,m$ as match,e as isTaskCallback,D as isSymbol,i as isString,Z$ as isStore,G$ as isState,W$ as isSignal,t as isRecordOrArray,T as isRecord,L as isObjectOfType,l as isNumber,I$ as isMutableSignal,a as isMemoCallback,F$ as isList,F as isFunction,P as isEqual,q$ as isComputed,S$ as isCollection,f as isAsyncFunction,E as isAbortError,V as flushPendingReactions,M as emitNotification,n as diff,x as createWatcher,X$ as createStore,C$ as createState,O$ as createSignal,$$ as createList,V$ as createEffect,T$ as createComputed,J$ as createCollection,Q$ as batchSignalWrites,H as UNSET,v as Task,M$ as TYPE_STORE,K$ as TYPE_STATE,B$ as TYPE_LIST,r as TYPE_COMPUTED,x$ as TYPE_COLLECTION,y as State,Y$ as ReadonlySignalError,o as NullishSignalValueError,h as Memo,L$ as InvalidSignalValueError,m as InvalidCallbackError,g as DuplicateKeyError,N as CircularDependencyError,D$ as BaseStore,A$ as BaseList};
