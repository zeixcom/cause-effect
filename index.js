var Y=($)=>typeof $==="function",w=($)=>Y($)&&$.constructor.name==="AsyncFunction",h=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,u=($)=>$ instanceof Error,D=($)=>$ instanceof DOMException&&$.name==="AbortError",o=($)=>$ instanceof Promise,q=($)=>u($)?$:Error(String($));class x extends Error{constructor($){super(`Circular dependency in ${$} detected`);return this}}var O,U=new Set,E=0,g=new Map,k,s=()=>{k=void 0;let $=Array.from(g.values());g.clear();for(let B of $)B()},t=()=>{if(k)cancelAnimationFrame(k);k=requestAnimationFrame(s)};queueMicrotask(s);var M=($)=>{if(O&&!$.has(O)){let B=O;$.add(B),O.cleanups.add(()=>{$.delete(B)})}},V=($)=>{for(let B of $)if(E)U.add(B);else B()},P=()=>{while(U.size){let $=Array.from(U);U.clear();for(let B of $)B()}},r=($)=>{E++;try{$()}finally{P(),E--}},R=($,B)=>{let G=O;O=B;try{$()}finally{O=G}},a=($,B)=>new Promise((G,z)=>{g.set(B||Symbol(),()=>{try{G($())}catch(J){z(J)}}),t()});function F($){let{signals:B,ok:G,err:z=console.error,nil:J=()=>{}}=Y($)?{signals:[],ok:$}:$,X=!1,L=()=>R(()=>{if(X)throw new x("effect");X=!0;let W=void 0;try{let Z=[],K=!1,_=B.map((A)=>{try{let j=A.get();if(j===Q)K=!0;return j}catch(j){if(D(j))throw j;return Z.push(q(j)),Q}});try{W=K?J():Z.length?z(...Z):G(..._)}catch(A){if(D(A))throw A;let j=q(A);W=z(j)}}catch(Z){z(q(Z))}if(Y(W))L.cleanups.add(W);X=!1},L);return L.cleanups=new Set,L(),()=>{L.cleanups.forEach((W)=>W()),L.cleanups.clear()}}var S=($)=>{let B=new Set,G=Q,z,J=!0,X=!1,L=()=>{if(J=!0,B.size)V(B);else L.cleanups.forEach((K)=>K()),L.cleanups.clear()};L.cleanups=new Set;let W=()=>R(()=>{if(X)throw new x("memo");X=!0;try{let K=$();if(K==null||Q===K)G=Q,z=void 0;else G=K,J=!1,z=void 0}catch(K){G=Q,z=K instanceof Error?K:new Error(String(K))}finally{X=!1}},L),Z={[Symbol.toStringTag]:N,get:()=>{if(M(B),P(),J)W();if(z)throw z;return G},map:(K)=>y(Z,K),tap:(K)=>F({signals:[Z],...typeof K==="function"?{ok:K}:K})};return Z};var b=($)=>{let B=new Set,G=Q,z,J=!0,X=!1,L=!1,W,Z=(H)=>{if(!Object.is(H,G))G=H,J=!1,z=void 0,X=!0},K=()=>{X=Q!==G,G=Q,z=void 0},_=(H)=>{let I=q(H);X=!(z&&I.name===z.name&&I.message===z.message),G=Q,z=I},A=(H)=>{if(L=!1,W=void 0,Z(H),X)V(B)},j=(H)=>{if(L=!1,W=void 0,_(H),X)V(B)},c=()=>{L=!1,W=void 0,m()},C=()=>{if(J=!0,W?.abort("Aborted because source signal changed"),B.size)V(B);else C.cleanups.forEach((H)=>H()),C.cleanups.clear()};C.cleanups=new Set;let m=()=>R(()=>{if(L)throw new x("task");X=!1,W=new AbortController,W.signal.addEventListener("abort",c,{once:!0});let H;L=!0;try{H=$(W.signal)}catch(I){if(D(I))K();else _(I);L=!1;return}if(o(H))H.then(A,j);else if(H==null||Q===H)K();else Z(H);L=!1},C),T={[Symbol.toStringTag]:N,get:()=>{if(M(B),P(),J)m();if(z)throw z;return G},map:(H)=>y(T,H),tap:(H)=>F({signals:[T],...typeof H==="function"?{ok:H}:H})};return T};var N="Computed",d=($)=>w($)?b($):S($),y=($,B)=>w(B)?b(()=>B($.get())):S(()=>B($.get())),p=($)=>{if(!$||typeof $!=="object")return!1;return $[Symbol.toStringTag]===N};var i="State",f=($)=>{let B=new Set,G=$,z={[Symbol.toStringTag]:i,get:()=>{return M(B),G},set:(J)=>{if(Object.is(G,J))return;if(G=J,V(B),Q===G)B.clear()},update:(J)=>{z.set(J(G))},map:(J)=>y(z,J),tap:(J)=>F({signals:[z],...typeof J==="function"?{ok:J}:J})};return z},v=($)=>h($,i);var Q=Symbol(),n=($)=>v($)||p($),l=($)=>Y($)&&$.length<2,e=($)=>n($)?$:l($)?d($):f($);export{R as watch,e as toSignal,b as task,f as state,S as memo,v as isState,n as isSignal,l as isComputedCallback,p as isComputed,a as enqueue,F as effect,d as computed,r as batch,Q as UNSET,x as CircularDependencyError};
