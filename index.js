var R,b=new Set,p=0,v=new Map,k,$$=()=>{k=void 0;let $=Array.from(v.values());v.clear();for(let G of $)G()},J$=()=>{if(k)cancelAnimationFrame(k);k=requestAnimationFrame($$)};queueMicrotask($$);var N=($)=>{let G=new Set,B=$;return B.off=(L)=>{G.add(L)},B.cleanup=()=>{for(let L of G)L();G.clear()},B},P=($)=>{if(R&&!$.has(R)){let G=R;$.add(G),R.off(()=>{$.delete(G)})}},q=($)=>{for(let G of $)if(p)b.add(G);else G()},g=()=>{while(b.size){let $=Array.from(b);b.clear();for(let G of $)G()}},L$=($)=>{p++;try{$()}finally{g(),p--}},m=($,G)=>{let B=R;R=G;try{$()}finally{R=B}},Q$=($,G)=>new Promise((B,L)=>{v.set(G||Symbol(),()=>{try{B($())}catch(Q){L(Q)}}),J$()});var I=($)=>typeof $==="function",E=($)=>I($)&&$.constructor.name==="AsyncFunction",Y=($,G)=>Object.prototype.toString.call($)===`[object ${G}]`,B$=($)=>!Y($,"Object")&&!Array.isArray($)&&!I($),G$=($,G)=>(G in $)&&I($[G]),_=($)=>$ instanceof DOMException&&$.name==="AbortError",K=($)=>$ instanceof Error?$:Error(String($));class V extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var n="State",T=($)=>{let G=new Set,B=$,L={[Symbol.toStringTag]:n,get:()=>{return P(G),B},set:(Q)=>{if(Object.is(B,Q))return;if(B=Q,q(G),W===B)G.clear()},update:(Q)=>{L.set(Q(B))}};return L},f=($)=>Y($,n);var c="Store",y=($)=>{let G=new Set,B=new Map,L=(z)=>{let J=new Set;if(z)J.add(z);let F={};return{get:()=>{P(J);let j={...F};return F={},j},merge:(j)=>{F={...F,...j},q(J)}}},Q=L(),C=N(()=>{let z=Object.keys(Q.get());console.log("Additions watcher called",z);for(let J of z)B.get(J)}),x=L(C),H=L(),S=T(0),O=()=>{let z={};for(let[J,F]of B)z[J]=F.get();return z},U=(z,J)=>{let F=new Set(Object.keys(z)),j=new Set(Object.keys(J)),Z=new Set([...F,...j]),X={additions:{},mutations:{},removals:{}};for(let A of Z){let a=F.has(A),e=j.has(A),D=J[A];if(a&&!e)B.delete(A),X.removals[A]=W;else if(!a&&e){let M=i(D);B.set(A,M),X.additions[A]=D}else{console.log(A,z[A],D);let M=B.get(A);if(f(M)&&B$(D)||w(M)&&(Y(D,"Object")||Array.isArray(D)))M.set(D);else{if(M&&G$(M,"set"))M.set(W);B.set(A,i(D))}X.mutations[A]=D}}let t=Object.keys(X.additions).length>0,l=Object.keys(X.mutations).length>0,r=Object.keys(X.removals).length>0;if(t)Q.merge(X.additions);if(l)x.merge(X.mutations);if(r)H.merge(X.removals);return S.set(B.size),t||l||r};return U({},$),new Proxy({},{get(z,J){let F=String(J);if(J===Symbol.toStringTag)return c;if(J===Symbol.iterator)return function*(){for(let[j,Z]of B)yield[j,Z]};if(J==="get")return()=>{return P(G),O()};if(J==="set")return(j)=>{if(U(O(),j)){if(q(G),W===j)G.clear()}};if(J==="update")return(j)=>{let Z=O(),X=j(Z);if(U(Z,X)){if(q(G),W===X)G.clear()}};if(J==="additions")return Q;if(J==="mutations")return x;if(J==="removals")return H;if(J==="size")return S;return B.get(F)},has(z,J){let F=String(J);return B.has(F)||J==="get"||J==="set"||J==="update"||J==="additions"||J==="mutations"||J==="removals"||J==="size"||J===Symbol.toStringTag||J===Symbol.iterator},ownKeys(){return Array.from(B.keys())},getOwnPropertyDescriptor(z,J){let F=B.get(String(J));return F?{enumerable:!0,configurable:!0,writable:!0,value:F}:void 0}})},w=($)=>Y($,c);var W=Symbol(),o=($)=>f($)||s($)||w($);function X$($){if(o($))return $;if(d($))return h($);if(Array.isArray($)){let G={};for(let B=0;B<$.length;B++)G[String(B)]=$[B];return y(G)}if(Y($,"Object"))return y($);return T($)}function i($){if(o($))return $;if(d($))return h($);if(Array.isArray($)){let G={};for(let B=0;B<$.length;B++)G[String(B)]=$[B];return y(G)}if(Y($,"Object"))return y($);return T($)}var u="Computed",h=($)=>{let G=new Set,B=W,L,Q,C=!0,x=!1,H=!1,S=(Z)=>{if(!Object.is(Z,B))B=Z,x=!0;L=void 0,C=!1},O=()=>{x=W!==B,B=W,L=void 0},U=(Z)=>{let X=K(Z);x=!L||X.name!==L.name||X.message!==L.message,B=W,L=X},z=(Z)=>(X)=>{if(H=!1,Q=void 0,Z(X),x)q(G)},J=N(()=>{if(C=!0,Q?.abort(),G.size)q(G);else J.cleanup()});J.off(()=>{Q?.abort()});let F=()=>m(()=>{if(H)throw new V("computed");if(x=!1,E($)){if(Q)return B;Q=new AbortController,Q.signal.addEventListener("abort",()=>{H=!1,Q=void 0,F()},{once:!0})}let Z;H=!0;try{Z=Q?$(Q.signal):$()}catch(X){if(_(X))O();else U(X);H=!1;return}if(Z instanceof Promise)Z.then(z(S),z(U));else if(Z==null||W===Z)O();else S(Z);H=!1},J);return{[Symbol.toStringTag]:u,get:()=>{if(P(G),g(),C)F();if(L)throw L;return B}}},s=($)=>Y($,u),d=($)=>I($)&&$.length<2;var Z$=($)=>{let G=E($),B=!1,L,Q=N(()=>m(()=>{if(B)throw new V("effect");B=!0,L?.abort(),L=void 0;let C;try{if(G){L=new AbortController;let x=L;$(L.signal).then((H)=>{if(I(H)&&L===x)Q.off(H)}).catch((H)=>{if(!_(H))console.error("Async effect error:",H)})}else if(C=$(),I(C))Q.off(C)}catch(x){if(!_(x))console.error("Effect callback error:",x)}B=!1},Q));return Q(),()=>{L?.abort(),Q.cleanup()}};function F$($,G){try{if($.pending)G.nil?.();else if($.errors)G.err?.($.errors);else G.ok?.($.values)}catch(B){if(G.err&&(!$.errors||!$.errors.includes(K(B)))){let L=$.errors?[...$.errors,K(B)]:[K(B)];G.err(L)}else throw B}}function x$($){let G=[],B=!1,L={};for(let[Q,C]of Object.entries($))try{let x=C.get();if(x===W)B=!0;else L[Q]=x}catch(x){G.push(K(x))}if(B)return{ok:!1,pending:!0};if(G.length>0)return{ok:!1,errors:G};return{ok:!0,values:L}}export{N as watch,X$ as toSignal,K as toError,P as subscribe,y as store,T as state,x$ as resolve,m as observe,q as notify,F$ as match,w as isStore,f as isState,o as isSignal,I as isFunction,d as isComputedCallback,s as isComputed,E as isAsyncFunction,_ as isAbortError,g as flush,Q$ as enqueue,Z$ as effect,h as computed,L$ as batch,W as UNSET,c as TYPE_STORE,n as TYPE_STATE,u as TYPE_COMPUTED,V as CircularDependencyError};
