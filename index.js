class p extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class w extends TypeError{constructor($,z){super(`Invalid ${$} callback ${z}`);this.name="InvalidCallbackError"}}class a extends TypeError{constructor($,z){super(`Invalid signal value ${z} in ${$}`);this.name="InvalidSignalValueError"}}class j extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class e extends Error{constructor($,z){super(`Could not add store key "${$}" with value ${z} because it already exists`);this.name="StoreKeyExistsError"}}class $$ extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class B$ extends Error{constructor($,z){super(`Could not set store key "${$}" to ${z} because it is readonly`);this.name="StoreKeyReadonlyError"}}var Y=Symbol(),J$=($)=>typeof $==="string",R$=($)=>typeof $==="number",s=($)=>typeof $==="symbol",U=($)=>typeof $==="function",i=($)=>U($)&&$.constructor.name==="AsyncFunction",b=($,z)=>Object.prototype.toString.call($)===`[object ${z}]`,E=($)=>b($,"Object"),z$=($)=>E($)||Array.isArray($);var n=($)=>$ instanceof DOMException&&$.name==="AbortError",m=($)=>$ instanceof Error?$:Error(String($)),C=($)=>J$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var g=($,z,G)=>{if(Object.is($,z))return!0;if(typeof $!==typeof z)return!1;if(typeof $!=="object"||$===null||z===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(z))throw new p("isEqual");G.add($),G.add(z);try{if(Array.isArray($)&&Array.isArray(z)){if($.length!==z.length)return!1;for(let Q=0;Q<$.length;Q++)if(!g($[Q],z[Q],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(z))return!1;if(E($)&&E(z)){let Q=Object.keys($),X=Object.keys(z);if(Q.length!==X.length)return!1;for(let H of Q){if(!(H in z))return!1;if(!g($[H],z[H],G))return!1}return!0}return!1}finally{G.delete($),G.delete(z)}},q$=($,z)=>{let G=z$($),Q=z$(z);if(!G||!Q){let D=!Object.is($,z);return{changed:D,add:D&&Q?z:{},change:{},remove:D&&G?$:{}}}let X=new WeakSet,H={},R={},I={},Z=Object.keys($),S=Object.keys(z),O=new Set([...Z,...S]);for(let D of O){let A=D in $,V=D in z;if(!A&&V){H[D]=z[D];continue}else if(A&&!V){I[D]=Y;continue}let f=$[D],F=z[D];if(!g(f,F,X))R[D]=F}return{changed:Object.keys(H).length>0||Object.keys(R).length>0||Object.keys(I).length>0,add:H,change:R,remove:I}};var c,G$=new Set,x$=0,k=($)=>{let z=new Set,G=$;return G.unwatch=(Q)=>{z.add(Q)},G.cleanup=()=>{for(let Q of z)Q();z.clear()},G},y=($)=>{if(c&&!$.has(c)){let z=c;z.unwatch(()=>{$.delete(z)}),$.add(z)}},_=($)=>{for(let z of $)if(x$)G$.add(z);else z()},M$=()=>{while(G$.size){let $=Array.from(G$);G$.clear();for(let z of $)z()}},Y$=($)=>{x$++;try{$()}finally{M$(),x$--}},h=($,z)=>{let G=c;c=z;try{$()}finally{c=G}};var D$="Computed",F$=($,z=Y)=>{if(!Q$($))throw new w("computed",C($));if(z==null)throw new j("computed");let G=new Set,Q=z,X,H,R=!0,I=!1,Z=!1,S=(F)=>{if(!g(F,Q))Q=F,I=!0;X=void 0,R=!1},O=()=>{I=Y!==Q,Q=Y,X=void 0},v=(F)=>{let P=m(F);I=!X||P.name!==X.name||P.message!==X.message,Q=Y,X=P},D=(F)=>(P)=>{if(Z=!1,H=void 0,F(P),I)_(G)},A=k(()=>{if(R=!0,H?.abort(),G.size)_(G);else A.cleanup()});A.unwatch(()=>{H?.abort()});let V=()=>h(()=>{if(Z)throw new p("computed");if(I=!1,i($)){if(H)return Q;H=new AbortController,H.signal.addEventListener("abort",()=>{Z=!1,H=void 0,V()},{once:!0})}let F;Z=!0;try{F=H?$(Q,H.signal):$(Q)}catch(P){if(n(P))O();else v(P);Z=!1;return}if(F instanceof Promise)F.then(D(S),D(v));else if(F==null||Y===F)O();else S(F);Z=!1},A),f={};return Object.defineProperties(f,{[Symbol.toStringTag]:{value:D$},get:{value:()=>{if(y(G),M$(),R)V();if(X)throw X;return Q}}}),f},t=($)=>b($,D$),Q$=($)=>U($)&&$.length<3;var _$=($)=>{if(!U($)||$.length>1)throw new w("effect",C($));let z=i($),G=!1,Q,X=k(()=>h(()=>{if(G)throw new p("effect");G=!0,Q?.abort(),Q=void 0;let H;try{if(z){Q=new AbortController;let R=Q;$(Q.signal).then((I)=>{if(U(I)&&Q===R)X.unwatch(I)}).catch((I)=>{if(!n(I))console.error("Async effect error:",I)})}else if(H=$(),U(H))X.unwatch(H)}catch(R){if(!n(R))console.error("Effect callback error:",R)}G=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function P$($,z){try{if($.pending)z.nil?.();else if($.errors)z.err?.($.errors);else if($.ok)z.ok($.values)}catch(G){if(z.err&&(!$.errors||!$.errors.includes(m(G))))z.err($.errors?[...$.errors,m(G)]:[m(G)]);else throw G}}function T$($){let z=[],G=!1,Q={};for(let[X,H]of Object.entries($))try{let R=H.get();if(R===Y)G=!0;else Q[X]=R}catch(R){z.push(m(R))}if(G)return{ok:!1,pending:!0};if(z.length>0)return{ok:!1,errors:z};return{ok:!0,values:Q}}var I$="State",l=($)=>{if($==null)throw new j("state");let z=new Set,G=$,Q=(H)=>{if(H==null)throw new j("state");if(g(G,H))return;if(G=H,_(z),Y===G)z.clear()},X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:I$},get:{value:()=>{return y(z),G}},set:{value:(H)=>{Q(H)}},update:{value:(H)=>{if(!U(H))throw new w("state update",C(H));Q(H(G))}}}),X},u=($)=>b($,I$);var A$="Store",X$=($,z)=>{if($==null)throw new j("store");let G=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,H=new Map,R=Array.isArray($),I=0,Z=[],S=(B)=>{let J=B;if(R){let M=Number(B);if(Number.isInteger(M)&&M>=0)J=Z[M]??B}return X.get(J)},O=(B)=>{if(!R)return"";let J=I++;return J$(z)?`${z}${J}`:U(z)?z(B):String(J)},v=(B)=>{if(!Array.isArray(B))return B;let J={};for(let M=0;M<B.length;M++){let q=B[M];if(q===void 0)continue;let x=Z[M];if(!x)x=O(q),Z[M]=x;J[x]=q}return J},D=()=>{if(R)return Z.map((J)=>X.get(J)?.get()).filter((J)=>J!==void 0);let B={};for(let J of Z){let M=X.get(J);if(M)B[J]=M.get()}return B},A=(B,J)=>{Object.freeze(J);for(let M of Q[B])M(J)},V=(B,J)=>{if(J==null)throw new j(`store for key "${B}"`);if(J===Y)return!0;if(s(J)||U(J)||t(J))throw new a(`store for key "${B}"`,C(J));return!0},f=(B,J,M=!1)=>{if(!V(B,J))return!1;let q=u(J)||r(J)?J:E(J)||Array.isArray(J)?X$(J):l(J);if(X.set(B,q),!Z.includes(B))Z.push(B);let x=k(()=>h(()=>{A("change",{[B]:q.get()})},x));if(x(),H.set(B,x),M)_(G),A("add",{[B]:J});return!0},F=(B,J=!1)=>{let M=Z.indexOf(B);if(M>=0){if(Z=[...Z.slice(0,M),...Z.slice(M+1)],J)Z=[...Z]}if(X.delete(B)){let x=H.get(B);if(x)x.cleanup();H.delete(B)}if(J)_(G),A("remove",{[B]:Y})},P=(B,J,M)=>{let q=R?v(B):B,x=R?v(J):J,L=q$(q,x);return Y$(()=>{if(Object.keys(L.add).length){for(let T in L.add){let W=L.add[T];if(W===void 0)continue;f(T,W??Y,!1)}if(M)setTimeout(()=>{A("add",L.add)},0);else A("add",L.add)}if(Object.keys(L.change).length){for(let T in L.change){let W=L.change[T];if(!V(T,W))continue;let o=X.get(T);if(L$(o))o.set(W);else throw new B$(T,C(W))}A("change",L.change)}if(Object.keys(L.remove).length){for(let T in L.remove)F(T);Z=Z.filter(()=>!0),A("remove",L.remove)}}),L.changed};P(R?[]:{},$,!0);let K$={};return Object.defineProperties(K$,{[Symbol.toStringTag]:{value:A$},[Symbol.isConcatSpreadable]:{value:R},[Symbol.iterator]:{value:R?function*(){let B=Z.keys();for(let J of B){let M=Z[J];if(M)yield X.get(M)}}:function*(){for(let B of Z){let J=X.get(B);if(J)yield[B,J]}}},add:{value:R?(B)=>{let J=Z.length,M=O(B);Z[J]=M,f(M,B,!0)}:(B,J)=>{if(!X.has(B))f(B,J,!0);else throw new e(B,C(J))}},byKey:{value(B){return S(B)}},keyAt:{value(B){return Z[B]}},indexOfKey:{value(B){return Z.indexOf(B)}},get:{value:()=>{if(y(G),R)return Z.map((B)=>X.get(B)?.get()).filter((B)=>B!==void 0);else return D()}},remove:{value:(B)=>{let J=String(B);if(R&&R$(B)){if(!Z[B])throw new $$(B);J=Z[B]}if(X.has(J))F(J,!0)}},set:{value:(B)=>{if(P(D(),B)){if(_(G),Y===B)G.clear()}}},update:{value:(B)=>{let J=D(),M=B(J);if(P(J,M)){if(_(G),Y===M)G.clear()}}},sort:{value:(B)=>{Z=Z.map((M,q)=>{let x=X.get(M);return[q,M,x?x.get():void 0]}).sort(B?(M,q)=>B(M[2],q[2]):(M,q)=>String(M[2]).localeCompare(String(q[2]))).map(([M,q])=>q),_(G),A("sort",Z)}},splice:{value:(B,J,...M)=>{if(!R)throw Error("Cannot splice non-array-like object");let q=X.size;if(J===void 0)J=Math.max(0,q-Math.max(0,B));let x=B<0?Math.max(0,q+B):Math.min(B,q),L=Math.max(0,Math.min(J,q-x)),T=[],W=[],o=[...Z];for(let K=0;K<L;K++){let N=x+K,d=o[N];if(d){let N$=X.get(d);if(N$)T.push(N$.get()),W.push(d)}}W.forEach((K)=>{X.delete(K);let N=H.get(K);if(N)N.cleanup();H.delete(K)});let Z$=o.slice(0,x),H$=[];for(let K of M){let N=O(K);Z$.push(N),f(N,K,!1),H$.push(N)}if(Z$.push(...o.slice(x+L)),Z=Z$,W.length>0){let K={};W.forEach((N)=>{K[N]=Y}),A("remove",K)}if(H$.length>0){let K={};H$.forEach((N)=>{let d=X.get(N);if(d)K[N]=d.get()}),A("add",K)}return _(G),T}},on:{value:(B,J)=>{return Q[B].add(J),()=>Q[B].delete(J)}},length:{get(){return y(G),X.size}}}),new Proxy(K$,{get(B,J){if(J in B)return Reflect.get(B,J);if(!s(J))return S(J)},has(B,J){if(J in B)return!0;return X.has(String(J))},ownKeys(B){let J=Reflect.ownKeys(B);return[...new Set([...Z,...J])]},getOwnPropertyDescriptor(B,J){if(J in B)return Reflect.getOwnPropertyDescriptor(B,J);if(s(J))return;let M=S(J);return M?{enumerable:!0,configurable:!0,writable:!0,value:M}:void 0}})},r=($)=>b($,A$);var U$=($)=>u($)||t($)||r($),L$=($)=>u($)||r($);function W$($){if(U$($))return $;if(Q$($))return F$($);if(Array.isArray($)||E($))return X$($);return l($)}export{C as valueString,W$ as toSignal,m as toError,y as subscribe,T$ as resolve,h as observe,_ as notify,P$ as match,s as isSymbol,J$ as isString,r as isStore,u as isState,U$ as isSignal,z$ as isRecordOrArray,E as isRecord,b as isObjectOfType,R$ as isNumber,L$ as isMutableSignal,U as isFunction,g as isEqual,Q$ as isComputedCallback,t as isComputed,i as isAsyncFunction,n as isAbortError,M$ as flush,q$ as diff,k as createWatcher,X$ as createStore,l as createState,_$ as createEffect,F$ as createComputed,Y$ as batch,Y as UNSET,A$ as TYPE_STORE,I$ as TYPE_STATE,D$ as TYPE_COMPUTED,B$ as StoreKeyReadonlyError,$$ as StoreKeyRangeError,e as StoreKeyExistsError,j as NullishSignalValueError,a as InvalidSignalValueError,w as InvalidCallbackError,p as CircularDependencyError};
