function g($){return typeof $==="function"}function i($){return g($)&&$.constructor.name==="AsyncFunction"}function X$($){return g($)&&$.constructor.name!=="AsyncFunction"}function Y($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function L($){return Y($,"Object")}function Y$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function D$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class Z$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class A$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class o extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class j$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${D$(J)} is invalid`);this.name="InvalidSignalValueError"}}class b$ extends TypeError{constructor($,J){super(`[${$}] Callback ${D$(J)} is invalid`);this.name="InvalidCallbackError"}}class P$ extends Error{constructor($){super(`[${$}] Signal is read-only`);this.name="ReadonlySignalError"}}class G$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class e extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function C($,J,z){if(J==null)throw new A$($);if(z&&!z(J))throw new j$($,J)}function W$($,J){if(J==null)throw new o($)}function T($,J,z=g){if(!z(J))throw new b$($,J)}var c="State",u="Memo",d="Task",t="Sensor",E="List",l="Collection",r="Store",s="Slot",S=0,$$=1,G=2,U$=4,b=8,N=null,y=null,O$=[],x=0,_$=!1,k=($,J)=>$===J,L$=($,J)=>!1;function g$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function R($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,W=J.flags&U$;if(W){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let Q=$.sinksTail;if(Q?.sink===J&&(!W||g$(Q,J)))return;let D={source:$,sink:J,nextSource:X,prevSink:Q,nextSink:null};if(J.sourcesTail=$.sinksTail=D,z)z.nextSource=D;else J.sources=D;if(Q)Q.nextSink=D;else $.sinks=D}function k$($){let{source:J,nextSource:z,nextSink:X,prevSink:W}=$;if(X)X.prevSink=W;else J.sinksTail=W;if(W)W.nextSink=X;else J.sinks=X;if(!J.sinks){if(J.stop)J.stop(),J.stop=void 0;if("sources"in J&&J.sources){let Q=J;Q.sourcesTail=null,H$(Q)}}return z}function H$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=k$(z);if(J)J.nextSource=null;else $.sources=null}function F($,J=G){let z=$.flags;if("sinks"in $){if((z&(G|$$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)F(X.sink,$$)}else{if((z&(G|$$))>=J)return;let X=z&(G|$$);if($.flags=J,!X)O$.push($)}}function N$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)F(z.sink);if(x===0)I()}function J$($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function C$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function v$($){let J=N;N=$,$.sourcesTail=null,$.flags=U$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{N=J,H$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&$$)X.sink.flags|=G}$.flags=S}function c$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=N;N=$,$.sourcesTail=null,$.flags=U$;let X;try{X=$.fn($.value,J.signal)}catch(W){$.controller=void 0,$.error=W instanceof Error?W:Error(String(W));return}finally{N=z,H$($)}X.then((W)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(W,$.value)){$.value=W,$.error=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)F(Q.sink);if(x===0)I()}},(W)=>{if(J.signal.aborted)return;$.controller=void 0;let Q=W instanceof Error?W:Error(String(W));if(!$.error||Q.name!==$.error.name||Q.message!==$.error.message){$.error=Q;for(let D=$.sinks;D;D=D.nextSink)F(D.sink);if(x===0)I()}}),$.flags=S}function T$($){C$($);let J=N,z=y;N=y=$,$.sourcesTail=null,$.flags=U$;try{let X=$.fn();if(typeof X==="function")J$($,X)}finally{N=J,y=z,H$($)}$.flags=S}function w($){if($.flags&$$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)w(J.source);if($.flags&G)break}if($.flags&U$)throw new Z$("controller"in $?d:("value"in $)?u:"Effect");if($.flags&G)if("controller"in $)c$($);else if("value"in $)v$($);else T$($);else $.flags=S}function I(){if(_$)return;_$=!0;try{for(let $=0;$<O$.length;$++){let J=O$[$];if(J.flags&(G|$$))w(J)}O$.length=0}finally{_$=!1}}function z$($){x++;try{$()}finally{if(x--,x===0)I()}}function v($){let J=N;N=null;try{return $()}finally{N=J}}function u$($){let J=y,z={cleanup:null};y=z;try{let X=$();if(typeof X==="function")J$(z,X);let W=()=>C$(z);if(J)J$(J,W);return W}finally{y=J}}function p($,J){C(c,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??k,guard:J?.guard};return{[Symbol.toStringTag]:c,get(){if(N)R(z,N);return z.value},set(X){C(c,X,z.guard),N$(z,X)},update(X){T(c,X);let W=X(z.value);C(c,W,z.guard),N$(z,W)}}}function V$($){return Y($,c)}function n($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new Z$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let W=$,Q=J;if(W.length!==Q.length)return!1;for(let D=0;D<W.length;D++)if(!n(W[D],Q[D],z))return!1;return!0}if(L($)&&L(J)){let W=Object.keys($),Q=Object.keys(J);if(W.length!==Q.length)return!1;for(let D of W){if(!(D in J))return!1;if(!n($[D],J[D],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function K$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function E$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function d$($,J,z,X,W){let Q=new WeakSet,D={},M={},O={},U=[],H=!1,j=new Map;for(let q=0;q<$.length;q++){let Z=z[q];if(Z&&$[q])j.set(Z,$[q])}let P=new Set;for(let q=0;q<J.length;q++){let Z=J[q];if(Z===void 0)continue;let B=W?X(Z):z[q]??X(Z);if(P.has(B))throw new e(E,B,Z);if(U.push(B),P.add(B),!j.has(B))D[B]=Z,H=!0;else if(!n(j.get(B),Z,Q))M[B]=Z,H=!0}for(let[q]of j)if(!P.has(q))O[q]=null,H=!0;if(!H&&!K$(z,U))H=!0;return{add:D,change:M,remove:O,newKeys:U,changed:H}}function Q$($,J){C(E,$,Array.isArray);let z=new Map,X=[],[W,Q]=E$(J?.keyConfig),D=()=>X.map((Z)=>z.get(Z)?.get()).filter((Z)=>Z!==void 0),M={fn:D,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},O=(Z)=>{let B={};for(let V=0;V<Z.length;V++){let m=Z[V];if(m===void 0)continue;let K=X[V];if(!K)K=W(m),X[V]=K;B[K]=m}return B},U=(Z)=>{let B=!1;for(let V in Z.add){let m=Z.add[V];C(`${E} item for key "${V}"`,m),z.set(V,p(m)),B=!0}if(Object.keys(Z.change).length)z$(()=>{for(let V in Z.change){let m=Z.change[V];C(`${E} item for key "${V}"`,m);let K=z.get(V);if(K)K.set(m)}});for(let V in Z.remove){z.delete(V);let m=X.indexOf(V);if(m!==-1)X.splice(m,1);B=!0}if(B)M.flags|=b;return Z.changed},H=J?.watched,j=H?()=>{if(N){if(!M.sinks)M.stop=H();R(M,N)}}:()=>{if(N)R(M,N)},P=O($);for(let Z in P){let B=P[Z];C(`${E} item for key "${Z}"`,B),z.set(Z,p(B))}M.value=$,M.flags=0;let q={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of X){let B=z.get(Z);if(B)yield B}},get length(){return j(),X.length},get(){if(j(),M.sources){if(M.flags){let Z=M.flags&b;if(M.value=v(D),Z){if(M.flags=G,w(M),M.error)throw M.error}else M.flags=S}}else if(w(M),M.error)throw M.error;return M.value},set(Z){let B=M.flags&G?D():M.value,V=d$(B,Z,X,W,Q);if(V.changed){X=V.newKeys,U(V),M.flags|=G;for(let m=M.sinks;m;m=m.nextSink)F(m.sink);if(x===0)I()}},update(Z){q.set(Z(q.get()))},at(Z){return z.get(X[Z])},keys(){return j(),X.values()},byKey(Z){return z.get(Z)},keyAt(Z){return X[Z]},indexOfKey(Z){return X.indexOf(Z)},add(Z){let B=W(Z);if(z.has(B))throw new e(E,B,Z);if(!X.includes(B))X.push(B);C(`${E} item for key "${B}"`,Z),z.set(B,p(Z)),M.flags|=G|b;for(let V=M.sinks;V;V=V.nextSink)F(V.sink);if(x===0)I();return B},remove(Z){let B=typeof Z==="number"?X[Z]:Z;if(z.delete(B)){let m=typeof Z==="number"?Z:X.indexOf(B);if(m>=0)X.splice(m,1);M.flags|=G|b;for(let K=M.sinks;K;K=K.nextSink)F(K.sink);if(x===0)I()}},sort(Z){let V=X.map((m)=>[m,z.get(m)?.get()]).sort(g(Z)?(m,K)=>Z(m[1],K[1]):(m,K)=>String(m[1]).localeCompare(String(K[1]))).map(([m])=>m);if(!K$(X,V)){X=V,M.flags|=G;for(let m=M.sinks;m;m=m.nextSink)F(m.sink);if(x===0)I()}},splice(Z,B,...V){let m=X.length,K=Z<0?Math.max(0,m+Z):Math.min(Z,m),f=Math.max(0,Math.min(B??Math.max(0,m-Math.max(0,K)),m-K)),A={},_={};for(let h=0;h<f;h++){let a=K+h,f$=X[a];if(f$){let y$=z.get(f$);if(y$)_[f$]=y$.get()}}let w$=X.slice(0,K);for(let h of V){let a=W(h);if(z.has(a)&&!(a in _))throw new e(E,a,h);w$.push(a),A[a]=h}w$.push(...X.slice(K+f));let p$=!!(Object.keys(A).length||Object.keys(_).length);if(p$){U({add:A,change:{},remove:_,changed:p$}),X=w$,M.flags|=G;for(let h=M.sinks;h;h=h.nextSink)F(h.sink);if(x===0)I()}return Object.values(_)},deriveCollection(Z){return x$(q,Z)}};return q}function R$($){return Y($,E)}function B$($,J){if(T(u,$,X$),J?.value!==void 0)C(u,J.value,J?.guard);let z={fn:$,value:J?.value,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??k,error:void 0,stop:void 0},X=J?.watched,W=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{if(F(z),x===0)I()});R(z,N)}}:()=>{if(N)R(z,N)};return{[Symbol.toStringTag]:u,get(){if(W(),w(z),z.error)throw z.error;return W$(u,z.value),z.value}}}function S$($){return Y($,u)}function q$($,J){if(T(d,$,i),J?.value!==void 0)C(d,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:G,equals:J?.equals??k,controller:void 0,error:void 0,stop:void 0},X=J?.watched,W=X?()=>{if(N){if(!z.sinks)z.stop=X(()=>{if(F(z),x===0)I()});R(z,N)}}:()=>{if(N)R(z,N)};return{[Symbol.toStringTag]:d,get(){if(W(),w(z),z.error)throw z.error;return W$(d,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function h$($){return Y($,d)}function x$($,J){T(l,J);let z=i(J),X=new Map,W=[],Q=(q)=>{let Z=z?q$(async(B,V)=>{let m=$.byKey(q)?.get();if(m==null)return B;return J(m,V)}):B$(()=>{let B=$.byKey(q)?.get();if(B==null)return;return J(B)});X.set(q,Z)};function D(q){if(!K$(W,q)){let Z=new Set(W),B=new Set(q);for(let V of W)if(!B.has(V))X.delete(V);for(let V of q)if(!Z.has(V))Q(V);W=q,U.flags|=b}}function M(){D(Array.from($.keys()));let q=[];for(let Z of W)try{let B=X.get(Z)?.get();if(B!=null)q.push(B)}catch(B){if(!(B instanceof o))throw B}return q}let U={fn:M,value:[],flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:(q,Z)=>{if(q.length!==Z.length)return!1;for(let B=0;B<q.length;B++)if(q[B]!==Z[B])return!1;return!0},error:void 0};function H(){if(U.sources){if(U.flags)if(U.value=v(M),U.flags&b){if(U.flags=G,w(U),U.error)throw U.error}else U.flags=S}else if(U.sinks){if(w(U),U.error)throw U.error}else U.value=v(M)}let j=Array.from(v(()=>$.keys()));for(let q of j)Q(q);W=j;let P={[Symbol.toStringTag]:l,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let q of W){let Z=X.get(q);if(Z)yield Z}},get length(){if(N)R(U,N);return H(),W.length},keys(){if(N)R(U,N);return H(),W.values()},get(){if(N)R(U,N);return H(),U.value},at(q){return X.get(W[q])},byKey(q){return X.get(q)},keyAt(q){return W[q]},indexOfKey(q){return W.indexOf(q)},deriveCollection(q){return x$(P,q)}};return P}function t$($,J){let z=J?.value??[];if(z.length)C(l,z,Array.isArray);T(l,$,X$);let X=new Map,W=[],Q=new Map,[D,M]=E$(J?.keyConfig),O=(Z)=>Q.get(Z)??(M?D(Z):void 0),U=J?.createItem??p;function H(){let Z=[];for(let B of W)try{let V=X.get(B)?.get();if(V!=null)Z.push(V)}catch(V){if(!(V instanceof o))throw V}return Z}let j={fn:H,value:z,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:L$,error:void 0};for(let Z of z){let B=D(Z);X.set(B,U(Z)),Q.set(Z,B),W.push(B)}j.value=z,j.flags=G;function P(){if(N){if(!j.sinks)j.stop=$((Z)=>{let{add:B,change:V,remove:m}=Z;if(!B?.length&&!V?.length&&!m?.length)return;let K=!1;z$(()=>{if(B)for(let f of B){let A=D(f);if(X.set(A,U(f)),Q.set(f,A),!W.includes(A))W.push(A);K=!0}if(V)for(let f of V){let A=O(f);if(!A)continue;let _=X.get(A);if(_&&V$(_))Q.delete(_.get()),_.set(f),Q.set(f,A)}if(m)for(let f of m){let A=O(f);if(!A)continue;Q.delete(f),X.delete(A);let _=W.indexOf(A);if(_!==-1)W.splice(_,1);K=!0}j.flags=G|(K?b:0);for(let f=j.sinks;f;f=f.nextSink)F(f.sink)})});R(j,N)}}let q={[Symbol.toStringTag]:l,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of W){let B=X.get(Z);if(B)yield B}},get length(){return P(),W.length},keys(){return P(),W.values()},get(){if(P(),j.sources){if(j.flags){let Z=j.flags&b;if(j.value=v(H),Z){if(j.flags=G,w(j),j.error)throw j.error}else j.flags=S}}else if(w(j),j.error)throw j.error;return j.value},at(Z){return X.get(W[Z])},byKey(Z){return X.get(Z)},keyAt(Z){return W[Z]},indexOfKey(Z){return W.indexOf(Z)},deriveCollection(Z){return x$(q,Z)}};return q}function l$($){return Y($,l)}function r$($){T("Effect",$);let J={fn:$,flags:G,sources:null,sourcesTail:null,cleanup:null},z=()=>{C$(J),J.fn=void 0,J.flags=S,J.sourcesTail=null,H$(J)};if(y)J$(y,z);return T$(J),z}function s$($,J){if(!y)throw new G$("match");let{ok:z,err:X=console.error,nil:W}=J,Q,D=!1,M=Array($.length);for(let U=0;U<$.length;U++)try{M[U]=$[U].get()}catch(H){if(H instanceof o){D=!0;continue}if(!Q)Q=[];Q.push(H instanceof Error?H:Error(String(H)))}let O;try{if(D)O=W?.();else if(Q)O=X(Q);else O=z(M)}catch(U){X([U instanceof Error?U:Error(String(U))])}if(typeof O==="function")return O;if(O instanceof Promise){let U=y,H=new AbortController;J$(U,()=>H.abort()),O.then((j)=>{if(!H.signal.aborted&&typeof j==="function")J$(U,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function i$($,J){if(T(t,$,X$),J?.value!==void 0)C(t,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??k,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:t,get(){if(N){if(!z.sinks)z.stop=$((X)=>{C(t,X,z.guard),N$(z,X)});R(z,N)}return W$(t,z.value),z.value}}}function o$($){return Y($,t)}function n$($,J){let z=L($)||Array.isArray($),X=L(J)||Array.isArray(J);if(!z||!X){let j=!Object.is($,J);return{changed:j,add:j&&X?J:{},change:{},remove:j&&z?$:{}}}let W=new WeakSet,Q={},D={},M={},O=!1,U=Object.keys($),H=Object.keys(J);for(let j of H)if(j in $){if(!n($[j],J[j],W))D[j]=J[j],O=!0}else Q[j]=J[j],O=!0;for(let j of U)if(!(j in J))M[j]=void 0,O=!0;return{add:Q,change:D,remove:M,changed:O}}function m$($,J){C(r,$,L);let z=new Map,X=(H,j)=>{if(C(`${r} for key "${H}"`,j),Array.isArray(j))z.set(H,Q$(j));else if(L(j))z.set(H,m$(j));else z.set(H,p(j))},W=()=>{let H={};return z.forEach((j,P)=>{H[P]=j.get()}),H},Q={fn:W,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},D=(H)=>{let j=!1;for(let P in H.add)X(P,H.add[P]),j=!0;if(Object.keys(H.change).length)z$(()=>{for(let P in H.change){let q=H.change[P];C(`${r} for key "${P}"`,q);let Z=z.get(P);if(Z)if(L(q)!==F$(Z))X(P,q),j=!0;else Z.set(q)}});for(let P in H.remove)z.delete(P),j=!0;if(j)Q.flags|=b;return H.changed},M=J?.watched,O=M?()=>{if(N){if(!Q.sinks)Q.stop=M();R(Q,N)}}:()=>{if(N)R(Q,N)};for(let H of Object.keys($))X(H,$[H]);let U={[Symbol.toStringTag]:r,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let H of Array.from(z.keys())){let j=z.get(H);if(j)yield[H,j]}},keys(){return O(),z.keys()},byKey(H){return z.get(H)},get(){if(O(),Q.sources){if(Q.flags){let H=Q.flags&b;if(Q.value=v(W),H){if(Q.flags=G,w(Q),Q.error)throw Q.error}else Q.flags=S}}else if(w(Q),Q.error)throw Q.error;return Q.value},set(H){let j=Q.flags&G?W():Q.value,P=n$(j,H);if(D(P)){Q.flags|=G;for(let q=Q.sinks;q;q=q.nextSink)F(q.sink);if(x===0)I()}},update(H){U.set(H(U.get()))},add(H,j){if(z.has(H))throw new e(r,H,j);X(H,j),Q.flags|=G|b;for(let P=Q.sinks;P;P=P.nextSink)F(P.sink);if(x===0)I();return H},remove(H){if(z.delete(H)){Q.flags|=G|b;for(let P=Q.sinks;P;P=P.nextSink)F(P.sink);if(x===0)I()}}};return new Proxy(U,{get(H,j){if(j in H)return Reflect.get(H,j);if(typeof j!=="symbol")return H.byKey(j)},has(H,j){if(j in H)return!0;return H.byKey(String(j))!==void 0},ownKeys(H){return Array.from(H.keys())},getOwnPropertyDescriptor(H,j){if(j in H)return Reflect.getOwnPropertyDescriptor(H,j);if(typeof j==="symbol")return;let P=H.byKey(String(j));return P?{enumerable:!0,configurable:!0,writable:!0,value:P}:void 0}})}function F$($){return Y($,r)}function a$($,J){return i($)?q$($,J):B$($,J)}function e$($){if(M$($))return $;if($==null)throw new j$("createSignal",$);if(i($))return q$($);if(g($))return B$($);if(Y$($))return Q$($);if(L($))return m$($);return p($)}function $J($){if(I$($))return $;if($==null||g($)||M$($))throw new j$("createMutableSignal",$);if(Y$($))return Q$($);if(L($))return m$($);return p($)}function JJ($){return S$($)||h$($)}function M$($){let J=[c,u,d,t,s,E,l,r],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function I$($){return V$($)||F$($)||R$($)}function zJ($,J){C(s,$,M$);let z=$,X=J?.guard,W={fn:()=>z.get(),value:void 0,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??k,error:void 0},Q=()=>{if(N)R(W,N);if(w(W),W.error)throw W.error;return W.value},D=(O)=>{if(!I$(z))throw new P$(s);C(s,O,X),z.set(O)},M=(O)=>{C(s,O,M$),z=O,W.flags|=G;for(let U=W.sinks;U;U=U.nextSink)F(U.sink);if(x===0)I()};return{[Symbol.toStringTag]:s,configurable:!0,enumerable:!0,get:Q,set:D,replace:M,current:()=>z}}function XJ($){return Y($,s)}export{D$ as valueString,v as untrack,s$ as match,h$ as isTask,F$ as isStore,V$ as isState,XJ as isSlot,M$ as isSignal,o$ as isSensor,L as isRecord,Y as isObjectOfType,I$ as isMutableSignal,S$ as isMemo,R$ as isList,g as isFunction,n as isEqual,JJ as isComputed,l$ as isCollection,i as isAsyncFunction,q$ as createTask,m$ as createStore,p as createState,zJ as createSlot,e$ as createSignal,i$ as createSensor,u$ as createScope,$J as createMutableSignal,B$ as createMemo,Q$ as createList,r$ as createEffect,a$ as createComputed,t$ as createCollection,z$ as batch,o as UnsetSignalValueError,L$ as SKIP_EQUALITY,G$ as RequiredOwnerError,P$ as ReadonlySignalError,A$ as NullishSignalValueError,j$ as InvalidSignalValueError,b$ as InvalidCallbackError,Z$ as CircularDependencyError};
