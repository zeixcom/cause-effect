var Y=Symbol(),t=($)=>typeof $==="string",x$=($)=>typeof $==="number",o=($)=>typeof $==="symbol",I=($)=>typeof $==="function",v=($)=>I($)&&$.constructor.name==="AsyncFunction",f=($,M)=>Object.prototype.toString.call($)===`[object ${M}]`,T=($)=>f($,"Object"),l=($)=>T($)||Array.isArray($);var g=($)=>$ instanceof DOMException&&$.name==="AbortError",W=($)=>$ instanceof Error?$:Error(String($)),y=($)=>t($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);class m extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class r extends Error{constructor($,M,z){super(`Forbidden method call ${$} in ${M} because ${z}`);this.name="ForbiddenMethodCallError"}}class E extends TypeError{constructor($,M){super(`Invalid ${$} callback ${y(M)}`);this.name="InvalidCallbackError"}}class a extends TypeError{constructor($,M){super(`Invalid signal value ${y(M)} in ${$}`);this.name="InvalidSignalValueError"}}class U extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class e extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class d extends Error{constructor($,M){super(`Could not add store key "${$}" with value ${y(M)} because it already exists`);this.name="StoreKeyExistsError"}}class $$ extends Error{constructor($,M){super(`Could not set store key "${$}" to ${y(M)} because it is read-only`);this.name="StoreKeyReadonlyError"}}var S=($,M,z)=>{if(Object.is($,M))return!0;if(typeof $!==typeof M)return!1;if(typeof $!=="object"||$===null||M===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(M))throw new m("isEqual");z.add($),z.add(M);try{if(Array.isArray($)&&Array.isArray(M)){if($.length!==M.length)return!1;for(let Q=0;Q<$.length;Q++)if(!S($[Q],M[Q],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(M))return!1;if(T($)&&T(M)){let Q=Object.keys($),X=Object.keys(M);if(Q.length!==X.length)return!1;for(let Z of Q){if(!(Z in M))return!1;if(!S($[Z],M[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(M)}},H$=($,M)=>{let z=l($),Q=l(M);if(!z||!Q){let D=!Object.is($,M);return{changed:D,add:D&&Q?M:{},change:{},remove:D&&z?$:{}}}let X=new WeakSet,Z={},H={},F={},x=Object.keys($),C=Object.keys(M),j=new Set([...x,...C]);for(let D of j){let P=D in $,A=D in M;if(!P&&A){Z[D]=M[D];continue}else if(P&&!A){F[D]=Y;continue}let V=$[D],_=M[D];if(!S(V,_,X))H[D]=_}return{add:Z,change:H,remove:F,changed:!!(Object.keys(Z).length||Object.keys(H).length||Object.keys(F).length)}};var k,B$=new Set,R$=0,p=($)=>{let M=new Set,z=$;return z.unwatch=(Q)=>{M.add(Q)},z.cleanup=()=>{for(let Q of M)Q();M.clear()},z},O=($)=>{if(k&&!$.has(k)){let M=k;M.unwatch(()=>{$.delete(M)}),$.add(M)}},L=($)=>{for(let M of $)if(R$)B$.add(M);else M()},J$=()=>{while(B$.size){let $=Array.from(B$);B$.clear();for(let M of $)M()}},q$=($)=>{R$++;try{$()}finally{J$(),R$--}},w=($,M)=>{let z=k;k=M;try{$()}finally{k=z}};var Y$="Computed",D$=($,M=Y)=>{if(!M$($))throw new E("computed",$);if(M==null)throw new U("computed");let z=new Set,Q=M,X,Z,H=!0,F=!1,x=!1,C=(K)=>{if(!S(K,Q))Q=K,F=!0;X=void 0,H=!1},j=()=>{F=Y!==Q,Q=Y,X=void 0},D=(K)=>{let N=W(K);F=!X||N.name!==X.name||N.message!==X.message,Q=Y,X=N},P=(K)=>(N)=>{if(x=!1,Z=void 0,K(N),F)L(z)},A=p(()=>{if(H=!0,Z?.abort(),z.size)L(z);else A.cleanup()});A.unwatch(()=>{Z?.abort()});let V=()=>w(()=>{if(x)throw new m("computed");if(F=!1,v($)){if(Z)return Q;Z=new AbortController,Z.signal.addEventListener("abort",()=>{x=!1,Z=void 0,V()},{once:!0})}let K;x=!0;try{K=Z?$(Q,Z.signal):$(Q)}catch(N){if(g(N))j();else D(N);x=!1;return}if(K instanceof Promise)K.then(P(C),P(D));else if(K==null||Y===K)j();else C(K);x=!1},A),_={};return Object.defineProperties(_,{[Symbol.toStringTag]:{value:Y$},get:{value:()=>{if(O(z),J$(),H)V();if(X)throw X;return Q}}}),_},n=($)=>f($,Y$),M$=($)=>I($)&&$.length<3;var _$=($)=>{if(!I($)||$.length>1)throw new E("effect",$);let M=v($),z=!1,Q,X=p(()=>w(()=>{if(z)throw new m("effect");z=!0,Q?.abort(),Q=void 0;let Z;try{if(M){Q=new AbortController;let H=Q;$(Q.signal).then((F)=>{if(I(F)&&Q===H)X.unwatch(F)}).catch((F)=>{if(!g(F))console.error("Async effect error:",F)})}else if(Z=$(),I(Z))X.unwatch(Z)}catch(H){if(!g(H))console.error("Effect callback error:",H)}z=!1},X));return X(),()=>{Q?.abort(),X.cleanup()}};function T$($,M){try{if($.pending)M.nil?.();else if($.errors)M.err?.($.errors);else if($.ok)M.ok($.values)}catch(z){if(M.err&&(!$.errors||!$.errors.includes(W(z))))M.err($.errors?[...$.errors,W(z)]:[W(z)]);else throw z}}function W$($){let M=[],z=!1,Q={};for(let[X,Z]of Object.entries($))try{let H=Z.get();if(H===Y)z=!0;else Q[X]=H}catch(H){M.push(W(H))}if(z)return{ok:!1,pending:!0};if(M.length>0)return{ok:!1,errors:M};return{ok:!0,values:Q}}var F$="State",u=($)=>{if($==null)throw new U("state");let M=new Set,z=$,Q=(Z)=>{if(Z==null)throw new U("state");if(S(z,Z))return;if(z=Z,L(M),Y===z)M.clear()},X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:F$},get:{value:()=>{return O(M),z}},set:{value:(Z)=>{Q(Z)}},update:{value:(Z)=>{if(!I(Z))throw new E("state update",Z);Q(Z(z))}}}),X},h=($)=>f($,F$);var K$="Store",z$=($,M)=>{if($==null)throw new U("store");let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},X=new Map,Z=new Map,H=Array.isArray($),F=0,x=[],C=(B)=>{let J=B;if(H){let G=Number(B);if(Number.isInteger(G)&&G>=0)J=x[G]??B}return X.get(J)},j=(B)=>{if(!H)return"";let J=F++;return t(M)?`${M}${J}`:I(M)?M(B):String(J)},D=(B)=>{if(!Array.isArray(B))return B;let J={};for(let G=0;G<B.length;G++){let R=B[G];if(R===void 0)continue;let q=x[G];if(!q)q=j(R),x[G]=q;J[q]=R}return J},P=()=>{if(H)return x.map((J)=>X.get(J)?.get()).filter((J)=>J!==void 0);let B={};for(let J of x){let G=X.get(J);if(G)B[J]=G.get()}return B},A=(B,J)=>{Object.freeze(J);for(let G of Q[B])G(J)},V=(B,J)=>{if(J==null)throw new U(`store for key "${B}"`);if(J===Y)return!0;if(o(J)||I(J)||n(J))throw new a(`store for key "${B}"`,J);return!0},_=(B,J,G=!1)=>{if(!V(B,J))return!1;let R=h(J)||c(J)?J:T(J)||Array.isArray(J)?z$(J):u(J);if(X.set(B,R),!x.includes(B))x.push(B);let q=p(()=>w(()=>{A("change",{[B]:R.get()})},q));if(q(),Z.set(B,q),G)L(z),A("add",{[B]:J});return!0},K=(B,J=!1)=>{if(!X.delete(B))return;let R=x.indexOf(B);if(R>=0)x.splice(R,1);let q=Z.get(B);if(q)q.cleanup();if(Z.delete(B),J)x=x.filter(()=>!0),L(z),A("remove",{[B]:Y})},N=(B,J)=>{if(Object.keys(B.add).length){for(let G in B.add)_(G,B.add[G]??Y,!1);if(J)setTimeout(()=>{A("add",B.add)},0);else A("add",B.add)}if(Object.keys(B.change).length)q$(()=>{for(let G in B.change){let R=B.change[G];if(!V(G,R))continue;let q=X.get(G);if(A$(q))q.set(R);else throw new $$(G,R)}A("change",B.change)});if(Object.keys(B.remove).length){for(let G in B.remove)K(G);x=x.filter(()=>!0),A("remove",B.remove)}return B.changed},G$=(B,J,G)=>N(H$(H?D(B):B,H?D(J):J),G);G$(H?[]:{},$,!0);let I$={};return Object.defineProperties(I$,{[Symbol.toStringTag]:{value:K$},[Symbol.isConcatSpreadable]:{value:H},[Symbol.iterator]:{value:function*(){for(let B of x){let J=X.get(B);if(J)yield H?J:[B,J]}}},add:{value:H?(B)=>{let J=j(B);if(!X.has(J))_(J,B,!0);else throw new d(J,B)}:(B,J)=>{if(!X.has(B))_(B,J,!0);else throw new d(B,J)}},byKey:{value(B){return C(B)}},keyAt:{value(B){return x[B]}},indexOfKey:{value(B){return x.indexOf(B)}},get:{value:()=>{return O(z),P()}},remove:{value:(B)=>{let J=String(B);if(x$(B)){if(!x[B])throw new e(B);J=x[B]}if(X.has(J))K(J,!0)}},set:{value:(B)=>{if(G$(P(),B)){if(L(z),Y===B)z.clear()}}},update:{value:(B)=>{let J=P(),G=B(J);if(G$(J,G)){if(L(z),Y===G)z.clear()}}},sort:{value:(B)=>{x=x.map((G,R)=>{let q=X.get(G);return[R,G,q?q.get():void 0]}).sort(B?(G,R)=>B(G[2],R[2]):(G,R)=>String(G[2]).localeCompare(String(R[2]))).map(([G,R])=>R),L(z),A("sort",[...x])}},splice:{value:(B,J,...G)=>{if(!H)throw new r("splice","store","it is only supported for array-like stores");let R=X.size,q=B<0?Math.max(0,R+B):Math.min(B,R),L$=Math.max(0,Math.min(J??Math.max(0,R-Math.max(0,q)),R-q)),Q$={},s={};for(let b=0;b<L$;b++){let i=q+b,Z$=x[i];if(Z$){let U$=X.get(Z$);if(U$)s[Z$]=U$.get()}}let X$=x.slice(0,q);for(let b of G){let i=j(b);X$.push(i),Q$[i]=b}X$.push(...x.slice(q+L$)),x=X$.filter(()=>!0);let N$=!!(Object.keys(Q$).length||Object.keys(s).length);if(N$)N({add:Q$,change:{},remove:s,changed:N$});return L(z),Object.values(s)}},on:{value:(B,J)=>{return Q[B].add(J),()=>Q[B].delete(J)}},length:{get(){return O(z),X.size}}}),new Proxy(I$,{get(B,J){if(J in B)return Reflect.get(B,J);if(!o(J))return C(J)},has(B,J){if(J in B)return!0;return X.has(String(J))},ownKeys(B){let J=Reflect.ownKeys(B);return[...new Set([...x,...J])]},getOwnPropertyDescriptor(B,J){if(J in B)return Reflect.getOwnPropertyDescriptor(B,J);if(o(J))return;let G=C(J);return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},c=($)=>f($,K$);var P$=($)=>h($)||n($)||c($),A$=($)=>h($)||c($);function C$($){if(P$($))return $;if(M$($))return D$($);if(Array.isArray($)||T($))return z$($);return u($)}export{y as valueString,C$ as toSignal,W as toError,O as subscribe,W$ as resolve,w as observe,L as notify,T$ as match,o as isSymbol,t as isString,c as isStore,h as isState,P$ as isSignal,l as isRecordOrArray,T as isRecord,f as isObjectOfType,x$ as isNumber,A$ as isMutableSignal,I as isFunction,S as isEqual,M$ as isComputedCallback,n as isComputed,v as isAsyncFunction,g as isAbortError,J$ as flush,H$ as diff,p as createWatcher,z$ as createStore,u as createState,_$ as createEffect,D$ as createComputed,q$ as batch,Y as UNSET,K$ as TYPE_STORE,F$ as TYPE_STATE,Y$ as TYPE_COMPUTED,$$ as StoreKeyReadonlyError,d as StoreKeyExistsError,e as StoreIndexRangeError,U as NullishSignalValueError,a as InvalidSignalValueError,E as InvalidCallbackError,r as ForbiddenMethodCallError,m as CircularDependencyError};
