var F=Symbol(),G$=($)=>typeof $==="string",e=($)=>typeof $==="number",E=($)=>typeof $==="symbol",P=($)=>typeof $==="function",g=($)=>P($)&&$.constructor.name==="AsyncFunction",O=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,m=($)=>O($,"Object"),Q$=($)=>m($)||Array.isArray($);var c=($)=>$ instanceof DOMException&&$.name==="AbortError",b=($)=>$ instanceof Error?$:Error(String($)),n=($)=>G$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);class p extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class s extends Error{constructor($,B,z){super(`Could not add ${$} key "${B}"${z?` with value ${n(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class f$ extends Error{constructor($,B,z){super(`Forbidden method call ${$} in ${B} because ${z}`);this.name="ForbiddenMethodCallError"}}class h extends TypeError{constructor($,B){super(`Invalid ${$} callback ${n(B)}`);this.name="InvalidCallbackError"}}class t extends TypeError{constructor($,B){super(`Invalid signal value ${n(B)} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class i extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreIndexRangeError"}}class l extends Error{constructor($,B){super(`Could not set store key "${$}" to ${n(B)} because it is read-only`);this.name="StoreKeyReadonlyError"}}var v=($,B,z)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(B))throw new p("isEqual");z.add($),z.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Q=0;Q<$.length;Q++)if(!v($[Q],B[Q],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(m($)&&m(B)){let Q=Object.keys($),q=Object.keys(B);if(Q.length!==q.length)return!1;for(let Z of Q){if(!(Z in B))return!1;if(!v($[Z],B[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(B)}},$$=($,B)=>{let z=Q$($),Q=Q$(B);if(!z||!Q){let U=!Object.is($,B);return{changed:U,add:U&&Q?B:{},change:{},remove:U&&z?$:{}}}let q=new WeakSet,Z={},K={},D={},C=Object.keys($),j=Object.keys(B),S=new Set([...C,...j]);for(let U of S){let X=U in $,Y=U in B;if(!X&&Y){Z[U]=B[U];continue}else if(X&&!Y){D[U]=F;continue}let M=$[U],J=B[U];if(!v(M,J,q))K[U]=J}return{add:Z,change:K,remove:D,changed:!!(Object.keys(Z).length||Object.keys(K).length||Object.keys(D).length)}};var r,X$=new Set,U$=0,V=($)=>{let B=new Set,z=$;return z.unwatch=(Q)=>{B.add(Q)},z.cleanup=()=>{for(let Q of B)Q();B.clear()},z},T=($)=>{if(r&&!$.has(r)){let B=r;B.unwatch(()=>{$.delete(B)}),$.add(B)}},N=($)=>{for(let B of $)if(U$)X$.add(B);else B()},Z$=()=>{while(X$.size){let $=Array.from(X$);X$.clear();for(let B of $)B()}},M$=($)=>{U$++;try{$()}finally{Z$(),U$--}},w=($,B)=>{let z=r;r=B;try{$()}finally{r=z}},W=($,B)=>{for(let z of $)z(B)};var _$="Computed",A$=($,B=F)=>{if(!H$($))throw new h("computed",$);if(B==null)throw new f("computed");let z=new Set,Q=B,q,Z,K=!0,D=!1,C=!1,j=(H)=>{if(!v(H,Q))Q=H,D=!0;q=void 0,K=!1},S=()=>{D=F!==Q,Q=F,q=void 0},U=(H)=>{let R=b(H);D=!q||R.name!==q.name||R.message!==q.message,Q=F,q=R},X=(H)=>(R)=>{if(C=!1,Z=void 0,H(R),D)N(z)},Y=V(()=>{if(K=!0,Z?.abort(),z.size)N(z);else Y.cleanup()});Y.unwatch(()=>{Z?.abort()});let M=()=>w(()=>{if(C)throw new p("computed");if(D=!1,g($)){if(Z)return Q;Z=new AbortController,Z.signal.addEventListener("abort",()=>{C=!1,Z=void 0,M()},{once:!0})}let H;C=!0;try{H=Z?$(Q,Z.signal):$(Q)}catch(R){if(c(R))S();else U(R);C=!1;return}if(H instanceof Promise)H.then(X(j),X(U));else if(H==null||F===H)S();else j(H);C=!1},Y),J={};return Object.defineProperties(J,{[Symbol.toStringTag]:{value:_$},get:{value:()=>{if(T(z),Z$(),K)M();if(q)throw q;return Q}}}),J},y=($)=>O($,_$),H$=($)=>P($)&&$.length<3;function q$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(z){if(B.err&&(!$.errors||!$.errors.includes(b(z))))B.err($.errors?[...$.errors,b(z)]:[b(z)]);else throw z}}function D$($){let B=[],z=!1,Q={};for(let[q,Z]of Object.entries($))try{let K=Z.get();if(K===F)z=!0;else Q[q]=K}catch(K){B.push(b(K))}if(z)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Q}}var W$="Collection",N$=($,B)=>{let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},q=new Map,Z=new Map,K=[],D=(X)=>{let Y=g(B)?async(H,R)=>{let x=$.byKey(X);if(!x)return F;let A=F;return q$(D$({originSignal:x}),{ok:async({originSignal:G})=>{A=await B(G,R)},err:(G)=>{console.log(G)}}),A}:()=>{let H=$.byKey(X);if(!H)return F;let R=F;return q$(D$({originSignal:H}),{ok:({originSignal:x})=>{R=B(x)},err:(x)=>{console.log(x)}}),R},M=A$(Y);if(q.set(X,M),!K.includes(X))K.push(X);let J=V(()=>w(()=>{M.get(),W(Q.change,[X])},J));return J(),Z.set(X,J),!0},C=(X)=>{if(!q.delete(X))return;let M=K.indexOf(X);if(M>=0)K.splice(M,1);let J=Z.get(X);if(J)J.cleanup();Z.delete(X)};for(let X=0;X<$.length;X++){let Y=$.keyAt(X);if(!Y)continue;D(Y)}$.on("add",(X)=>{for(let Y of X)if(!q.has(Y))D(Y);N(z),W(Q.add,X)}),$.on("remove",(X)=>{for(let Y of Object.keys(X)){if(!q.has(Y))continue;C(Y)}K=K.filter(()=>!0),N(z),W(Q.remove,X)}),$.on("sort",(X)=>{K=[...X],N(z),W(Q.sort,X)});let j=(X)=>{let Y=X,M=Number(X);if(Number.isInteger(M)&&M>=0)Y=K[M]??X;return q.get(Y)},S=()=>K.map((X)=>q.get(X)?.get()).filter((X)=>X!==F),U={};return Object.defineProperties(U,{[Symbol.toStringTag]:{value:W$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let X of K){let Y=q.get(X);if(Y)yield Y}}},byKey:{value(X){return j(X)}},keyAt:{value(X){return K[X]}},indexOfKey:{value(X){return K.indexOf(X)}},get:{value:()=>{return T(z),S()}},sort:{value:(X)=>{K=K.map((M,J)=>{let H=q.get(M);return[J,M,H?H.get():void 0]}).sort(X?(M,J)=>X(M[2],J[2]):(M,J)=>String(M[2]).localeCompare(String(J[2]))).map(([M,J])=>J),N(z),W(Q.sort,K)}},on:{value:(X,Y)=>{return Q[X].add(Y),()=>Q[X].delete(Y)}},length:{get(){return T(z),q.size}}}),new Proxy(U,{get(X,Y){if(Y in X)return Reflect.get(X,Y);if(!E(Y))return j(Y)},has(X,Y){if(Y in X)return!0;return q.has(String(Y))},ownKeys(X){let Y=Reflect.ownKeys(X);return[...new Set([...K,...Y])]},getOwnPropertyDescriptor(X,Y){if(Y in X)return Reflect.getOwnPropertyDescriptor(X,Y);if(E(Y))return;let M=j(Y);return M?{enumerable:!0,configurable:!0,writable:!0,value:M}:void 0}})},O$=($)=>O($,W$);var S$=($)=>{if(!P($)||$.length>1)throw new h("effect",$);let B=g($),z=!1,Q,q=V(()=>w(()=>{if(z)throw new p("effect");z=!0,Q?.abort(),Q=void 0;let Z;try{if(B){Q=new AbortController;let K=Q;$(Q.signal).then((D)=>{if(P(D)&&Q===K)q.unwatch(D)}).catch((D)=>{if(!c(D))console.error("Async effect error:",D)})}else if(Z=$(),P(Z))q.unwatch(Z)}catch(K){if(!c(K))console.error("Effect callback error:",K)}z=!1},q));return q(),()=>{Q?.abort(),q.cleanup()}};var I$="State",d=($)=>{if($==null)throw new f("state");let B=new Set,z=$,Q=(Z)=>{if(Z==null)throw new f("state");if(v(z,Z))return;if(z=Z,N(B),F===z)B.clear()},q={};return Object.defineProperties(q,{[Symbol.toStringTag]:{value:I$},get:{value:()=>{return T(B),z}},set:{value:(Z)=>{Q(Z)}},update:{value:(Z)=>{if(!P(Z))throw new h("state update",Z);Q(Z(z))}}}),q},k=($)=>O($,I$);var x$="Store",a=($)=>{if($==null)throw new f("store");let B=new Set,z={add:new Set,change:new Set,remove:new Set,sort:new Set},Q=new Map,q=new Map,Z=[],K=()=>{let M={};for(let J of Z){let H=Q.get(J);if(H)M[J]=H.get()}return M},D=(M,J)=>{if(J==null)throw new f(`store for key "${M}"`);if(J===F)return!0;if(E(J)||P(J)||y(J))throw new t(`store for key "${M}"`,J);return!0},C=(M,J,H=!1)=>{if(!D(M,J))return!1;let R=k(J)||u(J)?J:m(J)||Array.isArray(J)?a(J):d(J);if(Q.set(M,R),!Z.includes(M))Z.push(M);let x=V(()=>w(()=>{R.get(),W(z.change,[M])},x));if(x(),q.set(M,x),H)N(B),W(z.add,[M]);return!0},j=(M,J=!1)=>{if(!Q.delete(M))return;let R=Z.indexOf(M);if(R>=0)Z.splice(R,1);let x=q.get(M);if(x)x.cleanup();if(q.delete(M),J)Z=Z.filter(()=>!0),N(B),W(z.remove,[M])},S=(M,J)=>{if(Object.keys(M.add).length){for(let H in M.add)C(H,M.add[H],!1);if(J)setTimeout(()=>{W(z.add,Object.keys(M.add))},0);else W(z.add,Object.keys(M.add))}if(Object.keys(M.change).length)M$(()=>{for(let H in M.change){let R=M.change[H];if(!D(H,R))continue;let x=Q.get(H);if(B$(x))x.set(R);else throw new l(H,R)}W(z.change,Object.keys(M.change))});if(Object.keys(M.remove).length){for(let H in M.remove)j(H);Z=Z.filter(()=>!0),W(z.remove,Object.keys(M.remove))}return M.changed},U=(M,J,H)=>S($$(M,J),H);U({},$,!0);let X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:x$},[Symbol.iterator]:{value:function*(){for(let M of Z){let J=Q.get(M);if(J)yield[M,J]}}},add:{value:(M,J)=>{if(!Q.has(M))return C(M,J,!0),M;else throw new s("store",M,J)}},byKey:{value:(M)=>{return Q.get(M)}},keyAt:{value(M){return Z[M]}},indexOfKey:{value(M){return Z.indexOf(M)}},get:{value:()=>{return T(B),K()}},remove:{value:(M)=>{let J=String(M);if(e(M)){if(!Z[M])throw new i(M);J=Z[M]}if(Q.has(J))j(J,!0)}},set:{value:(M)=>{if(U(K(),M)){if(N(B),F===M)B.clear()}}},update:{value:(M)=>{let J=K(),H=M(J);if(U(J,H)){if(N(B),F===H)B.clear()}}},sort:{value:(M)=>{Z=Z.map((H,R)=>{let x=Q.get(H);return[R,H,x?x.get():void 0]}).sort(M?(H,R)=>M(H[2],R[2]):(H,R)=>String(H[2]).localeCompare(String(R[2]))).map(([H,R])=>R),N(B),W(z.sort,Z)}},on:{value:(M,J)=>{return z[M].add(J),()=>z[M].delete(J)}},length:{get(){return T(B),Q.size}}}),new Proxy(X,{get(M,J){if(J in M)return Reflect.get(M,J);if(!E(J))return Q.get(J)},has(M,J){if(J in M)return!0;return Q.has(String(J))},ownKeys(M){let J=Reflect.ownKeys(M);return[...new Set([...Z,...J])]},getOwnPropertyDescriptor(M,J){if(J in M)return Reflect.getOwnPropertyDescriptor(M,J);if(E(J))return;let H=Q.get(J);return H?{enumerable:!0,configurable:!0,writable:!0,value:H}:void 0}})},u=($)=>O($,x$);var E$=($)=>k($)||y($)||u($),B$=($)=>k($)||u($)||K$($);function m$($){if(E$($))return $;if(H$($))return A$($);if(Array.isArray($))return Y$($);if(m($))return a($);return d($)}var C$="List",Y$=($,B)=>{if($==null)throw new f("store");let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},q=new Map,Z=new Map,K=0,D=[],C=(A)=>{let G=A,L=Number(A);if(Number.isInteger(L)&&L>=0)G=D[L]??A;return q.get(G)},j=(A)=>{let G=K++;return G$(B)?`${B}${G}`:P(B)?B(A):String(G)},S=(A)=>{let G={};for(let L=0;L<A.length;L++){let _=A[L];if(_===void 0)continue;let I=D[L];if(!I)I=j(_),D[L]=I;G[I]=_}return G},U=()=>D.map((A)=>q.get(A)?.get()).filter((A)=>A!==void 0),X=(A,G)=>{if(G==null)throw new f(`store for key "${A}"`);if(G===F)return!0;if(E(G)||P(G)||y(G))throw new t(`store for key "${A}"`,G);return!0},Y=(A,G,L=!1)=>{if(!X(A,G))return!1;let _=k(G)||u(G)||K$(G)?G:m(G)?a(G):Array.isArray(G)?Y$(G):d(G);if(q.set(A,_),!D.includes(A))D.push(A);let I=V(()=>w(()=>{_.get(),W(Q.change,[A])},I));if(I(),Z.set(A,I),L)N(z),W(Q.add,[A]);return!0},M=(A,G=!1)=>{if(!q.delete(A))return;let _=D.indexOf(A);if(_>=0)D.splice(_,1);let I=Z.get(A);if(I)I.cleanup();if(Z.delete(A),G)D=D.filter(()=>!0),N(z),W(Q.remove,[A])},J=(A,G)=>{if(Object.keys(A.add).length){for(let L in A.add)Y(L,A.add[L],!1);if(G)setTimeout(()=>{W(Q.add,Object.keys(A.add))},0);else W(Q.add,Object.keys(A.add))}if(Object.keys(A.change).length)M$(()=>{for(let L in A.change){let _=A.change[L];if(!X(L,_))continue;let I=q.get(L);if(B$(I))I.set(_);else throw new l(L,_)}W(Q.change,Object.keys(A.change))});if(Object.keys(A.remove).length){for(let L in A.remove)M(L);D=D.filter(()=>!0),W(Q.remove,Object.keys(A.remove))}return A.changed},H=(A,G,L)=>J($$(S(A),S(G)),L);H([],$,!0);let R={};Object.defineProperties(R,{[Symbol.toStringTag]:{value:C$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let A of D){let G=q.get(A);if(G)yield G}}},add:{value:(A)=>{let G=j(A);if(!q.has(G))return Y(G,A,!0),G;else throw new s("store",G,A)}},byKey:{value:(A)=>{return C(A)}},deriveCollection:{value:(A)=>{return N$(x,A)}},keyAt:{value(A){return D[A]}},indexOfKey:{value(A){return D.indexOf(A)}},get:{value:()=>{return T(z),U()}},remove:{value:(A)=>{let G=String(A);if(e(A)){if(!D[A])throw new i(A);G=D[A]}if(q.has(G))M(G,!0)}},set:{value:(A)=>{if(H(U(),A)){if(N(z),F===A)z.clear()}}},update:{value:(A)=>{let G=U(),L=A(G);if(H(G,L)){if(N(z),F===L)z.clear()}}},sort:{value:(A)=>{D=D.map((L,_)=>{let I=q.get(L);return[_,L,I?I.get():void 0]}).sort(A?(L,_)=>A(L[2],_[2]):(L,_)=>String(L[2]).localeCompare(String(_[2]))).map(([L,_])=>_),N(z),W(Q.sort,D)}},splice:{value:(A,G,...L)=>{let _=q.size,I=A<0?Math.max(0,_+A):Math.min(A,_),j$=Math.max(0,Math.min(G??Math.max(0,_-Math.max(0,I)),_-I)),L$={},J$={};for(let o=0;o<j$;o++){let z$=I+o,F$=D[z$];if(F$){let T$=q.get(F$);if(T$)J$[F$]=T$.get()}}let R$=D.slice(0,I);for(let o of L){let z$=j(o);R$.push(z$),L$[z$]=o}R$.push(...D.slice(I+j$)),D=R$.filter(()=>!0);let P$=!!(Object.keys(L$).length||Object.keys(J$).length);if(P$)J({add:L$,change:{},remove:J$,changed:P$});return N(z),Object.values(J$)}},on:{value:(A,G)=>{return Q[A].add(G),()=>Q[A].delete(G)}},length:{get(){return T(z),q.size}}});let x=new Proxy(R,{get(A,G){if(G in A)return Reflect.get(A,G);if(!E(G))return C(G)},has(A,G){if(G in A)return!0;return q.has(String(G))},ownKeys(A){let G=Reflect.ownKeys(A);return[...new Set([...D,...G])]},getOwnPropertyDescriptor(A,G){if(G in A)return Reflect.getOwnPropertyDescriptor(A,G);if(E(G))return;let L=C(G);return L?{enumerable:!0,configurable:!0,writable:!0,value:L}:void 0}});return x},K$=($)=>O($,C$);export{n as valueString,m$ as toSignal,b as toError,T as subscribe,D$ as resolve,w as observe,N as notify,q$ as match,E as isSymbol,G$ as isString,u as isStore,k as isState,E$ as isSignal,Q$ as isRecordOrArray,m as isRecord,O as isObjectOfType,e as isNumber,B$ as isMutableSignal,K$ as isList,P as isFunction,v as isEqual,H$ as isComputedCallback,y as isComputed,O$ as isCollection,g as isAsyncFunction,c as isAbortError,Z$ as flush,W as emit,$$ as diff,V as createWatcher,a as createStore,d as createState,Y$ as createList,S$ as createEffect,A$ as createComputed,N$ as createCollection,M$ as batch,F as UNSET,x$ as TYPE_STORE,I$ as TYPE_STATE,C$ as TYPE_LIST,_$ as TYPE_COMPUTED,W$ as TYPE_COLLECTION,l as StoreKeyReadonlyError,i as StoreIndexRangeError,f as NullishSignalValueError,t as InvalidSignalValueError,h as InvalidCallbackError,f$ as ForbiddenMethodCallError,s as DuplicateKeyError,p as CircularDependencyError};
