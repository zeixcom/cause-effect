function y($){return typeof $==="function"}function l($){return y($)&&$.constructor.name==="AsyncFunction"}function $$($){return y($)&&$.constructor.name!=="AsyncFunction"}function Y($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function L($){return Y($,"Object")}function C$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function V$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class J$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class I$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class t extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class z$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${V$(J)} is invalid`);this.name="InvalidSignalValueError"}}class x$ extends TypeError{constructor($,J){super(`[${$}] Callback ${V$(J)} is invalid`);this.name="InvalidCallbackError"}}class G$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class n extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function K($,J,z){if(J==null)throw new I$($);if(z&&!z(J))throw new z$($,J)}function X$($,J){if(J==null)throw new t($)}function _($,J,z=y){if(!z(J))throw new x$($,J)}var k="State",v="Memo",u="Task",c="Sensor",b="List",g="Collection",d="Store",T=0,D$=1,D=2,H$=4,U=null,p=null,m$=[],C=0,A$=!1,r=($,J)=>$===J,w$=($,J)=>!1;function p$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function O($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,Q=J.flags&H$;if(Q){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let H=$.sinksTail;if(H?.sink===J&&(!Q||p$(H,J)))return;let B={source:$,sink:J,nextSource:X,prevSink:H,nextSink:null};if(J.sourcesTail=$.sinksTail=B,z)z.nextSource=B;else J.sources=B;if(H)H.nextSink=B;else $.sinks=B}function y$($){let{source:J,nextSource:z,nextSink:X,prevSink:Q}=$;if(X)X.prevSink=Q;else J.sinksTail=Q;if(Q)Q.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function Q$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=y$(z);if(J)J.nextSource=null;else $.sources=null}function I($,J=D){let z=$.flags;if("sinks"in $){if((z&(D|D$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)I(X.sink,D$)}else{if(z&D)return;$.flags=D,m$.push($)}}function B$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)I(z.sink);if(C===0)A()}function a($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function P$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function g$($){let J=U;U=$,$.sourcesTail=null,$.flags=H$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{U=J,Q$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&D$)X.sink.flags|=D}$.flags=T}function k$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=U;U=$,$.sourcesTail=null,$.flags=H$;let X;try{X=$.fn($.value,J.signal)}catch(Q){$.controller=void 0,$.error=Q instanceof Error?Q:Error(String(Q));return}finally{U=z,Q$($)}X.then((Q)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(Q,$.value)){$.value=Q,$.error=void 0;for(let H=$.sinks;H;H=H.nextSink)I(H.sink);if(C===0)A()}},(Q)=>{if(J.signal.aborted)return;$.controller=void 0;let H=Q instanceof Error?Q:Error(String(Q));if(!$.error||H.name!==$.error.name||H.message!==$.error.message){$.error=H;for(let B=$.sinks;B;B=B.nextSink)I(B.sink);if(C===0)A()}}),$.flags=T}function Y$($){P$($);let J=U,z=p;U=p=$,$.sourcesTail=null,$.flags=H$;try{let X=$.fn();if(typeof X==="function")a($,X)}finally{U=J,p=z,Q$($)}$.flags=T}function E($){if($.flags&D$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)E(J.source);if($.flags&D)break}if($.flags&H$)throw new J$("controller"in $?u:("value"in $)?v:"Effect");if($.flags&D)if("controller"in $)k$($);else if("value"in $)g$($);else Y$($);else $.flags=T}function A(){if(A$)return;A$=!0;try{for(let $=0;$<m$.length;$++){let J=m$[$];if(J.flags&D)E(J)}m$.length=0}finally{A$=!1}}function e($){C++;try{$()}finally{if(C--,C===0)A()}}function s($){let J=U;U=null;try{return $()}finally{U=J}}function v$($){let J=p,z={cleanup:null};p=z;try{let X=$();if(typeof X==="function")a(z,X);let Q=()=>P$(z);if(J)a(J,Q);return Q}finally{p=J}}function h($,J){K(k,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??r,guard:J?.guard};return{[Symbol.toStringTag]:k,get(){if(U)O(z,U);return z.value},set(X){K(k,X,z.guard),B$(z,X)},update(X){_(k,X);let Q=X(z.value);K(k,Q,z.guard),B$(z,Q)}}}function q$($){return Y($,k)}function i($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new J$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let Q=$,H=J;if(Q.length!==H.length)return!1;for(let B=0;B<Q.length;B++)if(!i(Q[B],H[B],z))return!1;return!0}if(L($)&&L(J)){let Q=Object.keys($),H=Object.keys(J);if(Q.length!==H.length)return!1;for(let B of Q){if(!(B in J))return!1;if(!i($[B],J[B],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function M$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function f$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function u$($,J,z,X,Q){let H=new WeakSet,B={},q={},F={},P=[],W=!1,j=new Map;for(let G=0;G<$.length;G++){let Z=z[G];if(Z&&$[G])j.set(Z,$[G])}let N=new Set;for(let G=0;G<J.length;G++){let Z=J[G];if(Z===void 0)continue;let M=Q?X(Z):z[G]??X(Z);if(N.has(M))throw new n(b,M,Z);if(P.push(M),N.add(M),!j.has(M))B[M]=Z,W=!0;else if(!i(j.get(M),Z,H))q[M]=Z,W=!0}for(let[G]of j)if(!N.has(G))F[G]=null,W=!0;if(!W&&!M$(z,P))W=!0;return{add:B,change:q,remove:F,newKeys:P,changed:W}}function Z$($,J){K(b,$,Array.isArray);let z=new Map,X=[],[Q,H]=f$(J?.keyConfig),B=()=>X.map((Z)=>z.get(Z)?.get()).filter((Z)=>Z!==void 0),q={fn:B,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:i,error:void 0},F=(Z)=>{let M={};for(let m=0;m<Z.length;m++){let V=Z[m];if(V===void 0)continue;let R=X[m];if(!R)R=Q(V),X[m]=R;M[R]=V}return M},P=(Z)=>{let M=!1;for(let m in Z.add){let V=Z.add[m];K(`${b} item for key "${m}"`,V),z.set(m,h(V)),M=!0}if(Object.keys(Z.change).length)e(()=>{for(let m in Z.change){let V=Z.change[m];K(`${b} item for key "${m}"`,V);let R=z.get(m);if(R)R.set(V)}});for(let m in Z.remove){z.delete(m);let V=X.indexOf(m);if(V!==-1)X.splice(V,1);M=!0}if(M)q.sources=null,q.sourcesTail=null;return Z.changed},W=J?.watched,j=W?()=>{if(U){if(!q.sinks)q.stop=W();O(q,U)}}:()=>{if(U)O(q,U)},N=F($);for(let Z in N){let M=N[Z];K(`${b} item for key "${Z}"`,M),z.set(Z,h(M))}q.value=$,q.flags=0;let G={[Symbol.toStringTag]:b,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of X){let M=z.get(Z);if(M)yield M}},get length(){return j(),X.length},get(){if(j(),q.sources){if(q.flags)q.value=s(B),q.flags=T}else if(E(q),q.error)throw q.error;return q.value},set(Z){let M=q.flags&D?B():q.value,m=u$(M,Z,X,Q,H);if(m.changed){X=m.newKeys,P(m),q.flags|=D;for(let V=q.sinks;V;V=V.nextSink)I(V.sink);if(C===0)A()}},update(Z){G.set(Z(G.get()))},at(Z){return z.get(X[Z])},keys(){return j(),X.values()},byKey(Z){return z.get(Z)},keyAt(Z){return X[Z]},indexOfKey(Z){return X.indexOf(Z)},add(Z){let M=Q(Z);if(z.has(M))throw new n(b,M,Z);if(!X.includes(M))X.push(M);K(`${b} item for key "${M}"`,Z),z.set(M,h(Z)),q.sources=null,q.sourcesTail=null,q.flags|=D;for(let m=q.sinks;m;m=m.nextSink)I(m.sink);if(C===0)A();return M},remove(Z){let M=typeof Z==="number"?X[Z]:Z;if(z.delete(M)){let V=typeof Z==="number"?Z:X.indexOf(M);if(V>=0)X.splice(V,1);q.sources=null,q.sourcesTail=null,q.flags|=D;for(let R=q.sinks;R;R=R.nextSink)I(R.sink);if(C===0)A()}},sort(Z){let m=X.map((V)=>[V,z.get(V)?.get()]).sort(y(Z)?(V,R)=>Z(V[1],R[1]):(V,R)=>String(V[1]).localeCompare(String(R[1]))).map(([V])=>V);if(!M$(X,m)){X=m,q.flags|=D;for(let V=q.sinks;V;V=V.nextSink)I(V.sink);if(C===0)A()}},splice(Z,M,...m){let V=X.length,R=Z<0?Math.max(0,V+Z):Math.min(Z,V),x=Math.max(0,Math.min(M??Math.max(0,V-Math.max(0,R)),V-R)),w={},f={};for(let S=0;S<x;S++){let o=R+S,O$=X[o];if(O$){let E$=z.get(O$);if(E$)f[O$]=E$.get()}}let K$=X.slice(0,R);for(let S of m){let o=Q(S);if(z.has(o)&&!(o in f))throw new n(b,o,S);K$.push(o),w[o]=S}K$.push(...X.slice(R+x));let T$=!!(Object.keys(w).length||Object.keys(f).length);if(T$){P({add:w,change:{},remove:f,changed:T$}),X=K$,q.flags|=D;for(let S=q.sinks;S;S=S.nextSink)I(S.sink);if(C===0)A()}return Object.values(f)},deriveCollection(Z){return F$(G,Z)}};return G}function U$($){return Y($,b)}function j$($,J){if(_(v,$,$$),J?.value!==void 0)K(v,J.value,J?.guard);let z={fn:$,value:J?.value,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??r,error:void 0,stop:void 0},X=J?.watched,Q=X?()=>{if(U){if(!z.sinks)z.stop=X(()=>{z.flags|=D;for(let H=z.sinks;H;H=H.nextSink)I(H.sink);if(C===0)A()});O(z,U)}}:()=>{if(U)O(z,U)};return{[Symbol.toStringTag]:v,get(){if(Q(),E(z),z.error)throw z.error;return X$(v,z.value),z.value}}}function L$($){return Y($,v)}function W$($,J){if(_(u,$,l),J?.value!==void 0)K(u,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:D,equals:J?.equals??r,controller:void 0,error:void 0,stop:void 0},X=J?.watched,Q=X?()=>{if(U){if(!z.sinks)z.stop=X(()=>{z.flags|=D;for(let H=z.sinks;H;H=H.nextSink)I(H.sink);if(C===0)A()});O(z,U)}}:()=>{if(U)O(z,U)};return{[Symbol.toStringTag]:u,get(){if(Q(),E(z),z.error)throw z.error;return X$(u,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function _$($){return Y($,u)}function F$($,J){if(_(g,J),!d$($))throw TypeError(`[${g}] Invalid collection source: expected a List or Collection`);let z=l(J),X=new Map,Q=(W)=>{let j=z?W$(async(N,G)=>{let Z=$.byKey(W)?.get();if(Z==null)return N;return J(Z,G)}):j$(()=>{let N=$.byKey(W)?.get();if(N==null)return;return J(N)});X.set(W,j)};function H(){let W=Array.from($.keys()),j=B.value;if(!M$(j,W)){let N=new Set(j),G=new Set(W);for(let Z of j)if(!G.has(Z))X.delete(Z);for(let Z of W)if(!N.has(Z))Q(Z)}return W}let B={fn:H,value:[],flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:M$,error:void 0};function q(){if(B.sources){if(B.flags)B.value=s(H),B.flags=T}else if(E(B),B.error)throw B.error;return B.value}let F=Array.from($.keys());for(let W of F)Q(W);B.value=F;let P={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let W of B.value){let j=X.get(W);if(j)yield j}},get length(){if(U)O(B,U);return q().length},keys(){if(U)O(B,U);return q().values()},get(){if(U)O(B,U);let W=q(),j=[];for(let N of W)try{let G=X.get(N)?.get();if(G!=null)j.push(G)}catch(G){if(!(G instanceof t))throw G}return j},at(W){return X.get(B.value[W])},byKey(W){return X.get(W)},keyAt(W){return B.value[W]},indexOfKey(W){return B.value.indexOf(W)},deriveCollection(W){return F$(P,W)}};return P}function c$($,J){let z=J?.value??[];if(z.length)K(g,z,Array.isArray);_(g,$,$$);let X=new Map,Q=[],H=new Map,[B,q]=f$(J?.keyConfig),F=(Z)=>H.get(Z)??(q?B(Z):void 0),P=J?.createItem??h;function W(){let Z=[];for(let M of Q)try{let m=X.get(M)?.get();if(m!=null)Z.push(m)}catch(m){if(!(m instanceof t))throw m}return Z}let j={fn:W,value:z,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:w$,error:void 0};for(let Z of z){let M=B(Z);X.set(M,P(Z)),H.set(Z,M),Q.push(M)}j.value=z,j.flags=D;function N(){if(U){if(!j.sinks)j.stop=$((Z)=>{let{add:M,change:m,remove:V}=Z;if(!M?.length&&!m?.length&&!V?.length)return;let R=!1;e(()=>{if(M)for(let x of M){let w=B(x);if(X.set(w,P(x)),H.set(x,w),!Q.includes(w))Q.push(w);R=!0}if(m)for(let x of m){let w=F(x);if(!w)continue;let f=X.get(w);if(f&&q$(f))H.delete(f.get()),f.set(x),H.set(x,w)}if(V)for(let x of V){let w=F(x);if(!w)continue;H.delete(x),X.delete(w);let f=Q.indexOf(w);if(f!==-1)Q.splice(f,1);R=!0}if(R)j.sources=null,j.sourcesTail=null;j.flags=D;for(let x=j.sinks;x;x=x.nextSink)I(x.sink)})});O(j,U)}}let G={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of Q){let M=X.get(Z);if(M)yield M}},get length(){return N(),Q.length},keys(){return N(),Q.values()},get(){if(N(),j.sources){if(j.flags)j.value=s(W),j.flags=T}else if(E(j),j.error)throw j.error;return j.value},at(Z){return X.get(Q[Z])},byKey(Z){return X.get(Z)},keyAt(Z){return Q[Z]},indexOfKey(Z){return Q.indexOf(Z)},deriveCollection(Z){return F$(G,Z)}};return G}function S$($){return Y($,g)}function d$($){return U$($)||S$($)}function l$($){_("Effect",$);let J={fn:$,flags:D,sources:null,sourcesTail:null,cleanup:null},z=()=>{P$(J),J.fn=void 0,J.flags=T,J.sourcesTail=null,Q$(J)};if(p)a(p,z);return Y$(J),z}function t$($,J){if(!p)throw new G$("match");let{ok:z,err:X=console.error,nil:Q}=J,H,B=!1,q=Array($.length);for(let P=0;P<$.length;P++)try{q[P]=$[P].get()}catch(W){if(W instanceof t){B=!0;continue}if(!H)H=[];H.push(W instanceof Error?W:Error(String(W)))}let F;try{if(B)F=Q?.();else if(H)F=X(H);else F=z(q)}catch(P){X([P instanceof Error?P:Error(String(P))])}if(typeof F==="function")return F;if(F instanceof Promise){let P=p,W=new AbortController;a(P,()=>W.abort()),F.then((j)=>{if(!W.signal.aborted&&typeof j==="function")a(P,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function r$($,J){if(_(c,$,$$),J?.value!==void 0)K(c,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??r,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:c,get(){if(U){if(!z.sinks)z.stop=$((X)=>{K(c,X,z.guard),B$(z,X)});O(z,U)}return X$(c,z.value),z.value}}}function s$($){return Y($,c)}function i$($,J){let z=L($)||Array.isArray($),X=L(J)||Array.isArray(J);if(!z||!X){let j=!Object.is($,J);return{changed:j,add:j&&X?J:{},change:{},remove:j&&z?$:{}}}let Q=new WeakSet,H={},B={},q={},F=!1,P=Object.keys($),W=Object.keys(J);for(let j of W)if(j in $){if(!i($[j],J[j],Q))B[j]=J[j],F=!0}else H[j]=J[j],F=!0;for(let j of P)if(!(j in J))q[j]=void 0,F=!0;return{add:H,change:B,remove:q,changed:F}}function N$($,J){K(d,$,L);let z=new Map,X=(W,j)=>{if(K(`${d} for key "${W}"`,j),Array.isArray(j))z.set(W,Z$(j));else if(L(j))z.set(W,N$(j));else z.set(W,h(j))},Q=()=>{let W={};return z.forEach((j,N)=>{W[N]=j.get()}),W},H={fn:Q,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:i,error:void 0},B=(W)=>{let j=!1;for(let N in W.add)X(N,W.add[N]),j=!0;if(Object.keys(W.change).length)e(()=>{for(let N in W.change){let G=W.change[N];K(`${d} for key "${N}"`,G);let Z=z.get(N);if(Z)if(L(G)!==R$(Z))X(N,G),j=!0;else Z.set(G)}});for(let N in W.remove)z.delete(N),j=!0;if(j)H.sources=null,H.sourcesTail=null;return W.changed},q=J?.watched,F=q?()=>{if(U){if(!H.sinks)H.stop=q();O(H,U)}}:()=>{if(U)O(H,U)};for(let W of Object.keys($))X(W,$[W]);let P={[Symbol.toStringTag]:d,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let j=z.get(W);if(j)yield[W,j]}},keys(){return F(),z.keys()},byKey(W){return z.get(W)},get(){if(F(),H.sources){if(H.flags)H.value=s(Q),H.flags=T}else if(E(H),H.error)throw H.error;return H.value},set(W){let j=H.flags&D?Q():H.value,N=i$(j,W);if(B(N)){H.flags|=D;for(let G=H.sinks;G;G=G.nextSink)I(G.sink);if(C===0)A()}},update(W){P.set(W(P.get()))},add(W,j){if(z.has(W))throw new n(d,W,j);X(W,j),H.sources=null,H.sourcesTail=null,H.flags|=D;for(let N=H.sinks;N;N=N.nextSink)I(N.sink);if(C===0)A();return W},remove(W){if(z.delete(W)){H.sources=null,H.sourcesTail=null,H.flags|=D;for(let N=H.sinks;N;N=N.nextSink)I(N.sink);if(C===0)A()}}};return new Proxy(P,{get(W,j){if(j in W)return Reflect.get(W,j);if(typeof j!=="symbol")return W.byKey(j)},has(W,j){if(j in W)return!0;return W.byKey(String(j))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,j){if(j in W)return Reflect.getOwnPropertyDescriptor(W,j);if(typeof j==="symbol")return;let N=W.byKey(String(j));return N?{enumerable:!0,configurable:!0,writable:!0,value:N}:void 0}})}function R$($){return Y($,d)}function o$($,J){return l($)?W$($,J):j$($,J)}function n$($){if(b$($))return $;if($==null)throw new z$("createSignal",$);if(l($))return W$($);if(y($))return j$($);if(C$($))return Z$($);if(L($))return N$($);return h($)}function a$($){if(h$($))return $;if($==null||y($)||b$($))throw new z$("createMutableSignal",$);if(C$($))return Z$($);if(L($))return N$($);return h($)}function e$($){return L$($)||_$($)}function b$($){let J=[k,v,u,c,b,g,d],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function h$($){return q$($)||R$($)||U$($)}export{V$ as valueString,s as untrack,t$ as match,_$ as isTask,R$ as isStore,q$ as isState,b$ as isSignal,s$ as isSensor,L as isRecord,Y as isObjectOfType,h$ as isMutableSignal,L$ as isMemo,U$ as isList,y as isFunction,i as isEqual,e$ as isComputed,S$ as isCollection,l as isAsyncFunction,W$ as createTask,N$ as createStore,h as createState,n$ as createSignal,r$ as createSensor,v$ as createScope,a$ as createMutableSignal,j$ as createMemo,Z$ as createList,l$ as createEffect,o$ as createComputed,c$ as createCollection,e as batch,t as UnsetSignalValueError,w$ as SKIP_EQUALITY,G$ as RequiredOwnerError,I$ as NullishSignalValueError,z$ as InvalidSignalValueError,x$ as InvalidCallbackError,J$ as CircularDependencyError};
