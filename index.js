var M=($)=>typeof $==="function",E=($)=>M($)&&$.constructor.name==="AsyncFunction",_=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,c=($)=>$ instanceof Error,D=($)=>$ instanceof DOMException&&$.name==="AbortError",h=($)=>$ instanceof Promise,Y=($)=>c($)?$:Error(String($));class x extends Error{constructor($){super(`Circular dependency in ${$} detected`);return this}}var R,U=new Set,g=0,p=new Map,S,s=()=>{S=void 0;let $=Array.from(p.values());p.clear();for(let B of $)B()},t=()=>{if(S)cancelAnimationFrame(S);S=requestAnimationFrame(s)};queueMicrotask(s);var q=($)=>{if(R&&!$.has(R)){let B=R;$.add(B),R.cleanups.add(()=>{$.delete(B)})}},V=($)=>{for(let B of $)if(g)U.add(B);else B()},P=()=>{while(U.size){let $=Array.from(U);U.clear();for(let B of $)B()}},r=($)=>{g++;try{$()}finally{P(),g--}},F=($,B)=>{let G=R;R=B;try{$()}finally{R=G}},a=($,B)=>new Promise((G,z)=>{p.set(B||Symbol(),()=>{try{G($())}catch(J){z(J)}}),t()});function I($){let{signals:B,ok:G,err:z=console.error,nil:J=()=>{}}=M($)?{signals:[],ok:$}:$,X=!1,L=()=>F(()=>{if(X)throw new x("effect");X=!0;let W=void 0;try{let Z=[],K=!1,C=B.map((A)=>{try{let j=A.get();if(j===Q)K=!0;return j}catch(j){if(D(j))throw j;return Z.push(Y(j)),Q}});try{W=K?J():Z.length?z(...Z):G(...C)}catch(A){if(D(A))throw A;let j=Y(A);W=z(j)}}catch(Z){z(Y(Z))}if(M(W))L.cleanups.add(W);X=!1},L);return L.cleanups=new Set,L(),()=>{L.cleanups.forEach((W)=>W()),L.cleanups.clear()}}var b=($)=>{let B=new Set,G=Q,z,J=!0,X=!1,L=()=>{if(J=!0,B.size)V(B);else L.cleanups.forEach((K)=>K()),L.cleanups.clear()};L.cleanups=new Set;let W=()=>F(()=>{if(X)throw new x("memo");X=!0;try{let K=$();if(K==null||Q===K)G=Q,z=void 0;else G=K,J=!1,z=void 0}catch(K){G=Q,z=K instanceof Error?K:new Error(String(K))}finally{X=!1}},L),Z={[Symbol.toStringTag]:N,get:()=>{if(q(B),P(),J)W();if(z)throw z;return G},map:(K)=>y(Z,K),tap:(K)=>I({signals:[Z],...typeof K==="function"?{ok:K}:K})};return Z};var T=($)=>{let B=new Set,G=Q,z,J=!0,X=!1,L=!1,W,Z=(H)=>{if(!Object.is(H,G))G=H,J=!1,z=void 0,X=!0},K=()=>{X=Q!==G,G=Q,z=void 0},C=(H)=>{let O=Y(H);X=!(z&&O.name===z.name&&O.message===z.message),G=Q,z=O},A=(H)=>{if(L=!1,W=void 0,Z(H),X)V(B)},j=(H)=>{if(L=!1,W=void 0,C(H),X)V(B)},u=()=>{L=!1,W=void 0,o()},k=()=>{if(J=!0,W?.abort("Aborted because source signal changed"),B.size)V(B);else k.cleanups.forEach((H)=>H()),k.cleanups.clear()};k.cleanups=new Set;let o=()=>F(()=>{if(L)throw new x("task");X=!1,W=new AbortController,W.signal.addEventListener("abort",u,{once:!0});let H;L=!0;try{H=$(W.signal)}catch(O){if(D(O))K();else C(O);L=!1;return}if(h(H))H.then(A,j);else if(H==null||Q===H)K();else Z(H);L=!1},k),w={[Symbol.toStringTag]:N,get:()=>{if(q(B),P(),J)o();if(z)throw z;return G},map:(H)=>y(w,H),tap:(H)=>I({signals:[w],...typeof H==="function"?{ok:H}:H})};return w};var N="Computed",d=($)=>E($)?T($):b($),y=($,B)=>E(B)?T(()=>B($.get())):b(()=>B($.get())),v=($)=>_($,N);var i="State",f=($)=>{let B=new Set,G=$,z={[Symbol.toStringTag]:i,get:()=>{return q(B),G},set:(J)=>{if(Object.is(G,J))return;if(G=J,V(B),Q===G)B.clear()},update:(J)=>{z.set(J(G))},map:(J)=>y(z,J),tap:(J)=>I({signals:[z],...typeof J==="function"?{ok:J}:J})};return z},m=($)=>_($,i);var Q=Symbol(),n=($)=>m($)||v($),l=($)=>M($)&&$.length<2,e=($)=>n($)?$:l($)?d($):f($);export{F as watch,e as toSignal,T as task,f as state,b as memo,m as isState,n as isSignal,l as isComputedCallback,v as isComputed,a as enqueue,I as effect,d as computed,r as batch,Q as UNSET,x as CircularDependencyError};
