var q=(y)=>typeof y==="function";var M=(y,x)=>Object.prototype.toString.call(y)===`[object ${x}]`,E=(y)=>(x)=>x instanceof y,A=E(Error),f=E(Promise),V=(y)=>A(y)?y:new Error(String(y));var X,R=new Set,_=0,T=new Map,S,g=()=>{S=void 0;let y=Array.from(T.values());T.clear();for(let x of y)x()},v=()=>{if(S)cancelAnimationFrame(S);S=requestAnimationFrame(g)};queueMicrotask(g);var N=(y)=>{if(X&&!y.includes(X))y.push(X)},I=(y)=>{for(let x of y)if(_)R.add(x);else x()},w=()=>{while(R.size){let y=Array.from(R);R.clear();for(let x of y)x()}},n=(y)=>{_++;try{y()}finally{w(),_--}},j=(y,x)=>{let $=X;X=x;try{y()}finally{X=$}},i=(y,x)=>new Promise(($,L)=>{let B=()=>{try{$(y())}catch(K){L(K)}};if(x)T.set(x,B);v()});function C(y,...x){let $=!1,L=()=>j(()=>{if($)throw new Error("Circular dependency in effect detected");$=!0;let B=D(x,y);if(A(B))console.error("Unhandled error in effect:",B);$=!1},L);L()}var p="Computed",c=(y,x)=>{if(!x)return!1;return y.name===x.name&&y.message===x.message},Z=(y,...x)=>{let $=[],L=H,B,K=!0,F=!1,Q=!1,G=(z)=>{if(!Object.is(z,L))L=z,K=!1,B=void 0,F=!1},J=()=>{F=H===L,L=H,B=void 0},O=(z)=>{let P=V(z);F=c(P,B),L=H,B=P},W=()=>{if(K=!0,!F)I($)},d=()=>j(()=>{if(Q)throw new Error("Circular dependency in computed detected");F=!0,Q=!0;let z=D(x,y);if(f(z))J(),z.then((P)=>{G(P),I($)}).catch(O);else if(z==null||H===z)J();else if(A(z))O(z);else G(z);Q=!1},W),Y={[Symbol.toStringTag]:p,get:()=>{if(N($),w(),K)d();if(B)throw B;return L},map:(z)=>Z(z,Y),match:(z)=>{return C(z,Y),Y}};return Y},U=(y)=>M(y,p);var b="State",k=(y)=>{let x=[],$=y,L={[Symbol.toStringTag]:b,get:()=>{return N(x),$},set:(B)=>{if(Object.is($,B))return;if($=B,I(x),H===$)x.length=0},update:(B)=>{L.set(B($))},map:(B)=>Z(B,L),match:(B)=>{return C(B,L),L}};return L},m=(y)=>M(y,b);var H=Symbol(),h=(y)=>m(y)||U(y),o=(y)=>q(y)&&!y.length||typeof y==="object"&&y!==null&&("ok"in y)&&q(y.ok),t=(y)=>h(y)?y:o(y)?Z(y):k(y),D=(y,x)=>{let{ok:$,nil:L,err:B}=q(x)?{ok:x}:x,K=[],F=[],Q=!1;for(let J=0;J<y.length;J++){let O=y[J];try{let W=O.get();if(W===H)Q=!0;K[J]=W}catch(W){F.push(V(W))}}let G=void 0;try{if(Q&&L)G=L();else if(F.length)G=B?B(...F):F[0];else if(!Q)G=$(...K)}catch(J){if(G=V(J),B)G=B(G)}return G};export{j as watch,t as toSignal,k as state,m as isState,h as isSignal,o as isComputedCallbacks,U as isComputed,i as enqueue,C as effect,Z as computed,n as batch,H as UNSET};
