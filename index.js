class L extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class c extends TypeError{constructor($,R){super(`Invalid signal value ${R} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class v extends Error{constructor($,R){super(`Could not add store key "${$}" with value ${R} because it already exists`);this.name="StoreKeyExistsError"}}class n extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class u extends Error{constructor($,R){super(`Could not set store key "${$}" to ${R} because it is readonly`);this.name="StoreKeyReadonlyError"}}var K=Symbol(),e=($)=>typeof $==="string",C$=($)=>typeof $==="number",y=($)=>typeof $==="symbol",Y=($)=>typeof $==="function",g=($)=>Y($)&&$.constructor.name==="AsyncFunction",V=($,R)=>Object.prototype.toString.call($)===`[object ${R}]`,T=($)=>V($,"Object"),t=($)=>T($)||Array.isArray($),I$=($)=>{if(!$.length)return null;let R=$.map((G)=>e(G)?parseInt(G,10):C$(G)?G:NaN);return R.every((G)=>Number.isFinite(G)&&G>=0)?R.sort((G,J)=>G-J):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var s=($)=>{let R=I$(Object.keys($));if(R===null)return $;let G=[];for(let J of R)G.push($[String(J)]);return G},b=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var A=($,R,G)=>{if(Object.is($,R))return!0;if(typeof $!==typeof R)return!1;if(typeof $!=="object"||$===null||R===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(R))throw new L("isEqual");G.add($),G.add(R);try{if(Array.isArray($)&&Array.isArray(R)){if($.length!==R.length)return!1;for(let J=0;J<$.length;J++)if(!A($[J],R[J],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(R))return!1;if(T($)&&T(R)){let J=Object.keys($),X=Object.keys(R);if(J.length!==X.length)return!1;for(let C of J){if(!(C in R))return!1;if(!A($[C],R[C],G))return!1}return!0}return!1}finally{G.delete($),G.delete(R)}},$$=($,R)=>{let G=t($),J=t(R);if(!G||!J){let I=!Object.is($,R);return{changed:I,add:I&&J?R:{},change:{},remove:I&&G?$:{}}}let X=new WeakSet,C={},W={},H={},D=Object.keys($),P=Object.keys(R),m=new Set([...D,...P]);for(let I of m){let z=I in $,F=I in R;if(!z&&F){C[I]=R[I];continue}else if(z&&!F){H[I]=K;continue}let B=$[I],x=R[I];if(!A(B,x,X))W[I]=x}return{changed:Object.keys(C).length>0||Object.keys(W).length>0||Object.keys(H).length>0,add:C,change:W,remove:H}};var S,i=new Set,R$=0,k=($)=>{let R=new Set,G=$;return G.off=(J)=>{R.add(J)},G.cleanup=()=>{for(let J of R)J();R.clear()},G},_=($)=>{if(S&&!$.has(S)){let R=S;$.add(R),S.off(()=>{$.delete(R)})}},N=($)=>{for(let R of $)if(R$)i.add(R);else R()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let R of $)R()}},x$=($)=>{R$++;try{$()}finally{r(),R$--}},h=($,R)=>{let G=S;S=R;try{$()}finally{S=G}};var B$="Computed",J$=($)=>{let R=new Set,G=K,J,X,C=!0,W=!1,H=!1,D=(B)=>{if(!A(B,G))G=B,W=!0;J=void 0,C=!1},P=()=>{W=K!==G,G=K,J=void 0},m=(B)=>{let x=U(B);W=!J||x.name!==J.name||x.message!==J.message,G=K,J=x},j=(B)=>(x)=>{if(H=!1,X=void 0,B(x),W)N(R)},I=k(()=>{if(C=!0,X?.abort(),R.size)N(R);else I.cleanup()});I.off(()=>{X?.abort()});let z=()=>h(()=>{if(H)throw new L("computed");if(W=!1,g($)){if(X)return G;X=new AbortController,X.signal.addEventListener("abort",()=>{H=!1,X=void 0,z()},{once:!0})}let B;H=!0;try{B=X?$(X.signal):$()}catch(x){if(O(x))P();else m(x);H=!1;return}if(B instanceof Promise)B.then(j(D),j(m));else if(B==null||K===B)P();else D(B);H=!1},I);return{[Symbol.toStringTag]:B$,get:()=>{if(_(R),r(),C)z();if(J)throw J;return G}}},d=($)=>V($,B$),G$=($)=>Y($)&&$.length<2;var M$=($)=>{let R=g($),G=!1,J,X=k(()=>h(()=>{if(G)throw new L("effect");G=!0,J?.abort(),J=void 0;let C;try{if(R){J=new AbortController;let W=J;$(J.signal).then((H)=>{if(Y(H)&&J===W)X.off(H)}).catch((H)=>{if(!O(H))console.error("Async effect error:",H)})}else if(C=$(),Y(C))X.off(C)}catch(W){if(!O(W))console.error("Effect callback error:",W)}G=!1},X));return X(),()=>{J?.abort(),X.cleanup()}};function K$($,R){try{if($.pending)R.nil?.();else if($.errors)R.err?.($.errors);else if($.ok)R.ok($.values)}catch(G){if(R.err&&(!$.errors||!$.errors.includes(U(G))))R.err($.errors?[...$.errors,U(G)]:[U(G)]);else throw G}}function q$($){let R=[],G=!1,J={};for(let[X,C]of Object.entries($))try{let W=C.get();if(W===K)G=!0;else J[X]=W}catch(W){R.push(U(W))}if(G)return{ok:!1,pending:!0};if(R.length>0)return{ok:!1,errors:R};return{ok:!0,values:J}}var Q$="State",E=($)=>{let R=new Set,G=$,J={[Symbol.toStringTag]:Q$,get:()=>{return _(R),G},set:(X)=>{if(X==null)throw new f("state");if(A(G,X))return;if(G=X,N(R),K===G)R.clear()},update:(X)=>{J.set(X(G))}};return J},w=($)=>V($,Q$);var l="Store",a=($)=>{let R=new Set,G={add:new Set,change:new Set,remove:new Set,sort:new Set},J=new Map,X=new Map,C=Array.isArray($),W=E(0),H=()=>{let B={};for(let[x,M]of J)B[x]=M.get();return B},D=(B,x)=>{Object.freeze(x);for(let M of G[B])M(x)},P=()=>Array.from(J.keys()).map((B)=>Number(B)).filter((B)=>Number.isInteger(B)).sort((B,x)=>B-x),m=(B,x)=>{if(x==null)throw new f(`store for key "${B}"`);if(x===K)return!0;if(y(x)||Y(x)||d(x))throw new c(`store for key "${B}"`,b(x));return!0},j=(B,x,M=!1)=>{if(!m(B,x))return!1;let Q=w(x)||p(x)?x:T(x)||Array.isArray(x)?a(x):E(x);J.set(B,Q);let Z=M$(()=>{let q=Q.get();if(q!=null)D("change",{[B]:q})});if(X.set(B,Z),M)W.set(J.size),N(R),D("add",{[B]:x});return!0},I=(B,x=!1)=>{let M=J.delete(B);if(M){let Q=X.get(B);if(Q)Q();X.delete(B)}if(x)W.set(J.size),N(R),D("remove",{[B]:K});return M},z=(B,x,M)=>{let Q=$$(B,x);return x$(()=>{if(Object.keys(Q.add).length){for(let Z in Q.add){let q=Q.add[Z]??K;j(Z,q)}if(M)setTimeout(()=>{D("add",Q.add)},0);else D("add",Q.add)}if(Object.keys(Q.change).length){for(let Z in Q.change){let q=Q.change[Z];if(!m(Z,q))continue;let o=J.get(Z);if(X$(o))o.set(q);else throw new u(Z,b(q))}D("change",Q.change)}if(Object.keys(Q.remove).length){for(let Z in Q.remove)I(Z);D("remove",Q.remove)}W.set(J.size)}),Q.changed};z({},$,!0);let F={add:C?(B)=>{let x=J.size,M=String(x);j(M,B,!0)}:(B,x)=>{if(!J.has(B))j(B,x,!0);else throw new v(B,b(x))},get:()=>{return _(R),s(H())},remove:C?(B)=>{let x=s(H()),M=J.size;if(!Array.isArray(x)||B<=-M||B>=M)throw new n(B);let Q=[...x];if(Q.splice(B,1),z(x,Q))N(R)}:(B)=>{if(J.has(B))I(B,!0)},set:(B)=>{if(z(H(),B)){if(N(R),K===B)R.clear()}},update:(B)=>{let x=H(),M=B(s(x));if(z(x,M)){if(N(R),K===M)R.clear()}},sort:(B)=>{let x=Array.from(J.entries()).map(([Z,q])=>[Z,q.get()]).sort(B?(Z,q)=>B(Z[1],q[1]):(Z,q)=>String(Z[1]).localeCompare(String(q[1]))),M=x.map(([Z])=>String(Z)),Q=new Map;x.forEach(([Z],q)=>{let o=String(Z),H$=C?String(q):String(Z),Z$=J.get(o);if(Z$)Q.set(H$,Z$)}),J.clear(),Q.forEach((Z,q)=>J.set(q,Z)),N(R),D("sort",M)},on:(B,x)=>{return G[B].add(x),()=>G[B].delete(x)},size:W};return new Proxy({},{get(B,x){if(x===Symbol.toStringTag)return l;if(x===Symbol.isConcatSpreadable)return C;if(x===Symbol.iterator)return C?function*(){let M=P();for(let Q of M){let Z=J.get(String(Q));if(Z)yield Z}}:function*(){for(let[M,Q]of J)yield[M,Q]};if(y(x))return;if(x in F)return F[x];if(x==="length"&&C)return _(R),W.get();return J.get(x)},has(B,x){let M=String(x);return M&&J.has(M)||Object.keys(F).includes(M)||x===Symbol.toStringTag||x===Symbol.iterator||x===Symbol.isConcatSpreadable||x==="length"&&C},ownKeys(){return C?P().map((B)=>String(B)).concat(["length"]):Array.from(J.keys()).map((B)=>String(B))},getOwnPropertyDescriptor(B,x){let M=(Z)=>({enumerable:!1,configurable:!0,writable:!1,value:Z});if(x==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:W.get()};if(x===Symbol.isConcatSpreadable)return M(C);if(x===Symbol.toStringTag)return M(l);if(y(x))return;if(Object.keys(F).includes(x))return M(F[x]);let Q=J.get(x);return Q?{enumerable:!0,configurable:!0,writable:!0,value:Q}:void 0}})},p=($)=>V($,l);var W$=($)=>w($)||d($)||p($),X$=($)=>w($)||p($);function D$($){if(W$($))return $;if(G$($))return J$($);if(Array.isArray($)||T($))return a($);return E($)}export{b as valueString,D$ as toSignal,U as toError,_ as subscribe,q$ as resolve,h as observe,N as notify,K$ as match,y as isSymbol,e as isString,p as isStore,w as isState,W$ as isSignal,t as isRecordOrArray,T as isRecord,C$ as isNumber,X$ as isMutableSignal,Y as isFunction,A as isEqual,G$ as isComputedCallback,d as isComputed,g as isAsyncFunction,O as isAbortError,r as flush,$$ as diff,k as createWatcher,a as createStore,E as createState,M$ as createEffect,J$ as createComputed,x$ as batch,K as UNSET,l as TYPE_STORE,Q$ as TYPE_STATE,B$ as TYPE_COMPUTED,u as StoreKeyReadonlyError,n as StoreKeyRangeError,v as StoreKeyExistsError,f as NullishSignalValueError,c as InvalidSignalValueError,L as CircularDependencyError};
