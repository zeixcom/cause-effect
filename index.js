var I,k=new Set,T=0,m=new Map,C,c=()=>{C=void 0;let $=Array.from(m.values());m.clear();for(let G of $)G()},u=()=>{if(C)cancelAnimationFrame(C);C=requestAnimationFrame(c)};queueMicrotask(c);var N=($)=>{let G=new Set,J=$;return J.off=(z)=>{G.add(z)},J.cleanup=()=>{for(let z of G)z();G.clear()},J},R=($)=>{if(I&&!$.has(I)){let G=I;$.add(G),I.off(()=>{$.delete(G)})}},D=($)=>{for(let G of $)if(T)k.add(G);else G()},S=()=>{while(k.size){let $=Array.from(k);k.clear();for(let G of $)G()}},t=($)=>{T++;try{$()}finally{S(),T--}},y=($,G)=>{let J=I;I=G;try{$()}finally{I=J}},l=($,G)=>new Promise((J,z)=>{m.set(G||Symbol(),()=>{try{J($())}catch(K){z(K)}}),u()});var B=($)=>typeof $==="function",F=($)=>B($)&&$.constructor.name==="AsyncFunction",E=($,G)=>Object.prototype.toString.call($)===`[object ${G}]`,w=($)=>$ instanceof DOMException&&$.name==="AbortError",x=($)=>$ instanceof Error?$:Error(String($));class U extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var g="State",f=($)=>{let G=new Set,J=$,z={[Symbol.toStringTag]:g,get:()=>{return R(G),J},set:(K)=>{if(Object.is(J,K))return;if(J=K,D(G),V===J)G.clear()},update:(K)=>{z.set(K(J))}};return z},h=($)=>E($,g);var V=Symbol(),o=($)=>h($)||b($),n=($)=>o($)?$:v($)?p($):f($);var d="Computed",s="Aborted because source signal changed",i="Aborted because cleanup was called",p=($)=>{let G=new Set,J=V,z,K,Y=!0,j=!1,Z=!1,L=(H)=>{if(!Object.is(H,J))J=H,j=!0;z=void 0,Y=!1},M=()=>{j=V!==J,J=V,z=void 0},O=(H)=>{let q=x(H);j=!z||q.name!==z.name||q.message!==z.message,J=V,z=q},Q=(H)=>(q)=>{if(Z=!1,K=void 0,H(q),j)D(G)},W=N(()=>{if(Y=!0,K?.abort(s),G.size)D(G);else W.cleanup()});W.off(()=>{K?.abort(i)});let X=()=>y(()=>{if(Z)throw new U("computed");if(j=!1,F($)){if(K)return J;K=new AbortController,K.signal.addEventListener("abort",()=>{Z=!1,K=void 0,X()},{once:!0})}let H;Z=!0;try{H=K?$(K.signal):$()}catch(q){if(w(q))M();else O(q);Z=!1;return}if(H instanceof Promise)H.then(Q(L),Q(O));else if(H==null||V===H)M();else L(H);Z=!1},W);return{[Symbol.toStringTag]:d,get:()=>{if(R(G),S(),Y)X();if(z)throw z;return J}}},b=($)=>E($,d),v=($)=>B($)&&$.length<2;function r($){let{signals:G,ok:J,err:z=console.error,nil:K=()=>{}}=F($)?{signals:[],ok:$}:B($)?{signals:[],ok:$}:$,Y=!1,j,Z=N(()=>y(()=>{if(Y)throw new U("effect");Y=!0,j?.abort(s),j=void 0;let L=[],M=!1,O=G.map((X)=>{try{let P=X.get();if(P===V)M=!0;return P}catch(P){return L.push(x(P)),V}}),Q,W;try{if([J,K,z].some(F))j=new AbortController;if(W=j?.signal,M)Q=_(K)?K(W):A(K)?K():void 0;else if(L.length)Q=_(z)?z(W,...L):A(z)?z(...L):void 0;else Q=_(J)?J(W,...O):J(...O)}catch(X){Q=w(X)?void 0:_(z)?z(W,x(X),...L):A(z)?z(x(X),...L):void 0}finally{if(Q instanceof Promise)Q.then((X)=>{if(B(X))Z.off(X)}).catch((X)=>{if(Q=_(z)?z(W,x(X),...L):A(z)?z(x(X),...L):void 0,Q instanceof Promise)Q.catch(console.error);else if(B(Q))Z.off(Q)});else if(B(Q))Z.off(Q)}Y=!1},Z));return Z(),()=>{j?.abort(i),Z.cleanup()}}var _=($)=>F($),A=($)=>B($);export{N as watch,n as toSignal,R as subscribe,f as state,y as observe,D as notify,h as isState,o as isSignal,B as isFunction,v as isComputedCallback,b as isComputed,S as flush,l as enqueue,r as effect,p as computed,t as batch,V as UNSET,g as TYPE_STATE,d as TYPE_COMPUTED,U as CircularDependencyError};
