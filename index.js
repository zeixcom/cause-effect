var O,c=new Set,s=0,t=new Map,d,x$=()=>{d=void 0;let $=Array.from(t.values());t.clear();for(let B of $)B()},L$=()=>{if(d)cancelAnimationFrame(d);d=requestAnimationFrame(x$)};queueMicrotask(x$);var g=($)=>{let B=new Set,W=$;return W.off=(x)=>{B.add(x)},W.cleanup=()=>{for(let x of B)x();B.clear()},W},S=($)=>{if(O&&!$.has(O)){let B=O;$.add(B),O.off(()=>{$.delete(B)})}},D=($)=>{for(let B of $)if(s)c.add(B);else B()},i=()=>{while(c.size){let $=Array.from(c);c.clear();for(let B of $)B()}},u=($)=>{s++;try{$()}finally{i(),s--}},V=($,B)=>{let W=O;O=B;try{$()}finally{O=W}},Q$=($,B)=>new Promise((W,x)=>{t.set(B||Symbol(),()=>{try{W($())}catch(L){x(L)}}),L$()});var I=($)=>typeof $==="function",w=($)=>I($)&&$.constructor.name==="AsyncFunction",R=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,j=($)=>R($,"Object"),p=($)=>typeof $!=="object"&&!I($),k=($)=>{let B={};for(let W=0;W<$.length;W++)if(W in $)B[String(W)]=$[W];return B},G$=($,B)=>(B in $)&&I($[B]),m=($)=>$ instanceof DOMException&&$.name==="AbortError",K=($)=>$ instanceof Error?$:Error(String($));class H extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var r="State",T=($)=>{let B=new Set,W=$,x={[Symbol.toStringTag]:r,get:()=>{return S(B),W},set:(L)=>{if(Object.is(W,L))return;if(W=L,D(B),C===W)B.clear()},update:(L)=>{x.set(L(W))}};return x},f=($)=>R($,r);var a="Store",E=($)=>{let B=new Set,W=new EventTarget,x=new Map,L=T(0),Q=v(()=>{L.get();let F={};for(let[X,z]of x)F[X]=z.get();return F}),G=T(0),Z=(F,X)=>W.dispatchEvent(new CustomEvent(F,{detail:X})),q=(F,X)=>{console.log("Reconciling data...",L.get());let z=new Set(Object.keys(F)),A=new Set(Object.keys(X)),P=new Set([...z,...A]),J={add:{},change:{},remove:{}};for(let M of P){let n=z.has(M),o=A.has(M),_=X[M];if(n&&!o)x.delete(M),J.remove[M]=C;else if(!n&&o){let U=l(_);x.set(M,U),J.add[M]=_}else if(n&&o){let U=x.get(M);if(f(U)&&p(_)||h(U)&&(j(_)||Array.isArray(_)))U.set(_);else{if(U&&G$(U,"set"))U.set(C);x.set(M,l(_))}J.change[M]=_}}let Y=Object.keys(J.add).length>0,y=Object.keys(J.change).length>0,b=Object.keys(J.remove).length>0,W$=Y||y||b;if(u(()=>{if(W$)L.update((M)=>++M);G.set(x.size)}),Y)Z("store-add",J.add);if(y)Z("store-change",J.change);if(b)Z("store-remove",J.remove);return W$};q({},$),setTimeout(()=>{let F=new CustomEvent("store-add",{detail:$});W.dispatchEvent(F)},0);let N=["get","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(F,X){let z=String(X);if(X===Symbol.toStringTag)return a;if(X===Symbol.iterator)return function*(){for(let[A,P]of x)yield[A,P]};if(X==="get")return()=>{return S(B),Q.get()};if(X==="set")return(A)=>{if(q(Q.get(),A)){if(D(B),C===A)B.clear()}};if(X==="update")return(A)=>{let P=Q.get(),J=A(P);if(q(P,J)){if(D(B),C===J)B.clear()}};if(X==="addEventListener")return W.addEventListener.bind(W);if(X==="removeEventListener")return W.removeEventListener.bind(W);if(X==="dispatchEvent")return W.dispatchEvent.bind(W);if(X==="size")return G;return x.get(z)},has(F,X){let z=String(X);return x.has(z)||N.includes(z)||X===Symbol.toStringTag||X===Symbol.iterator},ownKeys(){return Array.from(x.keys())},getOwnPropertyDescriptor(F,X){let z=x.get(String(X));return z?{enumerable:!0,configurable:!0,writable:!0,value:z}:void 0}})},h=($)=>R($,a);var C=Symbol(),J$=($)=>f($)||e($)||h($);function X$($){if(J$($))return $;if($$($))return v($);if(Array.isArray($))return E(k($));if(j($))return E($);return T($)}function l($){if(f($)||h($))return $;if(Array.isArray($))return E(k($));if(j($))return E($);return T($)}var B$="Computed",v=($)=>{let B=new Set,W=C,x,L,Q=!0,G=!1,Z=!1,q=(J)=>{if(!Object.is(J,W))W=J,G=!0;x=void 0,Q=!1},N=()=>{G=C!==W,W=C,x=void 0},F=(J)=>{let Y=K(J);G=!x||Y.name!==x.name||Y.message!==x.message,W=C,x=Y},X=(J)=>(Y)=>{if(Z=!1,L=void 0,J(Y),G)D(B)},z=g(()=>{if(Q=!0,L?.abort(),B.size)D(B);else z.cleanup()});z.off(()=>{L?.abort()});let A=()=>V(()=>{if(Z)throw new H("computed");if(G=!1,w($)){if(L)return W;L=new AbortController,L.signal.addEventListener("abort",()=>{Z=!1,L=void 0,A()},{once:!0})}let J;Z=!0;try{J=L?$(L.signal):$()}catch(Y){if(m(Y))N();else F(Y);Z=!1;return}if(J instanceof Promise)J.then(X(q),X(F));else if(J==null||C===J)N();else q(J);Z=!1},z);return{[Symbol.toStringTag]:B$,get:()=>{if(S(B),i(),Q)A();if(x)throw x;return W}}},e=($)=>R($,B$),$$=($)=>I($)&&$.length<2;var Z$=($,B)=>{let W=new WeakSet,x=(Q,G,Z="root")=>{if(p(Q)||p(G))return{changed:!Object.is(Q,G),value:G};if(Array.isArray(Q)!==Array.isArray(G))return{changed:!0,value:G};if(W.has(Q))throw new H(`${Z} (old value)`);if(W.has(G))throw new H(`${Z} (new value)`);W.add(Q),W.add(G);try{if(Array.isArray(Q)&&Array.isArray(G)){if(Q.length!==G.length)return{changed:!0,value:G};return{changed:L(k(Q),k(G),`${Z}[array]`).changed,value:G}}if(j(Q)&&j(G))return{changed:L(Q,G,`${Z}[object]`).changed,value:G};return{changed:!Object.is(Q,G),value:G}}finally{W.delete(Q),W.delete(G)}},L=(Q,G,Z)=>{let q={},N={},F={},X=Object.keys(Q),z=Object.keys(G),A=new Set([...X,...z]);for(let J of A){let Y=J in Q,y=J in G;if(!Y&&y){q[J]=G[J];continue}else if(Y&&!y){F[J]=C;continue}let b=x(Q[J],G[J],`${Z}.${J}`);if(b.changed)N[J]=b.value}return{changed:Object.keys(q).length>0||Object.keys(N).length>0||Object.keys(F).length>0,add:q,change:N,remove:F}};if(!j($)||!j(B))throw Error("diff() requires both arguments to be records (plain objects)");return L($,B,"root")};var F$=($)=>{let B=w($),W=!1,x,L=g(()=>V(()=>{if(W)throw new H("effect");W=!0,x?.abort(),x=void 0;let Q;try{if(B){x=new AbortController;let G=x;$(x.signal).then((Z)=>{if(I(Z)&&x===G)L.off(Z)}).catch((Z)=>{if(!m(Z))console.error("Async effect error:",Z)})}else if(Q=$(),I(Q))L.off(Q)}catch(G){if(!m(G))console.error("Effect callback error:",G)}W=!1},L));return L(),()=>{x?.abort(),L.cleanup()}};function z$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(K(W)))){let x=$.errors?[...$.errors,K(W)]:[K(W)];B.err(x)}else throw W}}function C$($){let B=[],W=!1,x={};for(let[L,Q]of Object.entries($))try{let G=Q.get();if(G===C)W=!0;else x[L]=G}catch(G){B.push(K(G))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:x}}export{g as watch,X$ as toSignal,K as toError,S as subscribe,E as store,T as state,C$ as resolve,V as observe,D as notify,z$ as match,h as isStore,f as isState,J$ as isSignal,I as isFunction,$$ as isComputedCallback,e as isComputed,w as isAsyncFunction,m as isAbortError,i as flush,Q$ as enqueue,F$ as effect,Z$ as diff,v as computed,u as batch,C as UNSET,a as TYPE_STORE,r as TYPE_STATE,B$ as TYPE_COMPUTED,H as CircularDependencyError};
