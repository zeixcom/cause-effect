var T,w=new Set,d=0,j=($)=>{let J=new Set,z=$;return z.onCleanup=(G)=>{J.add(G)},z.stop=()=>{for(let G of J)G();J.clear()},z},D=($)=>{if(T&&!$.has(T)){let J=T;J.onCleanup(()=>$.delete(J)),$.add(J)}},q=($)=>{for(let J of $)if(d)w.add(J);else J()},m=()=>{while(w.size){let $=Array.from(w);w.clear();for(let J of $)J()}},e=($)=>{d++;try{$()}finally{m(),d--}},P=($,J)=>{let z=T;T=$||void 0;try{J()}finally{T=z}},Y=($,J)=>{for(let z of $)if(d)w.add(()=>z(J));else z(J)};var H=Symbol(),n=($)=>typeof $==="string",u=($)=>typeof $==="number",I=($)=>typeof $==="symbol",F=($)=>typeof $==="function",W=($)=>F($)&&$.constructor.name==="AsyncFunction",Y$=($)=>F($)&&$.constructor.name!=="AsyncFunction",$$=($)=>$!=null&&typeof $==="object",M=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,L=($)=>M($,"Object"),o=($)=>L($)||Array.isArray($),J$=($,J=(z)=>z!=null)=>Array.isArray($)&&$.every(J);var C=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($)),O=($)=>n($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);class b{#J;#z=new Map;#G=new Map;#$={add:new Set,change:new Set,remove:new Set};#X=!1;constructor($,J){this.#J=J,this.change({add:$,change:{},remove:{},changed:!0},!0)}#Z($){let J=j(()=>{P(J,()=>{if(this.#z.get($)?.get(),!this.#X)Y(this.#$.change,[$])})});this.#G.set($,J),J()}#Q($){let J=this.#G.get($);if(J)J.stop(),this.#G.delete($)}keys(){return this.#z.keys()}values(){return this.#z.values()}entries(){return this.#z.entries()}has($){return this.#z.has($)}get($){return this.#z.get($)}add($,J){if(!this.#J($,J))return!1;let z=I$(J);if(this.#z.set($,z),this.#$.change.size)this.#Z($);if(!this.#X)Y(this.#$.add,[$]);return!0}remove($){if(!this.#z.delete($))return!1;if(this.#Q($),!this.#X)Y(this.#$.remove,[$]);return!0}change($,J){if(this.#X=!0,Object.keys($.add).length){for(let G in $.add)this.add(G,$.add[G]);let z=()=>Y(this.#$.add,Object.keys($.add));if(J)setTimeout(z,0);else z()}if(Object.keys($.change).length)e(()=>{for(let z in $.change){let G=$.change[z];if(!this.#J(z,G))continue;let X=this.#z.get(z);if(M$(`list item "${z}"`,G,X))X.set(G)}}),Y(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let z in $.remove)this.remove(z);Y(this.#$.remove,Object.keys($.remove))}return this.#X=!1,$.changed}clear(){let $=Array.from(this.#z.keys());return this.#z.clear(),this.#G.clear(),Y(this.#$.remove,$),!0}on($,J){if(this.#$[$].add(J),$==="change"&&!this.#G.size){this.#X=!0;for(let z of this.#z.keys())this.#Z(z);this.#X=!1}return()=>{if(this.#$[$].delete(J),$==="change"&&!this.#$.change.size){if(this.#G.size){for(let z of this.#G.values())z.stop();this.#G.clear()}}}}}var z$="List";class G${#J;#z=new Set;#G={sort:new Set};#$=[];keyCounter=0;keyConfig;constructor($,J){K("list",$,Array.isArray),this.#J=new b(this.#Z($),(z,G)=>{return K(`list for key "${z}"`,G),!0}),this.keyConfig=J}#X($){let J=this.keyCounter++;return n(this.keyConfig)?`${this.keyConfig}${J}`:F(this.keyConfig)?this.keyConfig($):String(J)}#Z($){let J={};for(let z=0;z<$.length;z++){let G=$[z];if(G===void 0)continue;let X=this.#$[z];if(!X)X=this.#X(G),this.#$[z]=X;J[X]=G}return J}get#Q(){return this.#$.map(($)=>this.#J.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return z$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let J=this.#J.get($);if(J)yield J}}get length(){return D(this.#z),this.#$.length}get(){return D(this.#z),this.#Q}set($){if(H===$){this.#J.clear(),q(this.#z),this.#z.clear();return}let J=this.#Q,z=g(this.#Z(J),this.#Z($)),G=Object.keys(z.remove);if(this.#J.change(z)){for(let Z of G){let Q=this.#$.indexOf(Z);if(Q!==-1)this.#$.splice(Q,1)}this.#$=this.#$.filter(()=>!0),q(this.#z)}}update($){this.set($(this.get()))}at($){return this.#J.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#J.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let J=this.#X($);if(this.#J.has(J))throw new E("store",J,$);if(!this.#$.includes(J))this.#$.push(J);if(this.#J.add(J,$))q(this.#z);return J}remove($){let J=u($)?this.#$[$]:$;if(this.#J.remove(J)){let G=u($)?$:this.#$.indexOf(J);if(G>=0)this.#$.splice(G,1);this.#$=this.#$.filter(()=>!0),q(this.#z)}}sort($){let z=this.#$.map((G)=>[G,this.#J.get(G)?.get()]).sort(F($)?(G,X)=>$(G[1],X[1]):(G,X)=>String(G[1]).localeCompare(String(X[1]))).map(([G])=>G);if(!x(this.#$,z))this.#$=z,q(this.#z),Y(this.#G.sort,this.#$)}splice($,J,...z){let G=this.#$.length,X=$<0?Math.max(0,G+$):Math.min($,G),Z=Math.max(0,Math.min(J??Math.max(0,G-Math.max(0,X)),G-X)),Q={},B={};for(let N=0;N<Z;N++){let A=X+N,R=this.#$[A];if(R){let f=this.#J.get(R);if(f)B[R]=f.get()}}let S=this.#$.slice(0,X);for(let N of z){let A=this.#X(N);S.push(A),Q[A]=N}S.push(...this.#$.slice(X+Z));let v=!!(Object.keys(Q).length||Object.keys(B).length);if(v)this.#J.change({add:Q,change:{},remove:B,changed:v}),this.#$=S.filter(()=>!0),q(this.#z);return Object.values(B)}on($,J){if($==="sort")return this.#G.sort.add(J),()=>this.#G.sort.delete(J);return this.#J.on($,J)}}var c=($,J)=>{let z=new G$($,J),G=(X)=>{let Z=Number(X);return Number.isInteger(Z)&&Z>=0?z.at(Z):z.byKey(X)};return new Proxy(z,{get(X,Z){if(Z in X){let Q=Reflect.get(X,Z);return F(Q)?Q.bind(X):Q}return!I(Z)?G(Z):void 0},has(X,Z){if(Z in X)return!0;return!I(Z)?G(Z)!==void 0:!1},ownKeys(X){return Object.getOwnPropertyNames(X.keys())},getOwnPropertyDescriptor(X,Z){if(I(Z))return;if(Z==="length")return{enumerable:!1,configurable:!1,writable:!1,value:X.length};let Q=Number(Z);if(Number.isInteger(Q)&&Q>=0&&Q<X.length){let B=X.at(Q);return B?{enumerable:!0,configurable:!0,writable:!0,value:B}:void 0}return}})},X$=($)=>M($,z$);var Z$="State";class V{#J=new Set;#z;constructor($){K("state",$),this.#z=$}get[Symbol.toStringTag](){return Z$}get(){return D(this.#J),this.#z}set($){if(K("state",$),x(this.#z,$))return;if(this.#z=$,q(this.#J),H===this.#z)this.#J.clear()}update($){k("state update",$),this.set($(this.#z))}}var U$=($)=>new V($),s=($)=>M($,Z$);var Q$="Store";class H${#J;#z=new Set;constructor($){K("store",$,L),this.#J=new b($,(J,z)=>{return K(`store for key "${J}"`,z),!0})}get#G(){let $={};for(let[J,z]of this.#J.entries())$[J]=z.get();return $}get[Symbol.toStringTag](){return Q$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,J]of this.#J.entries())yield[$,J]}get(){return D(this.#z),this.#G}set($){if(H===$){this.#J.clear(),q(this.#z),this.#z.clear();return}let J=this.#G;if(this.#J.change(g(J,$)))q(this.#z)}keys(){return this.#J.keys()}byKey($){return this.#J.get($)}update($){this.set($(this.get()))}add($,J){if(this.#J.has($))throw new E("store",$,J);if(this.#J.add($,J))q(this.#z);return $}remove($){if(this.#J.remove($))q(this.#z)}on($,J){return this.#J.on($,J)}}var i=($)=>{let J=new H$($);return new Proxy(J,{get(z,G){if(G in z){let X=Reflect.get(z,G);return F(X)?X.bind(z):X}if(!I(G))return z.byKey(G)},has(z,G){if(G in z)return!0;return z.byKey(String(G))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,G){if(G in z)return Reflect.getOwnPropertyDescriptor(z,G);if(I(G))return;let X=z.byKey(String(G));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},l=($)=>M($,Q$);var x$=($)=>s($)||B$($)||l($),q$=($)=>s($)||l($)||X$($);function _$($){if(r($))return new y($);if(t($))return new p($);if(J$($))return c($);if(L($))return i($);return new V($)}function I$($){if(J$($))return c($);if(L($))return i($);return new V($)}class _ extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class E extends Error{constructor($,J,z){super(`Could not add ${$} key "${J}"${z?` with value ${O(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class h extends TypeError{constructor($,J){super(`Invalid ${$} callback ${O(J)}`);this.name="InvalidCallbackError"}}class A$ extends TypeError{constructor($,J){super(`Invalid signal value ${O(J)} in ${$}`);this.name="InvalidSignalValueError"}}class F$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class K$ extends Error{constructor($,J){super(`Could not set ${$} to ${O(J)} because signal is read-only`);this.name="ReadonlySignalError"}}var k=($,J,z=F)=>{if(!z(J))throw new h($,J)},K=($,J,z=()=>!(I(J)&&J!==H)||F(J))=>{if(J==null)throw new F$($);if(!z(J))throw new A$($,J)},M$=($,J,z)=>{if(!q$(z))throw new K$($,J);return!0};var x=($,J,z)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!$$($)||!$$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new _("isEqual");z.add($),z.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let G=0;G<$.length;G++)if(!x($[G],J[G],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(L($)&&L(J)){let G=Object.keys($),X=Object.keys(J);if(G.length!==X.length)return!1;for(let Z of G){if(!(Z in J))return!1;if(!x($[Z],J[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}},g=($,J)=>{let z=o($),G=o(J);if(!z||!G){let A=!Object.is($,J);return{changed:A,add:A&&G?J:{},change:{},remove:A&&z?$:{}}}let X=new WeakSet,Z={},Q={},B={},S=Object.keys($),v=Object.keys(J),N=new Set([...S,...v]);for(let A of N){let R=A in $,f=A in J;if(!R&&f){Z[A]=J[A];continue}else if(R&&!f){B[A]=H;continue}let L$=$[A],D$=J[A];if(!x(L$,D$,X))Q[A]=D$}return{add:Z,change:Q,remove:B,changed:!!(Object.keys(Z).length||Object.keys(Q).length||Object.keys(B).length)}};var a="Computed";class y{#J=new Set;#z;#G;#$;#X=!0;#Z=!1;#Q;constructor($,J=H){k("memo",$,r),K("memo",J),this.#z=$,this.#G=J,this.#Q=j(()=>{if(this.#X=!0,this.#J.size)q(this.#J);else this.#Q.stop()})}get[Symbol.toStringTag](){return a}get(){if(D(this.#J),m(),this.#X)P(this.#Q,()=>{if(this.#Z)throw new _("memo");let $;this.#Z=!0;try{$=this.#z(this.#G)}catch(J){this.#G=H,this.#$=U(J),this.#Z=!1;return}if($==null||H===$)this.#G=H,this.#$=void 0;else this.#G=$,this.#$=void 0,this.#X=!1;this.#Z=!1});if(this.#$)throw this.#$;return this.#G}}class p{#J=new Set;#z;#G;#$;#X=!0;#Z=!1;#Q=!1;#q;#H;constructor($,J=H){k("task",$,t),K("task",J),this.#z=$,this.#G=J,this.#q=j(()=>{if(this.#X=!0,this.#H?.abort(),this.#J.size)q(this.#J);else this.#q.stop()}),this.#q.onCleanup(()=>{this.#H?.abort()})}get[Symbol.toStringTag](){return a}get(){D(this.#J),m();let $=(Z)=>{if(!x(Z,this.#G))this.#G=Z,this.#Q=!0;this.#$=void 0,this.#X=!1},J=()=>{this.#Q=H!==this.#G,this.#G=H,this.#$=void 0},z=(Z)=>{let Q=U(Z);this.#Q=!this.#$||Q.name!==this.#$.name||Q.message!==this.#$.message,this.#G=H,this.#$=Q},G=(Z)=>(Q)=>{if(this.#Z=!1,this.#H=void 0,Z(Q),this.#Q)q(this.#J)},X=()=>P(this.#q,()=>{if(this.#Z)throw new _("task");if(this.#Q=!1,this.#H)return this.#G;this.#H=new AbortController,this.#H.signal.addEventListener("abort",()=>{this.#Z=!1,this.#H=void 0,X()},{once:!0});let Z;this.#Z=!0;try{Z=this.#z(this.#G,this.#H.signal)}catch(Q){if(C(Q))J();else z(Q);this.#Z=!1;return}if(Z instanceof Promise)Z.then(G($),G(z));else if(Z==null||H===Z)J();else $(Z);this.#Z=!1});if(this.#X)X();if(this.#$)throw this.#$;return this.#G}}var N$=($,J=H)=>W($)?new p($,J):new y($,J),B$=($)=>M($,a),r=($)=>Y$($)&&$.length<2,t=($)=>W($)&&$.length<3;var j$=($)=>{if(!F($)||$.length>1)throw new h("effect",$);let J=W($),z=!1,G,X=j(()=>P(X,()=>{if(z)throw new _("effect");z=!0,G?.abort(),G=void 0;let Z;try{if(J){G=new AbortController;let Q=G;$(G.signal).then((B)=>{if(F(B)&&G===Q)X.onCleanup(B)}).catch((B)=>{if(!C(B))console.error("Async effect error:",B)})}else if(Z=$(),F(Z))X.onCleanup(Z)}catch(Q){if(!C(Q))console.error("Effect callback error:",Q)}z=!1}));return X(),()=>{G?.abort(),X.stop()}};function P$($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(z){if(J.err&&(!$.errors||!$.errors.includes(U(z))))J.err($.errors?[...$.errors,U(z)]:[U(z)]);else throw z}}function R$($){let J=[],z=!1,G={};for(let[X,Z]of Object.entries($))try{let Q=Z.get();if(Q===H)z=!0;else G[X]=Q}catch(Q){J.push(U(Q))}if(z)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:G}}export{O as valueString,P as trackSignalReads,U as toError,D as subscribeActiveWatcher,R$ as resolve,q as notifyWatchers,P$ as match,t as isTaskCallback,I as isSymbol,n as isString,l as isStore,s as isState,x$ as isSignal,o as isRecordOrArray,L as isRecord,M as isObjectOfType,u as isNumber,q$ as isMutableSignal,r as isMemoCallback,X$ as isList,F as isFunction,x as isEqual,B$ as isComputed,W as isAsyncFunction,C as isAbortError,m as flushPendingReactions,Y as emitNotification,g as diff,j as createWatcher,i as createStore,U$ as createState,_$ as createSignal,c as createList,j$ as createEffect,N$ as createComputed,e as batchSignalWrites,H as UNSET,p as Task,Q$ as TYPE_STORE,Z$ as TYPE_STATE,z$ as TYPE_LIST,a as TYPE_COMPUTED,V as State,K$ as ReadonlySignalError,F$ as NullishSignalValueError,y as Memo,A$ as InvalidSignalValueError,h as InvalidCallbackError,E as DuplicateKeyError,_ as CircularDependencyError,H$ as BaseStore,G$ as BaseList};
