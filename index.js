function f($){return typeof $==="function"}function s($){return f($)&&$.constructor.name==="AsyncFunction"}function G$($){return f($)&&$.constructor.name!=="AsyncFunction"}function V($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function b($){return V($,"Object")}function V$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function D$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class z$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class A$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class l extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class X$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${D$(J)} is invalid`);this.name="InvalidSignalValueError"}}class Y$ extends TypeError{constructor($,J){super(`[${$}] Callback ${D$(J)} is invalid`);this.name="InvalidCallbackError"}}class P$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class e extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function R($,J,z){if(J==null)throw new A$($);if(z&&!z(J))throw new X$($,J)}function Z$($,J){if(J==null)throw new l($)}function T($,J,z=f){if(!z(J))throw new Y$($,J)}var c="State",u="Memo",d="Task",t="Sensor",E="List",g="Collection",r="Store",w=0,F$=1,P=2,B$=4,x=null,y=null,m$=[],A=0,L$=!1,i=($,J)=>$===J,S$=($,J)=>!1;function h$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function I($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,U=J.flags&B$;if(U){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let H=$.sinksTail;if(H?.sink===J&&(!U||h$(H,J)))return;let q={source:$,sink:J,nextSource:X,prevSink:H,nextSink:null};if(J.sourcesTail=$.sinksTail=q,z)z.nextSource=q;else J.sources=q;if(H)H.nextSink=q;else $.sinks=q}function p$($){let{source:J,nextSource:z,nextSink:X,prevSink:U}=$;if(X)X.prevSink=U;else J.sinksTail=U;if(U)U.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function U$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=p$(z);if(J)J.nextSource=null;else $.sources=null}function Y($,J=P){let z=$.flags;if("sinks"in $){if((z&(P|F$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)Y(X.sink,F$)}else{if(z&P)return;$.flags=P,m$.push($)}}function M$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)Y(z.sink);if(A===0)_()}function $$($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function R$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function y$($){let J=x;x=$,$.sourcesTail=null,$.flags=B$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{x=J,U$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&F$)X.sink.flags|=P}$.flags=w}function g$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=x;x=$,$.sourcesTail=null,$.flags=B$;let X;try{X=$.fn($.value,J.signal)}catch(U){$.controller=void 0,$.error=U instanceof Error?U:Error(String(U));return}finally{x=z,U$($)}X.then((U)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(U,$.value)){$.value=U,$.error=void 0;for(let H=$.sinks;H;H=H.nextSink)Y(H.sink);if(A===0)_()}},(U)=>{if(J.signal.aborted)return;$.controller=void 0;let H=U instanceof Error?U:Error(String(U));if(!$.error||H.name!==$.error.name||H.message!==$.error.message){$.error=H;for(let q=$.sinks;q;q=q.nextSink)Y(q.sink);if(A===0)_()}}),$.flags=w}function f$($){R$($);let J=x,z=y;x=y=$,$.sourcesTail=null,$.flags=B$;try{let X=$.fn();if(typeof X==="function")$$($,X)}finally{x=J,y=z,U$($)}$.flags=w}function S($){if($.flags&F$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)S(J.source);if($.flags&P)break}if($.flags&B$)throw new z$("controller"in $?d:("value"in $)?u:"Effect");if($.flags&P)if("controller"in $)g$($);else if("value"in $)y$($);else f$($);else $.flags=w}function _(){if(L$)return;L$=!0;try{for(let $=0;$<m$.length;$++){let J=m$[$];if(J.flags&P)S(J)}m$.length=0}finally{L$=!1}}function J$($){A++;try{$()}finally{if(A--,A===0)_()}}function o($){let J=x;x=null;try{return $()}finally{x=J}}function k$($){let J=y,z={cleanup:null};y=z;try{let X=$();if(typeof X==="function")$$(z,X);let U=()=>R$(z);if(J)$$(J,U);return U}finally{y=J}}function p($,J){R(c,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??i,guard:J?.guard};return{[Symbol.toStringTag]:c,get(){if(x)I(z,x);return z.value},set(X){R(c,X,z.guard),M$(z,X)},update(X){T(c,X);let U=X(z.value);R(c,U,z.guard),M$(z,U)}}}function q$($){return V($,c)}function j$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function n($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new z$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let U=$,H=J;if(U.length!==H.length)return!1;for(let q=0;q<U.length;q++)if(!n(U[q],H[q],z))return!1;return!0}if(b($)&&b(J)){let U=Object.keys($),H=Object.keys(J);if(U.length!==H.length)return!1;for(let q of U){if(!(q in J))return!1;if(!n($[q],J[q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function v$($,J,z,X,U){let H=new WeakSet,q={},F={},W={},Z=[],B=!1,j=new Map;for(let N=0;N<$.length;N++){let Q=z[N];if(Q&&$[N])j.set(Q,$[N])}let K=new Set;for(let N=0;N<J.length;N++){let Q=J[N];if(Q===void 0)continue;let G=U?X(Q):z[N]??X(Q);if(K.has(G))throw new e(E,G,Q);if(Z.push(G),K.add(G),!j.has(G))q[G]=Q,B=!0;else{let m=j.get(G);if(!n(m,Q,H))F[G]=Q,B=!0}}for(let[N]of j)if(!K.has(N))W[N]=null,B=!0;if(!B&&!j$(z,Z))B=!0;return{add:q,change:F,remove:W,newKeys:Z,changed:B}}function Q$($,J){R(E,$,Array.isArray);let z=new Map,X=[],U=0,H=J?.keyConfig,q=f(H),F=typeof H==="string"?()=>`${H}${U++}`:q?(Q)=>H(Q)||String(U++):()=>String(U++),W=()=>X.map((Q)=>z.get(Q)?.get()).filter((Q)=>Q!==void 0),Z={fn:W,value:$,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},B=(Q)=>{let G={};for(let m=0;m<Q.length;m++){let M=Q[m];if(M===void 0)continue;let D=X[m];if(!D)D=F(M),X[m]=D;G[D]=M}return G},j=(Q)=>{let G=!1;for(let m in Q.add){let M=Q.add[m];R(`${E} item for key "${m}"`,M),z.set(m,p(M)),G=!0}if(Object.keys(Q.change).length)J$(()=>{for(let m in Q.change){let M=Q.change[m];R(`${E} item for key "${m}"`,M);let D=z.get(m);if(D)D.set(M)}});for(let m in Q.remove){z.delete(m);let M=X.indexOf(m);if(M!==-1)X.splice(M,1);G=!0}if(G)Z.sources=null,Z.sourcesTail=null;return Q.changed},K=B($);for(let Q in K){let G=K[Q];R(`${E} item for key "${Q}"`,G),z.set(Q,p(G))}Z.value=$,Z.flags=0;let N={[Symbol.toStringTag]:E,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Q of X){let G=z.get(Q);if(G)yield G}},get length(){if(x){if(!Z.sinks&&J?.watched)Z.stop=J.watched();I(Z,x)}return X.length},get(){if(x){if(!Z.sinks&&J?.watched)Z.stop=J.watched();I(Z,x)}if(Z.sources){if(Z.flags)Z.value=o(W),Z.flags=w}else if(S(Z),Z.error)throw Z.error;return Z.value},set(Q){let G=Z.flags&P?W():Z.value,m=v$(G,Q,X,F,q);if(m.changed){if(X=m.newKeys,j(m),Y(Z),Z.flags|=P,A===0)_()}},update(Q){N.set(Q(N.get()))},at(Q){return z.get(X[Q])},keys(){if(x){if(!Z.sinks&&J?.watched)Z.stop=J.watched();I(Z,x)}return X.values()},byKey(Q){return z.get(Q)},keyAt(Q){return X[Q]},indexOfKey(Q){return X.indexOf(Q)},add(Q){let G=F(Q);if(z.has(G))throw new e(E,G,Q);if(!X.includes(G))X.push(G);if(R(`${E} item for key "${G}"`,Q),z.set(G,p(Q)),Z.sources=null,Z.sourcesTail=null,Y(Z),Z.flags|=P,A===0)_();return G},remove(Q){let G=typeof Q==="number"?X[Q]:Q;if(z.delete(G)){let M=typeof Q==="number"?Q:X.indexOf(G);if(M>=0)X.splice(M,1);if(Z.sources=null,Z.sourcesTail=null,Y(Z),Z.flags|=P,A===0)_()}},sort(Q){let m=X.map((M)=>[M,z.get(M)?.get()]).sort(f(Q)?(M,D)=>Q(M[1],D[1]):(M,D)=>String(M[1]).localeCompare(String(D[1]))).map(([M])=>M);if(!j$(X,m)){if(X=m,Y(Z),Z.flags|=P,A===0)_()}},splice(Q,G,...m){let M=X.length,D=Q<0?Math.max(0,M+Q):Math.min(Q,M),h=Math.max(0,Math.min(G??Math.max(0,M-Math.max(0,D)),M-D)),a={},k={};for(let L=0;L<h;L++){let v=D+L,C$=X[v];if(C$){let b$=z.get(C$);if(b$)k[C$]=b$.get()}}let O=X.slice(0,D);for(let L of m){let v=F(L);if(z.has(v)&&!(v in k))throw new e(E,v,L);O.push(v),a[v]=L}O.push(...X.slice(D+h));let C=!!(Object.keys(a).length||Object.keys(k).length);if(C){if(j({add:a,change:{},remove:k,changed:C}),X=O,Y(Z),Z.flags|=P,A===0)_()}return Object.values(k)},deriveCollection(Q){return K$(N,Q)}};return N}function N$($){return V($,E)}function H$($,J){if(T(u,$,G$),J?.value!==void 0)R(u,J.value,J?.guard);let z={fn:$,value:J?.value,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??i,error:void 0};return{[Symbol.toStringTag]:u,get(){if(x)I(z,x);if(S(z),z.error)throw z.error;return Z$(u,z.value),z.value}}}function O$($){return V($,u)}function W$($,J){if(T(d,$,s),J?.value!==void 0)R(d,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:P,equals:J?.equals??i,controller:void 0,error:void 0};return{[Symbol.toStringTag]:d,get(){if(x)I(z,x);if(S(z),z.error)throw z.error;return Z$(d,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function _$($){return V($,d)}function K$($,J){if(T(g,J),!u$($))throw TypeError(`[${g}] Invalid collection source: expected a List or Collection`);let z=s(J),X=new Map,U=(B)=>{let j=z?W$(async(K,N)=>{let Q=$.byKey(B)?.get();if(Q==null)return K;return J(Q,N)}):H$(()=>{let K=$.byKey(B)?.get();if(K==null)return;return J(K)});X.set(B,j)};function H(){let B=Array.from($.keys()),j=q.value;if(!j$(j,B)){let K=new Set(j),N=new Set(B);for(let Q of j)if(!N.has(Q))X.delete(Q);for(let Q of B)if(!K.has(Q))U(Q)}return B}let q={fn:H,value:[],flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:j$,error:void 0};function F(){if(q.sources){if(q.flags)q.value=o(H),q.flags=w}else if(S(q),q.error)throw q.error;return q.value}let W=Array.from($.keys());for(let B of W)U(B);q.value=W;let Z={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of q.value){let j=X.get(B);if(j)yield j}},get length(){if(x)I(q,x);return F().length},keys(){if(x)I(q,x);return F().values()},get(){if(x)I(q,x);let B=F(),j=[];for(let K of B)try{let N=X.get(K)?.get();if(N!=null)j.push(N)}catch(N){if(!(N instanceof l))throw N}return j},at(B){return X.get(q.value[B])},byKey(B){return X.get(B)},keyAt(B){return q.value[B]},indexOfKey(B){return q.value.indexOf(B)},deriveCollection(B){return K$(Z,B)}};return Z}function c$($,J){let z=J?.value??[];if(z.length)R(g,z,Array.isArray);T(g,$);let X=new Map,U=[],H=new Map,q=0,F=J?.keyConfig,W=f(F),Z=typeof F==="string"?()=>`${F}${q++}`:W?(M)=>F(M)||String(q++):()=>String(q++),B=(M)=>H.get(M)??(W?Z(M):void 0),j=J?.createItem??((M,D)=>p(D));function K(){let M=[];for(let D of U)try{let h=X.get(D)?.get();if(h!=null)M.push(h)}catch(h){if(!(h instanceof l))throw h}return M}let N={fn:K,value:z,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:()=>!1,error:void 0};function Q(M){let{add:D,change:h,remove:a}=M;if(!D?.length&&!h?.length&&!a?.length)return;let k=!1;J$(()=>{if(D)for(let O of D){let C=Z(O);if(X.set(C,j(C,O)),H.set(O,C),!U.includes(C))U.push(C);k=!0}if(h)for(let O of h){let C=B(O);if(!C)continue;let L=X.get(C);if(L&&q$(L)){let v=L.get();H.delete(v),L.set(O),H.set(O,C)}}if(a)for(let O of a){let C=B(O);if(!C)continue;H.delete(O),X.delete(C);let L=U.indexOf(C);if(L!==-1)U.splice(L,1);k=!0}if(k)N.sources=null,N.sourcesTail=null;N.flags=w,Y(N),N.flags|=P})}for(let M of z){let D=Z(M);X.set(D,j(D,M)),H.set(M,D),U.push(D)}N.value=z,N.flags=P;function G(){if(!N.sinks)N.stop=$(Q)}let m={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let M of U){let D=X.get(M);if(D)yield D}},get length(){if(x)G(),I(N,x);return U.length},keys(){if(x)G(),I(N,x);return U.values()},get(){if(x)G(),I(N,x);if(N.sources){if(N.flags)N.value=o(K),N.flags=w}else if(S(N),N.error)throw N.error;return N.value},at(M){return X.get(U[M])},byKey(M){return X.get(M)},keyAt(M){return U[M]},indexOfKey(M){return U.indexOf(M)},deriveCollection(M){return K$(m,M)}};return m}function T$($){return V($,g)}function u$($){return N$($)||T$($)}function d$($){T("Effect",$);let J={fn:$,flags:P,sources:null,sourcesTail:null,cleanup:null},z=()=>{R$(J),J.fn=void 0,J.flags=w,J.sourcesTail=null,U$(J)};if(y)$$(y,z);return f$(J),z}function t$($,J){if(!y)throw new P$("match");let{ok:z,err:X=console.error,nil:U}=J,H,q=!1,F=Array($.length);for(let Z=0;Z<$.length;Z++)try{F[Z]=$[Z].get()}catch(B){if(B instanceof l){q=!0;continue}if(!H)H=[];H.push(B instanceof Error?B:Error(String(B)))}let W;try{if(q)W=U?.();else if(H)W=X(H);else W=z(F)}catch(Z){X([Z instanceof Error?Z:Error(String(Z))])}if(typeof W==="function")return W;if(W instanceof Promise){let Z=y,B=new AbortController;$$(Z,()=>B.abort()),W.then((j)=>{if(!B.signal.aborted&&typeof j==="function")$$(Z,j)}).catch((j)=>{X([j instanceof Error?j:Error(String(j))])})}}function r$($,J){if(T(t,$,G$),J?.value!==void 0)R(t,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??i,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:t,get(){if(x){if(!z.sinks)z.stop=$((X)=>{R(t,X,z.guard),M$(z,X)});I(z,x)}return Z$(t,z.value),z.value}}}function s$($){return V($,t)}function l$($,J){let z=b($)||Array.isArray($),X=b(J)||Array.isArray(J);if(!z||!X){let j=!Object.is($,J);return{changed:j,add:j&&X?J:{},change:{},remove:j&&z?$:{}}}let U=new WeakSet,H={},q={},F={},W=!1,Z=Object.keys($),B=Object.keys(J);for(let j of B)if(j in $){if(!n($[j],J[j],U))q[j]=J[j],W=!0}else H[j]=J[j],W=!0;for(let j of Z)if(!(j in J))F[j]=void 0,W=!0;return{add:H,change:q,remove:F,changed:W}}function x$($,J){R(r,$,b);let z=new Map,X=(W,Z)=>{if(R(`${r} for key "${W}"`,Z),Array.isArray(Z))z.set(W,Q$(Z));else if(b(Z))z.set(W,x$(Z));else z.set(W,p(Z))},U=()=>{let W={};return z.forEach((Z,B)=>{W[B]=Z.get()}),W},H={fn:U,value:$,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:n,error:void 0},q=(W)=>{let Z=!1;for(let B in W.add)X(B,W.add[B]),Z=!0;if(Object.keys(W.change).length)J$(()=>{for(let B in W.change){let j=W.change[B];R(`${r} for key "${B}"`,j);let K=z.get(B);if(K)if(b(j)!==I$(K))X(B,j),Z=!0;else K.set(j)}});for(let B in W.remove)z.delete(B),Z=!0;if(Z)H.sources=null,H.sourcesTail=null;return W.changed};for(let W of Object.keys($))X(W,$[W]);let F={[Symbol.toStringTag]:r,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let Z=z.get(W);if(Z)yield[W,Z]}},keys(){if(x){if(!H.sinks&&J?.watched)H.stop=J.watched();I(H,x)}return z.keys()},byKey(W){return z.get(W)},get(){if(x){if(!H.sinks&&J?.watched)H.stop=J.watched();I(H,x)}if(H.sources){if(H.flags)H.value=o(U),H.flags=w}else if(S(H),H.error)throw H.error;return H.value},set(W){let Z=H.flags&P?U():H.value,B=l$(Z,W);if(q(B)){if(Y(H),H.flags|=P,A===0)_()}},update(W){F.set(W(F.get()))},add(W,Z){if(z.has(W))throw new e(r,W,Z);if(X(W,Z),H.sources=null,H.sourcesTail=null,Y(H),H.flags|=P,A===0)_();return W},remove(W){if(z.delete(W)){if(H.sources=null,H.sourcesTail=null,Y(H),H.flags|=P,A===0)_()}}};return new Proxy(F,{get(W,Z){if(Z in W){let B=Reflect.get(W,Z);return f(B)?B.bind(W):B}if(typeof Z!=="symbol")return W.byKey(Z)},has(W,Z){if(Z in W)return!0;return W.byKey(String(Z))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Z){if(Z in W)return Reflect.getOwnPropertyDescriptor(W,Z);if(typeof Z==="symbol")return;let B=W.byKey(String(Z));return B?{enumerable:!0,configurable:!0,writable:!0,value:B}:void 0}})}function I$($){return V($,r)}function i$($,J){return s($)?W$($,J):H$($,J)}function o$($){if(w$($))return $;if($==null)throw new X$("createSignal",$);if(s($))return W$($);if(f($))return H$($);if(V$($))return Q$($);if(b($))return x$($);return p($)}function n$($){if(E$($))return $;if($==null||f($)||w$($))throw new X$("createMutableSignal",$);if(V$($))return Q$($);if(b($))return x$($);return p($)}function a$($){return O$($)||_$($)}function w$($){let J=[c,u,d,t,E,g,r],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function E$($){return q$($)||I$($)||N$($)}export{D$ as valueString,o as untrack,t$ as match,_$ as isTask,I$ as isStore,q$ as isState,w$ as isSignal,s$ as isSensor,b as isRecord,V as isObjectOfType,E$ as isMutableSignal,O$ as isMemo,N$ as isList,f as isFunction,n as isEqual,a$ as isComputed,T$ as isCollection,s as isAsyncFunction,W$ as createTask,x$ as createStore,p as createState,o$ as createSignal,r$ as createSensor,k$ as createScope,n$ as createMutableSignal,H$ as createMemo,Q$ as createList,d$ as createEffect,i$ as createComputed,c$ as createCollection,J$ as batch,l as UnsetSignalValueError,S$ as SKIP_EQUALITY,P$ as RequiredOwnerError,A$ as NullishSignalValueError,X$ as InvalidSignalValueError,Y$ as InvalidCallbackError,z$ as CircularDependencyError};
