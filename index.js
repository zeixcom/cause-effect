var q,y=new Set,h=0,d=new Map,k,a=()=>{k=void 0;let $=Array.from(d.values());d.clear();for(let B of $)B()},W$=()=>{if(k)cancelAnimationFrame(k);k=requestAnimationFrame(a)};queueMicrotask(a);var E=($)=>{let B=new Set,W=$;return W.off=(F)=>{B.add(F)},W.cleanup=()=>{for(let F of B)F();B.clear()},W},U=($)=>{if(q&&!$.has(q)){let B=q;$.add(B),q.off(()=>{$.delete(B)})}},C=($)=>{for(let B of $)if(h)y.add(B);else B()},w=()=>{while(y.size){let $=Array.from(y);y.clear();for(let B of $)B()}},v=($)=>{h++;try{$()}finally{w(),h--}},m=($,B)=>{let W=q;q=B;try{$()}finally{q=W}},F$=($,B)=>new Promise((W,F)=>{d.set(B||Symbol(),()=>{try{W($())}catch(Q){F(Q)}}),W$()});var j=($)=>typeof $==="function",f=($)=>j($)&&$.constructor.name==="AsyncFunction",O=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,P=($)=>O($,"Object"),b=($)=>{let B={};for(let W=0;W<$.length;W++)if(W in $)B[String(W)]=$[W];return B},e=($)=>{if(!$.length)return null;let B=$.map((W)=>parseInt(W,10));return B.every((W)=>Number.isFinite(W)&&W>=0)?B.sort((W,F)=>W-F):null},$$=($,B)=>(B in $)&&j($[B]),R=($)=>$ instanceof DOMException&&$.name==="AbortError",K=($)=>$ instanceof Error?$:Error(String($));class D extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var c="State",V=($)=>{let B=new Set,W=$,F={[Symbol.toStringTag]:c,get:()=>{return U(B),W},set:(Q)=>{if(I(W,Q))return;if(W=Q,C(B),A===W)B.clear()},update:(Q)=>{F.set(Q(W))}};return F},g=($)=>O($,c);var o=($)=>{let B=f($),W=!1,F,Q=E(()=>m(()=>{if(W)throw new D("effect");W=!0,F?.abort(),F=void 0;let H;try{if(B){F=new AbortController;let M=F;$(F.signal).then((z)=>{if(j(z)&&F===M)Q.off(z)}).catch((z)=>{if(!R(z))console.error("Async effect error:",z)})}else if(H=$(),j(H))Q.off(H)}catch(M){if(!R(M))console.error("Effect callback error:",M)}W=!1},Q));return Q(),()=>{F?.abort(),Q.cleanup()}};var n="Store",S=($)=>{let B=new Set,W=new EventTarget,F=new Map,Q=new Map,H=V(0),M=()=>{let Z=Array.from(F.keys()),L=e(Z);if(console.log(Z,L),L)return L.map((J)=>F.get(String(J))?.get());let G={};for(let[J,X]of F)G[J]=X.get();return G},z=(Z,L)=>W.dispatchEvent(new CustomEvent(Z,{detail:L})),x=(Z,L)=>{let G=u(L);F.set(Z,G);let J=o(()=>{let X=G.get();if(X!=null)z("store-change",{[Z]:X})});Q.set(Z,J)},N=(Z)=>{F.delete(Z);let L=Q.get(Z);if(L)L();Q.delete(Z)},Y=(Z,L)=>{let G=i(Z,L);return v(()=>{if(Object.keys(G.add).length){for(let J in G.add){let X=G.add[J];if(X!=null)x(J,X)}z("store-add",G.add)}if(Object.keys(G.change).length){for(let J in G.change){let X=F.get(J),T=G.change[J];if(X&&T!=null&&$$(X,"set"))X.set(T)}z("store-change",G.change)}if(Object.keys(G.remove).length){for(let J in G.remove)N(J);z("store-remove",G.remove)}H.set(F.size)}),G.changed};Y({},$),setTimeout(()=>{let Z=new CustomEvent("store-add",{detail:$});W.dispatchEvent(Z)},0);let _=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"];return new Proxy({},{get(Z,L){switch(L){case"add":return(G,J)=>{if(!F.has(G))x(G,J),C(B),z("store-add",{[G]:J}),H.set(F.size)};case"get":return()=>{return U(B),M()};case"remove":return(G)=>{if(F.has(G))N(G),C(B),z("store-remove",{[G]:A}),H.set(F.size)};case"set":return(G)=>{if(Y(M(),G)){if(C(B),A===G)B.clear()}};case"update":return(G)=>{let J=M(),X=G(J);if(Y(J,X)){if(C(B),A===X)B.clear()}};case"addEventListener":return W.addEventListener.bind(W);case"removeEventListener":return W.removeEventListener.bind(W);case"dispatchEvent":return W.dispatchEvent.bind(W);case"size":return H}if(L===Symbol.toStringTag)return n;if(L===Symbol.iterator)return function*(){for(let[G,J]of F)yield[G,J]};return F.get(String(L))},has(Z,L){let G=String(L);return F.has(G)||_.includes(G)||L===Symbol.toStringTag||L===Symbol.iterator},ownKeys(){return Array.from(F.keys())},getOwnPropertyDescriptor(Z,L){let G=F.get(String(L));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},p=($)=>O($,n);var A=Symbol(),B$=($)=>g($)||s($)||p($);function G$($){if(B$($))return $;if(l($))return t($);if(Array.isArray($))return S(b($));if(P($))return S($);return V($)}function u($){if(g($)||p($))return $;if(Array.isArray($))return S(b($));if(P($))return S($);return V($)}var I=($,B,W)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!W)W=new WeakSet;if(W.has($)||W.has(B))throw new D("isEqual");W.add($),W.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let F=0;F<$.length;F++)if(!I($[F],B[F],W))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(P($)&&P(B)){let F=Object.keys($),Q=Object.keys(B);if(F.length!==Q.length)return!1;for(let H of F){if(!(H in B))return!1;if(!I($[H],B[H],W))return!1}return!0}return!1}finally{W.delete($),W.delete(B)}},i=($,B)=>{let W=new WeakSet;return((Q,H)=>{let M={},z={},x={},N=Object.keys(Q),Y=Object.keys(H),_=new Set([...N,...Y]);for(let L of _){let G=L in Q,J=L in H;if(!G&&J){M[L]=H[L];continue}else if(G&&!J){x[L]=A;continue}let X=Q[L],T=H[L];if(!I(X,T,W))z[L]=T}return{changed:Object.keys(M).length>0||Object.keys(z).length>0||Object.keys(x).length>0,add:M,change:z,remove:x}})($,B)};var r="Computed",t=($)=>{let B=new Set,W=A,F,Q,H=!0,M=!1,z=!1,x=(J)=>{if(!I(J,W))W=J,M=!0;F=void 0,H=!1},N=()=>{M=A!==W,W=A,F=void 0},Y=(J)=>{let X=K(J);M=!F||X.name!==F.name||X.message!==F.message,W=A,F=X},_=(J)=>(X)=>{if(z=!1,Q=void 0,J(X),M)C(B)},Z=E(()=>{if(H=!0,Q?.abort(),B.size)C(B);else Z.cleanup()});Z.off(()=>{Q?.abort()});let L=()=>m(()=>{if(z)throw new D("computed");if(M=!1,f($)){if(Q)return W;Q=new AbortController,Q.signal.addEventListener("abort",()=>{z=!1,Q=void 0,L()},{once:!0})}let J;z=!0;try{J=Q?$(Q.signal):$()}catch(X){if(R(X))N();else Y(X);z=!1;return}if(J instanceof Promise)J.then(_(x),_(Y));else if(J==null||A===J)N();else x(J);z=!1},Z);return{[Symbol.toStringTag]:r,get:()=>{if(U(B),w(),H)L();if(F)throw F;return W}}},s=($)=>O($,r),l=($)=>j($)&&$.length<2;function J$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else B.ok?.($.values)}catch(W){if(B.err&&(!$.errors||!$.errors.includes(K(W))))B.err($.errors?[...$.errors,K(W)]:[K(W)]);else throw W}}function L$($){let B=[],W=!1,F={};for(let[Q,H]of Object.entries($))try{let M=H.get();if(M===A)W=!0;else F[Q]=M}catch(M){B.push(K(M))}if(W)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:F}}export{E as watch,G$ as toSignal,u as toMutableSignal,K as toError,U as subscribe,S as store,V as state,L$ as resolve,m as observe,C as notify,J$ as match,p as isStore,g as isState,B$ as isSignal,j as isFunction,I as isEqual,l as isComputedCallback,s as isComputed,f as isAsyncFunction,R as isAbortError,w as flush,F$ as enqueue,o as effect,i as diff,t as computed,v as batch,b as arrayToRecord,A as UNSET,n as TYPE_STORE,c as TYPE_STATE,r as TYPE_COMPUTED,D as CircularDependencyError};
