var A=(x)=>typeof x==="function";var o=(x)=>A(x)&&x.length<2,F=(x,y)=>Object.prototype.toString.call(x)===`[object ${y}]`,O=(x)=>(y)=>y instanceof x,w=O(Error),p=O(Promise),X=(x)=>w(x)?x:new Error(String(x));function P(x,...y){let j=A(x)?{ok:x}:x,{ok:q,nil:L,err:B}=j,J=()=>N(()=>{let M=[],K=[],C=!1;for(let G of y)try{let $=G.get();if($===H)C=!0;M.push($)}catch($){K.push(X($))}try{if(!C&&!K.length)q(...M);else if(K.length&&B)B(...K);else if(C&&L)L()}catch(G){B?.(X(G))}},J);J()}var _="Computed",E=1000,W=(x)=>{let y=[],j=H,q=null,L=!0,B=!1,J=!1,M=0,K=()=>{if(L=!0,!B)I(y)},C=()=>N(()=>{if(!L||J)return;let $=(z)=>{if(!Object.is(z,j))j=z,L=!1,q=null,B=!1;else B=!0},g=(z)=>{let S=X(z);B=Object.is(S,q),q=S};J=!0;try{let z=x(j);p(z)?z.then((S)=>{$(S),I(y)}).catch(g):$(z)}catch(z){g(z)}finally{J=!1}},K),G={[Symbol.toStringTag]:_,get:()=>{if(M++>=E)throw new Error(`Circular dependency detected: exceeded ${E} iterations`);if(R(y),C(),q)throw q;return j},map:($)=>W(()=>$(G.get())),match:($)=>P($,G)};return G},V=(x)=>F(x,_);var Z,T=0,Y=new Set,D=new Set,m=()=>{while(Y.size||D.size)Y.forEach((x)=>x()),Y.clear(),D.forEach((x)=>x()),D.clear()},H=Symbol(),f=(x)=>U(x)||V(x),b=(x)=>f(x)?x:o(x)?W(x):Q(x),R=(x)=>{if(Z&&!x.includes(Z))x.push(Z)},I=(x)=>{x.forEach((y)=>T?Y.add(y):y())},N=(x,y)=>{let j=Z;Z=y,x(),Z=j},k=(x)=>{if(T++,x(),T--,!T)m()};var d="State",Q=(x)=>{let y=[],j=x,q={[Symbol.toStringTag]:d,get:()=>{return R(y),j},set:(L)=>{if(Object.is(j,L))return;if(j=L,I(y),H===j)y.length=0},update:(L)=>{q.set(L(j))},map:(L)=>{return W(()=>L(j))}};return q},U=(x)=>F(x,d);export{b as toSignal,Q as state,U as isState,f as isSignal,V as isComputed,P as effect,W as computed,k as batch,H as UNSET};
