var R=Symbol(),Q$=($)=>typeof $==="string",X$=($)=>typeof $==="number",y=($)=>typeof $==="symbol",j=($)=>typeof $==="function",w=($)=>j($)&&$.constructor.name==="AsyncFunction",m=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,L=($)=>m($,"Object"),h=($)=>L($)||Array.isArray($),M$=($)=>{if(!$.length)return null;let B=$.map((J)=>Q$(J)?parseInt(J,10):X$(J)?J:NaN);return B.every((J)=>Number.isFinite(J)&&J>=0)?B.sort((J,Q)=>J-Q):null};var V=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var p=($)=>{let B=M$(Object.keys($));if(B===null)return $;let J=[];for(let Q of B)J.push($[String(Q)]);return J};class D extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var N=($,B,J)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(B))throw new D("isEqual");J.add($),J.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Q=0;Q<$.length;Q++)if(!N($[Q],B[Q],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(L($)&&L(B)){let Q=Object.keys($),F=Object.keys(B);if(Q.length!==F.length)return!1;for(let G of Q){if(!(G in B))return!1;if(!N($[G],B[G],J))return!1}return!0}return!1}finally{J.delete($),J.delete(B)}},t=($,B)=>{let J=h($),Q=h(B);if(!J||!Q){let K=!Object.is($,B);return{changed:K,add:K&&Q?B:{},change:{},remove:K&&J?$:{}}}let F=new WeakSet,G={},C={},H={},Y=Object.keys($),P=Object.keys(B),q=new Set([...Y,...P]);for(let K of q){let I=K in $,X=K in B;if(!I&&X){G[K]=B[K];continue}else if(I&&!X){H[K]=R;continue}let W=$[K],Z=B[K];if(!N(W,Z,F))C[K]=Z}return{changed:Object.keys(G).length>0||Object.keys(C).length>0||Object.keys(H).length>0,add:G,change:C,remove:H}};var S,d=new Set,s=0,i=new Map,o,Z$=()=>{o=void 0;let $=Array.from(i.values());i.clear();for(let B of $)B()},H$=()=>{if(o)cancelAnimationFrame(o);o=requestAnimationFrame(Z$)};queueMicrotask(Z$);var g=($)=>{let B=new Set,J=$;return J.off=(Q)=>{B.add(Q)},J.cleanup=()=>{for(let Q of B)Q();B.clear()},J},A=($)=>{if(S&&!$.has(S)){let B=S;$.add(B),S.off(()=>{$.delete(B)})}},x=($)=>{for(let B of $)if(s)d.add(B);else B()},c=()=>{while(d.size){let $=Array.from(d);d.clear();for(let B of $)B()}},l=($)=>{s++;try{$()}finally{c(),s--}},E=($,B)=>{let J=S;S=B;try{$()}finally{S=J}},K$=($,B)=>new Promise((J,Q)=>{i.set(B||Symbol(),()=>{try{J($())}catch(F){Q(F)}}),H$()});var r="Computed",a=($)=>{let B=new Set,J=R,Q,F,G=!0,C=!1,H=!1,Y=(W)=>{if(!N(W,J))J=W,C=!0;Q=void 0,G=!1},P=()=>{C=R!==J,J=R,Q=void 0},q=(W)=>{let Z=U(W);C=!Q||Z.name!==Q.name||Z.message!==Q.message,J=R,Q=Z},_=(W)=>(Z)=>{if(H=!1,F=void 0,W(Z),C)x(B)},K=g(()=>{if(G=!0,F?.abort(),B.size)x(B);else K.cleanup()});K.off(()=>{F?.abort()});let I=()=>E(()=>{if(H)throw new D("computed");if(C=!1,w($)){if(F)return J;F=new AbortController,F.signal.addEventListener("abort",()=>{H=!1,F=void 0,I()},{once:!0})}let W;H=!0;try{W=F?$(F.signal):$()}catch(Z){if(V(Z))P();else q(Z);H=!1;return}if(W instanceof Promise)W.then(_(Y),_(q));else if(W==null||R===W)P();else Y(W);H=!1},K);return{[Symbol.toStringTag]:r,get:()=>{if(A(B),c(),G)I();if(Q)throw Q;return J}}},e=($)=>m($,r),$$=($)=>j($)&&$.length<2;var B$=($)=>{let B=w($),J=!1,Q,F=g(()=>E(()=>{if(J)throw new D("effect");J=!0,Q?.abort(),Q=void 0;let G;try{if(B){Q=new AbortController;let C=Q;$(Q.signal).then((H)=>{if(j(H)&&Q===C)F.off(H)}).catch((H)=>{if(!V(H))console.error("Async effect error:",H)})}else if(G=$(),j(G))F.off(G)}catch(C){if(!V(C))console.error("Effect callback error:",C)}J=!1},F));return F(),()=>{Q?.abort(),F.cleanup()}};function R$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(J){if(B.err&&(!$.errors||!$.errors.includes(U(J))))B.err($.errors?[...$.errors,U(J)]:[U(J)]);else throw J}}function z$($){let B=[],J=!1,Q={};for(let[F,G]of Object.entries($))try{let C=G.get();if(C===R)J=!0;else Q[F]=C}catch(C){B.push(U(C))}if(J)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Q}}var W$="State",T=($)=>{let B=new Set,J=$,Q={[Symbol.toStringTag]:W$,get:()=>{return A(B),J},set:(F)=>{if(N(J,F))return;if(J=F,x(B),R===J)B.clear()},update:(F)=>{Q.set(F(J))}};return Q},f=($)=>m($,W$);var n="Store",v="store-add",F$="store-change",G$="store-remove",k=($)=>{let B=new Set,J=new EventTarget,Q=new Map,F=new Map,G=Array.isArray($),C=T(0),H=()=>{let X={};for(let[W,Z]of Q)X[W]=Z.get();return X},Y=(X,W)=>J.dispatchEvent(new CustomEvent(X,{detail:W})),P=()=>Array.from(Q.keys()).map((X)=>Number(X)).filter((X)=>Number.isInteger(X)).sort((X,W)=>X-W),q=(X,W)=>{if(y(X)||W==null)return!1;let Z=f(W)||b(W)?W:L(W)?k(W):Array.isArray(W)?k(W):T(W);Q.set(X,Z);let M=B$(()=>{let z=Z.get();if(z!=null)Y(F$,{[X]:z})});return F.set(X,M),!0},_=(X)=>{let W=Q.delete(X);if(W){let Z=F.get(X);if(Z)Z();F.delete(X)}return W},K=(X,W,Z)=>{let M=t(X,W);return l(()=>{if(Object.keys(M.add).length){for(let z in M.add){let O=M.add[z];if(O!=null)q(z,O)}if(Z)setTimeout(()=>{Y(v,M.add)},0);else Y(v,M.add)}if(Object.keys(M.change).length){for(let z in M.change){let O=Q.get(z),u=M.change[z];if(J$(O)&&u!=null)O.set(u);else console.error(`Invalid change for key ${z}: ${u}`)}Y(F$,M.change)}if(Object.keys(M.remove).length){for(let z in M.remove)_(z);Y(G$,M.remove)}C.set(Q.size)}),M.changed};K({},$,!0);let I={add:G?(X)=>{let W=Q.size,Z=String(W);if(X==null){console.error(`Invalid value for key ${String(Z)}: ${X}`);return}if(q(Z,X))C.set(Q.size),x(B),Y(v,{[Z]:X});else console.error(`Failed to add value ${X} to key ${String(Z)}`)}:(X,W)=>{if(!Q.has(X)){if(W==null){console.error(`Invalid value for key ${X}: ${W}`);return}if(q(X,W))C.set(Q.size),x(B),Y(v,{[X]:W});else console.error(`Failed to add value ${W} to key ${X}`)}else console.error(`Key ${X} already exists`)},get:()=>{return A(B),p(H())},remove:G?(X)=>{let W=p(H());if(Array.isArray(W)&&X>=0&&X<W.length){let Z=[...W];if(Z.splice(X,1),K(W,Z))x(B)}}:(X)=>{if(Q.has(X))_(X),x(B),Y(G$,{[X]:R}),C.set(Q.size)},set:(X)=>{if(K(H(),X)){if(x(B),R===X)B.clear()}},update:(X)=>{let W=H(),Z=X(p(W));if(K(W,Z)){if(x(B),R===Z)B.clear()}},addEventListener:J.addEventListener.bind(J),removeEventListener:J.removeEventListener.bind(J),dispatchEvent:J.dispatchEvent.bind(J),size:C};return new Proxy({},{get(X,W){if(W===Symbol.toStringTag)return n;if(W===Symbol.isConcatSpreadable)return G;if(W===Symbol.iterator)return G?function*(){let Z=P();for(let M of Z){let z=Q.get(String(M));if(z)yield z}}:function*(){for(let[Z,M]of Q)yield[Z,M]};if(y(W))return;if(W in I)return I[W];if(W==="length"&&G)return A(B),C.get();return Q.get(W)},has(X,W){let Z=String(W);return Z&&Q.has(Z)||Object.keys(I).includes(Z)||W===Symbol.toStringTag||W===Symbol.iterator||W===Symbol.isConcatSpreadable||W==="length"&&G},ownKeys(){return G?P().map((X)=>String(X)).concat(["length"]):Array.from(Q.keys()).map((X)=>String(X))},getOwnPropertyDescriptor(X,W){let Z=(z)=>({enumerable:!1,configurable:!0,writable:!1,value:z});if(W==="length"&&G)return{enumerable:!0,configurable:!0,writable:!1,value:C.get()};if(W===Symbol.isConcatSpreadable)return Z(G);if(W===Symbol.toStringTag)return Z(n);if(y(W))return;if(Object.keys(I).includes(W))return Z(I[W]);let M=Q.get(W);return M?{enumerable:!0,configurable:!0,writable:!0,value:M}:void 0}})},b=($)=>m($,n);var C$=($)=>f($)||e($)||b($),J$=($)=>f($)||b($);function Y$($){if(C$($))return $;if($$($))return a($);if(Array.isArray($)||L($))return k($);return T($)}export{g as watch,Y$ as toSignal,U as toError,A as subscribe,k as store,T as state,z$ as resolve,E as observe,x as notify,R$ as match,y as isSymbol,Q$ as isString,b as isStore,f as isState,C$ as isSignal,h as isRecordOrArray,L as isRecord,X$ as isNumber,J$ as isMutableSignal,j as isFunction,N as isEqual,$$ as isComputedCallback,e as isComputed,w as isAsyncFunction,V as isAbortError,c as flush,K$ as enqueue,B$ as effect,t as diff,a as computed,l as batch,R as UNSET,n as TYPE_STORE,W$ as TYPE_STATE,r as TYPE_COMPUTED,D as CircularDependencyError};
