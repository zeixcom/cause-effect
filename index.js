var K=Symbol(),c=($)=>typeof $==="string",H$=($)=>typeof $==="number",C=($)=>typeof $==="symbol",Y=($)=>typeof $==="function",V=($)=>Y($)&&$.constructor.name==="AsyncFunction",P$=($)=>Y($)&&$.constructor.name!=="AsyncFunction",N=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,S=($)=>N($,"Object"),i=($)=>S($)||Array.isArray($);var m=($)=>$ instanceof DOMException&&$.name==="AbortError",T=($)=>$ instanceof Error?$:Error(String($)),y=($)=>c($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);function t($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(J){if(B.err&&(!$.errors||!$.errors.includes(T(J))))B.err($.errors?[...$.errors,T(J)]:[T(J)]);else throw J}}function l($){let B=[],J=!1,z={};for(let[G,X]of Object.entries($))try{let Z=X.get();if(Z===K)J=!0;else z[G]=Z}catch(Z){B.push(T(Z))}if(J)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:z}}var d,r=new Set,K$=0,j=($)=>{let B=new Set,J=$;return J.onCleanup=(z)=>{B.add(z)},J.stop=()=>{for(let z of B)z();B.clear()},J},L=($)=>{if(d&&!$.has(d)){let B=d;B.onCleanup(()=>{$.delete(B)}),$.add(B)}},A=($)=>{for(let B of $)if(K$)r.add(B);else B()},w=()=>{while(r.size){let $=Array.from(r);r.clear();for(let B of $)B()}},h=($)=>{K$++;try{$()}finally{w(),K$--}},U=($,B)=>{let J=d;d=$||void 0;try{B()}finally{d=J}},I=($,B)=>{for(let J of $)J(B)};var N$="Computed",C$=($,B=K)=>{if(!W$($))throw new b("computed",$);if(B==null)throw new g("computed");let J=new Set,z=B,G,X,Z=!0,q=!1,R=!1,f=(F)=>{if(!O(F,z))z=F,q=!0;G=void 0,Z=!1},_=()=>{q=K!==z,z=K,G=void 0},x=(F)=>{let P=T(F);q=!G||P.name!==G.name||P.message!==G.message,z=K,G=P},Q=(F)=>(P)=>{if(R=!1,X=void 0,F(P),q)A(J)},H=j(()=>{if(Z=!0,X?.abort(),J.size)A(J);else H.stop()});H.onCleanup(()=>{X?.abort()});let M=()=>U(H,()=>{if(R)throw new E("computed");if(q=!1,V($)){if(X)return z;X=new AbortController,X.signal.addEventListener("abort",()=>{R=!1,X=void 0,M()},{once:!0})}let F;R=!0;try{F=X?$(z,X.signal):$(z)}catch(P){if(m(P))_();else x(P);R=!1;return}if(F instanceof Promise)F.then(Q(f),Q(x));else if(F==null||K===F)_();else f(F);R=!1}),D={};return Object.defineProperties(D,{[Symbol.toStringTag]:{value:N$},get:{value:()=>{if(L(J),w(),Z)M();if(G)throw G;return z}}}),D};var W$=($)=>Y($)&&$.length<3;var q$="Collection",M$=($,B)=>{let J=new Set,z={add:new Set,change:new Set,remove:new Set,sort:new Set},G=new Map,X=new Map,Z=[],q=(Q)=>{let H=V(B)?async(F,P)=>{let p=$.byKey(Q);if(!p)return K;let _$=K;return t(l({originSignal:p}),{ok:async({originSignal:Z$})=>{_$=await B(Z$,P)},err:(Z$)=>{console.log(Z$)}}),_$}:()=>{let F=$.byKey(Q);if(!F)return K;let P=K;return t(l({originSignal:F}),{ok:({originSignal:p})=>{P=B(p)},err:(p)=>{console.log(p)}}),P},M=C$(H);if(G.set(Q,M),!Z.includes(Q))Z.push(Q);let D=j(()=>U(D,()=>{M.get(),I(z.change,[Q])}));return D(),X.set(Q,D),!0},R=(Q)=>{if(!G.delete(Q))return;let M=Z.indexOf(Q);if(M>=0)Z.splice(M,1);let D=X.get(Q);if(D)D.stop(),X.delete(Q)};for(let Q=0;Q<$.length;Q++){let H=$.keyAt(Q);if(!H)continue;q(H)}$.on("add",(Q)=>{for(let H of Q)if(!G.has(H))q(H);A(J),I(z.add,Q)}),$.on("remove",(Q)=>{for(let H of Object.keys(Q)){if(!G.has(H))continue;R(H)}Z=Z.filter(()=>!0),A(J),I(z.remove,Q)}),$.on("sort",(Q)=>{Z=[...Q],A(J),I(z.sort,Q)});let f=(Q)=>{let H=Q,M=Number(Q);if(Number.isInteger(M)&&M>=0)H=Z[M]??Q;return G.get(H)},_=()=>Z.map((Q)=>G.get(Q)?.get()).filter((Q)=>Q!==K),x={};return Object.defineProperties(x,{[Symbol.toStringTag]:{value:q$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let Q of Z){let H=G.get(Q);if(H)yield H}}},byKey:{value(Q){return f(Q)}},keyAt:{value(Q){return Z[Q]}},indexOfKey:{value(Q){return Z.indexOf(Q)}},get:{value:()=>{return L(J),_()}},sort:{value:(Q)=>{Z=Z.map((M,D)=>{let F=G.get(M);return[D,M,F?F.get():void 0]}).sort(Q?(M,D)=>Q(M[2],D[2]):(M,D)=>String(M[2]).localeCompare(String(D[2]))).map(([M,D])=>D),A(J),I(z.sort,Z)}},on:{value:(Q,H)=>{return z[Q].add(H),()=>z[Q].delete(H)}},length:{get(){return L(J),G.size}}}),new Proxy(x,{get(Q,H){if(H in Q)return Reflect.get(Q,H);if(!C(H))return f(H)},has(Q,H){if(H in Q)return!0;return G.has(String(H))},ownKeys(Q){let H=Reflect.ownKeys(Q);return[...new Set([...Z,...H])]},getOwnPropertyDescriptor(Q,H){if(H in Q)return Reflect.getOwnPropertyDescriptor(Q,H);if(C(H))return;let M=f(H);return M?{enumerable:!0,configurable:!0,writable:!0,value:M}:void 0}})},T$=($)=>N($,q$);var A$="List";class I${watchers=new Set;listeners={add:new Set,change:new Set,remove:new Set,sort:new Set};signals=new Map;order=[];ownWatchers=new Map;batching=!1;keyCounter=0;keyConfig;constructor($,B){W("list",$,Array.isArray),this.keyConfig=B,this.reconcile([],$,!0)}generateKey($){let B=this.keyCounter++;return c(this.keyConfig)?`${this.keyConfig}${B}`:Y(this.keyConfig)?this.keyConfig($):String(B)}arrayToRecord($){let B={};for(let J=0;J<$.length;J++){let z=$[J];if(z===void 0)continue;let G=this.order[J];if(!G)G=this.generateKey(z),this.order[J]=G;B[G]=z}return B}isValidValue($,B){return W(`list for key "${$}"`,B),!0}addOwnWatcher($,B){let J=j(()=>{U(J,()=>{if(B.get(),!this.batching)I(this.listeners.change,[$])})});this.ownWatchers.set($,J),J()}addProperty($,B,J=!1){if(!this.isValidValue($,B))return!1;let z=e(B);if(this.signals.set($,z),!this.order.includes($))this.order.push($);if(this.listeners.change.size)this.addOwnWatcher($,z);if(J)A(this.watchers),I(this.listeners.add,[$]);return!0}removeProperty($,B=!1){if(!this.signals.delete($))return;let z=this.order.indexOf($);if(z>=0)this.order.splice(z,1);let G=this.ownWatchers.get($);if(G)G.stop(),this.ownWatchers.delete($);if(B)this.order=this.order.filter(()=>!0),A(this.watchers),I(this.listeners.remove,[$])}batchChanges($,B){if(Object.keys($.add).length){for(let J in $.add)this.addProperty(J,$.add[J],!1);if(B)setTimeout(()=>{I(this.listeners.add,Object.keys($.add))},0);else I(this.listeners.add,Object.keys($.add))}if(Object.keys($.change).length)this.batching=!0,h(()=>{for(let J in $.change){let z=$.change[J];if(!this.isValidValue(J,z))continue;let G=this.signals.get(J);if($$(`list item "${J}"`,z,G))G.set(z)}}),this.batching=!1,I(this.listeners.change,Object.keys($.change));if(Object.keys($.remove).length){for(let J in $.remove)this.removeProperty(J);this.order=this.order.filter(()=>!0),I(this.listeners.remove,Object.keys($.remove))}return $.changed}reconcile($,B,J){return this.batchChanges(u(this.arrayToRecord($),this.arrayToRecord(B)),J)}get[Symbol.toStringTag](){return A$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.order){let B=this.signals.get($);if(B)yield B}}get length(){return L(this.watchers),this.signals.size}get(){return L(this.watchers),this.order.map(($)=>this.signals.get($)?.get()).filter(($)=>$!==void 0)}set($){if(this.reconcile(this.get(),$)){if(A(this.watchers),K===$)this.watchers.clear()}}update($){this.set($(this.get()))}at($){return this.signals.get(this.order[$])}keys(){return this.order.values()}byKey($){return this.signals.get($)}keyAt($){return this.order[$]}indexOfKey($){return this.order.indexOf($)}add($){let B=this.generateKey($);if(!this.signals.has(B))return this.addProperty(B,$,!0),B;else throw new v("store",B,$)}remove($){let B=H$($)?this.order[$]:$;if(B&&this.signals.has(B))this.removeProperty(B,!0)}sort($){let J=this.order.map((z)=>[z,this.signals.get(z)?.get()]).sort(Y($)?(z,G)=>$(z[1],G[1]):(z,G)=>String(z[1]).localeCompare(String(G[1]))).map(([z])=>z);if(!O(this.order,J))this.order=J,A(this.watchers),I(this.listeners.sort,this.order)}splice($,B,...J){let z=this.signals.size,G=$<0?Math.max(0,z+$):Math.min($,z),X=Math.max(0,Math.min(B??Math.max(0,z-Math.max(0,G)),z-G)),Z={},q={};for(let _=0;_<X;_++){let x=G+_,Q=this.order[x];if(Q){let H=this.signals.get(Q);if(H)q[Q]=H.get()}}let R=this.order.slice(0,G);for(let _ of J){let x=this.generateKey(_);R.push(x),Z[x]=_}R.push(...this.order.slice(G+X)),this.order=R.filter(()=>!0);let f=!!(Object.keys(Z).length||Object.keys(q).length);if(f)this.batchChanges({add:Z,change:{},remove:q,changed:f});return A(this.watchers),Object.values(q)}on($,B){if(this.listeners[$].add(B),$==="change"&&!this.ownWatchers.size){this.batching=!0;for(let[J,z]of this.signals)this.addOwnWatcher(J,z);for(let J of this.ownWatchers.values())J();this.batching=!1}return()=>{if(this.listeners[$].delete(B),$==="change"&&!this.listeners.change.size){if(this.ownWatchers.size){for(let J of this.ownWatchers.values())J.stop();this.ownWatchers.clear()}}}}deriveCollection($){return M$(this,$)}}var a=($,B)=>{let J=new I$($,B),z=(G)=>{let X=Number(G);return Number.isInteger(X)&&X>=0?J.at(X):J.byKey(G)};return new Proxy(J,{get(G,X){if(X in G)return Reflect.get(G,X);return!C(X)?z(X):void 0},has(G,X){if(X in G)return!0;return!C(X)?z(X)!==void 0:!1},ownKeys(G){return Object.getOwnPropertyNames(G.keys())},getOwnPropertyDescriptor(G,X){if(C(X))return;if(X==="length")return{enumerable:!1,configurable:!1,writable:!1,value:G.length};let Z=Number(X);if(Number.isInteger(Z)&&Z>=0&&Z<G.length){let q=G.at(Z);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}return}})},x$=($)=>N($,A$);var D$="State";class k{#J=new Set;#z;constructor($){W("state",$),this.#z=$}get[Symbol.toStringTag](){return D$}get(){return L(this.#J),this.#z}set($){if(W("state",$),O(this.#z,$))return;if(this.#z=$,A(this.#J),K===this.#z)this.#J.clear()}update($){o("state update",$),this.set($(this.#z))}}var O$=($)=>new k($),B$=($)=>N($,D$);var F$="Store";class L${watchers=new Set;listeners={add:new Set,change:new Set,remove:new Set};signals=new Map;ownWatchers=new Map;batching=!1;constructor($){W("store",$,S),this.reconcile({},$,!0)}isValidValue($,B){return W(`store for key "${$}"`,B),!0}addOwnWatcher($,B){let J=j(()=>{U(J,()=>{if(B.get(),!this.batching)I(this.listeners.change,[$])})});this.ownWatchers.set($,J),J()}addProperty($,B,J=!1){W(`store for key "${$}"`,B);let z=e(B);if(this.signals.set($,z),this.listeners.change.size)this.addOwnWatcher($,z);if(J)A(this.watchers),I(this.listeners.add,[$]);return!0}removeProperty($,B=!1){if(!this.signals.delete($))return;let z=this.ownWatchers.get($);if(z)z.stop(),this.ownWatchers.delete($);if(B)A(this.watchers),I(this.listeners.remove,[$])}batchChanges($,B){if(Object.keys($.add).length){for(let J in $.add)this.addProperty(J,$.add[J],!1);if(B)setTimeout(()=>{I(this.listeners.add,Object.keys($.add))},0);else I(this.listeners.add,Object.keys($.add))}if(Object.keys($.change).length)this.batching=!0,h(()=>{for(let J in $.change){let z=$.change[J];if(!this.isValidValue(J,z))continue;let G=this.signals.get(J);if($$(`store key "${J}"`,z,G))G.set(z)}}),this.batching=!1,I(this.listeners.change,Object.keys($.change));if(Object.keys($.remove).length){for(let J in $.remove)this.removeProperty(J);I(this.listeners.remove,Object.keys($.remove))}return $.changed}reconcile($,B,J){return this.batchChanges(u($,B),J)}get[Symbol.toStringTag](){return F$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,B]of this.signals)yield[$,B]}get(){L(this.watchers);let $={};for(let[B,J]of this.signals)$[B]=J.get();return $}set($){if(this.reconcile(this.get(),$)){if(A(this.watchers),K===$)this.watchers.clear()}}keys(){return this.signals.keys()}byKey($){return this.signals.get($)}update($){this.set($(this.get()))}add($,B){if(this.signals.has($))throw new v("store",$,B);return this.addProperty($,B,!0),$}remove($){if(this.signals.has($))this.removeProperty($,!0)}on($,B){if(this.listeners[$].add(B),$==="change"&&!this.ownWatchers.size){this.batching=!0;for(let[J,z]of this.signals)this.addOwnWatcher(J,z);for(let J of this.ownWatchers.values())J();this.batching=!1}return()=>{if(this.listeners[$].delete(B),$==="change"&&!this.listeners.change.size){if(this.ownWatchers.size){for(let J of this.ownWatchers.values())J.stop();this.ownWatchers.clear()}}}}}var J$=($)=>{let B=new L$($);return new Proxy(B,{get(J,z){if(z in J)return Reflect.get(J,z);if(!C(z))return J.byKey(z)},has(J,z){if(z in J)return!0;return J.byKey(String(z))!==void 0},ownKeys(J){return Array.from(J.keys())},getOwnPropertyDescriptor(J,z){if(C(z))return;if(z in J)return Reflect.getOwnPropertyDescriptor(J,z);let G=J.byKey(String(z));return G?{enumerable:!0,configurable:!0,writable:!0,value:G}:void 0}})},z$=($)=>N($,F$);var f$=($)=>B$($)||R$($)||z$($),Y$=($)=>B$($)||z$($)||x$($),E$=($)=>{if(G$($))return new n($);if(Q$($))return new s($);if(Array.isArray($))return a($);if(S($))return J$($);return new k($)},e=($)=>{if(Array.isArray($))return a($);if(S($))return J$($);return new k($)};class E extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class v extends Error{constructor($,B,J){super(`Could not add ${$} key "${B}"${J?` with value ${y(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class b extends TypeError{constructor($,B){super(`Invalid ${$} callback ${y(B)}`);this.name="InvalidCallbackError"}}class j$ extends TypeError{constructor($,B){super(`Invalid signal value ${y(B)} in ${$}`);this.name="InvalidSignalValueError"}}class g extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class U$ extends Error{constructor($,B){super(`Could not set ${$} to ${y(B)} because signal is read-only`);this.name="ReadonlySignalError"}}var o=($,B,J=Y)=>{if(!J(B))throw new b($,B)},W=($,B,J=()=>!(C(B)&&B!==K)||Y(B))=>{if(B==null)throw new g($);if(!J(B))throw new j$($,B)},$$=($,B,J)=>{if(!Y$(J))throw new U$($,B);return!0};var O=($,B,J)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(B))throw new E("isEqual");J.add($),J.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let z=0;z<$.length;z++)if(!O($[z],B[z],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(S($)&&S(B)){let z=Object.keys($),G=Object.keys(B);if(z.length!==G.length)return!1;for(let X of z){if(!(X in B))return!1;if(!O($[X],B[X],J))return!1}return!0}return!1}finally{J.delete($),J.delete(B)}},u=($,B)=>{let J=i($),z=i(B);if(!J||!z){let x=!Object.is($,B);return{changed:x,add:x&&z?B:{},change:{},remove:x&&J?$:{}}}let G=new WeakSet,X={},Z={},q={},R=Object.keys($),f=Object.keys(B),_=new Set([...R,...f]);for(let x of _){let Q=x in $,H=x in B;if(!Q&&H){X[x]=B[x];continue}else if(Q&&!H){q[x]=K;continue}let M=$[x],D=B[x];if(!O(M,D,G))Z[x]=D}return{add:X,change:Z,remove:q,changed:!!(Object.keys(X).length||Object.keys(Z).length||Object.keys(q).length)}};var X$="Computed";class n{#J=new Set;#z;#$;#B;#Z=!0;#G=!1;#Q;constructor($,B=K){o("memo",$,G$),W("memo",B),this.#z=$,this.#$=B,this.#Q=j(()=>{if(this.#Z=!0,this.#J.size)A(this.#J);else this.#Q.stop()})}get[Symbol.toStringTag](){return X$}get(){if(L(this.#J),w(),this.#Z)U(this.#Q,()=>{if(this.#G)throw new E("memo");let $;this.#G=!0;try{$=this.#z(this.#$)}catch(B){this.#$=K,this.#B=T(B),this.#G=!1;return}if($==null||K===$)this.#$=K,this.#B=void 0;else this.#$=$,this.#B=void 0,this.#Z=!1;this.#G=!1});if(this.#B)throw this.#B;return this.#$}}class s{#J=new Set;#z;#$;#B;#Z=!0;#G=!1;#Q=!1;#H;#X;constructor($,B=K){o("task",$,Q$),W("task",B),this.#z=$,this.#$=B,this.#H=j(()=>{if(this.#Z=!0,this.#X?.abort(),this.#J.size)A(this.#J);else this.#H.stop()}),this.#H.onCleanup(()=>{this.#X?.abort()})}get[Symbol.toStringTag](){return X$}get(){L(this.#J),w();let $=(X)=>{if(!O(X,this.#$))this.#$=X,this.#Q=!0;this.#B=void 0,this.#Z=!1},B=()=>{this.#Q=K!==this.#$,this.#$=K,this.#B=void 0},J=(X)=>{let Z=T(X);this.#Q=!this.#B||Z.name!==this.#B.name||Z.message!==this.#B.message,this.#$=K,this.#B=Z},z=(X)=>(Z)=>{if(this.#G=!1,this.#X=void 0,X(Z),this.#Q)A(this.#J)},G=()=>U(this.#H,()=>{if(this.#G)throw new E("task");if(this.#Q=!1,this.#X)return this.#$;this.#X=new AbortController,this.#X.signal.addEventListener("abort",()=>{this.#G=!1,this.#X=void 0,G()},{once:!0});let X;this.#G=!0;try{X=this.#z(this.#$,this.#X.signal)}catch(Z){if(m(Z))B();else J(Z);this.#G=!1;return}if(X instanceof Promise)X.then(z($),z(J));else if(X==null||K===X)B();else $(X);this.#G=!1});if(this.#Z)G();if(this.#B)throw this.#B;return this.#$}}var V$=($,B=K)=>V($)?new s($,B):new n($,B),R$=($)=>N($,X$),G$=($)=>P$($)&&$.length<2,Q$=($)=>V($)&&$.length<3;var S$=($)=>{if(!Y($)||$.length>1)throw new b("effect",$);let B=V($),J=!1,z,G=j(()=>U(G,()=>{if(J)throw new E("effect");J=!0,z?.abort(),z=void 0;let X;try{if(B){z=new AbortController;let Z=z;$(z.signal).then((q)=>{if(Y(q)&&z===Z)G.onCleanup(q)}).catch((q)=>{if(!m(q))console.error("Async effect error:",q)})}else if(X=$(),Y(X))G.onCleanup(X)}catch(Z){if(!m(Z))console.error("Effect callback error:",Z)}J=!1}));return G(),()=>{z?.abort(),G.stop()}};export{y as valueString,U as trackSignalReads,T as toError,L as subscribeActiveWatcher,l as resolve,A as notifyWatchers,t as match,Q$ as isTaskCallback,C as isSymbol,c as isString,z$ as isStore,B$ as isState,f$ as isSignal,i as isRecordOrArray,S as isRecord,N as isObjectOfType,H$ as isNumber,Y$ as isMutableSignal,G$ as isMemoCallback,x$ as isList,Y as isFunction,O as isEqual,R$ as isComputed,T$ as isCollection,V as isAsyncFunction,m as isAbortError,w as flushPendingReactions,I as emitNotification,u as diff,j as createWatcher,J$ as createStore,O$ as createState,E$ as createSignal,a as createList,S$ as createEffect,V$ as createComputed,M$ as createCollection,h as batchSignalWrites,K as UNSET,s as Task,F$ as TYPE_STORE,D$ as TYPE_STATE,A$ as TYPE_LIST,X$ as TYPE_COMPUTED,q$ as TYPE_COLLECTION,L$ as Store,k as State,U$ as ReadonlySignalError,g as NullishSignalValueError,n as Memo,I$ as List,j$ as InvalidSignalValueError,b as InvalidCallbackError,v as DuplicateKeyError,E as CircularDependencyError};
