var H=Symbol(),xx=(x)=>typeof x==="string",$x=(x)=>typeof x==="number",Y=(x)=>typeof x==="function",_=(x)=>Y(x)&&x.constructor.name==="AsyncFunction",P=(x,$)=>Object.prototype.toString.call(x)===`[object ${$}]`,K=(x)=>P(x,"Object"),O=(x)=>K(x)||Array.isArray(x),Xx=(x)=>{if(!x.length)return null;let $=x.map((B)=>xx(B)?parseInt(B,10):$x(B)?B:NaN);return $.every((B)=>Number.isFinite(B)&&B>=0)?$.sort((B,W)=>B-W):null},Bx=(x,$)=>($ in x)&&Y(x[$]),j=(x)=>x instanceof DOMException&&x.name==="AbortError",M=(x)=>x instanceof Error?x:Error(String(x));var b=(x)=>{let $=Xx(Object.keys(x));if($===null)return x;let B=[];for(let W of $)B.push(x[String(W)]);return B};class U extends Error{constructor(x){super(`Circular dependency in ${x} detected`);this.name="CircularDependencyError"}}var q=(x,$,B)=>{if(Object.is(x,$))return!0;if(typeof x!==typeof $)return!1;if(typeof x!=="object"||x===null||$===null)return!1;if(!B)B=new WeakSet;if(B.has(x)||B.has($))throw new U("isEqual");B.add(x),B.add($);try{if(Array.isArray(x)&&Array.isArray($)){if(x.length!==$.length)return!1;for(let W=0;W<x.length;W++)if(!q(x[W],$[W],B))return!1;return!0}if(Array.isArray(x)!==Array.isArray($))return!1;if(K(x)&&K($)){let W=Object.keys(x),Q=Object.keys($);if(W.length!==Q.length)return!1;for(let A of W){if(!(A in $))return!1;if(!q(x[A],$[A],B))return!1}return!0}return!1}finally{B.delete(x),B.delete($)}},h=(x,$)=>{let B=O(x),W=O($);if(!B||!W){let J=!Object.is(x,$);return{changed:J,add:J&&W?$:{},change:{},remove:J&&B?x:{}}}let Q=new WeakSet,A={},G={},F={},D=Object.keys(x),N=Object.keys($),R=new Set([...D,...N]);for(let J of R){let L=J in x,X=J in $;if(!L&&X){A[J]=$[J];continue}else if(L&&!X){F[J]=H;continue}let Z=x[J],z=$[J];if(!q(Z,z,Q))G[J]=z}return{changed:Object.keys(A).length>0||Object.keys(G).length>0||Object.keys(F).length>0,add:A,change:G,remove:F}};var m,k=new Set,d=0,o=new Map,w,Wx=()=>{w=void 0;let x=Array.from(o.values());o.clear();for(let $ of x)$()},Zx=()=>{if(w)cancelAnimationFrame(w);w=requestAnimationFrame(Wx)};queueMicrotask(Wx);var T=(x)=>{let $=new Set,B=x;return B.off=(W)=>{$.add(W)},B.cleanup=()=>{for(let W of $)W();$.clear()},B},S=(x)=>{if(m&&!x.has(m)){let $=m;x.add($),m.off(()=>{x.delete($)})}},I=(x)=>{for(let $ of x)if(d)k.add($);else $()},g=()=>{while(k.size){let x=Array.from(k);k.clear();for(let $ of x)$()}},n=(x)=>{d++;try{x()}finally{g(),d--}},f=(x,$)=>{let B=m;m=$;try{x()}finally{m=B}},Fx=(x,$)=>new Promise((B,W)=>{o.set($||Symbol(),()=>{try{B(x())}catch(Q){W(Q)}}),Zx()});var v="Computed",c=(x)=>{let $=new Set,B=H,W,Q,A=!0,G=!1,F=!1,D=(Z)=>{if(!q(Z,B))B=Z,G=!0;W=void 0,A=!1},N=()=>{G=H!==B,B=H,W=void 0},R=(Z)=>{let z=M(Z);G=!W||z.name!==W.name||z.message!==W.message,B=H,W=z},C=(Z)=>(z)=>{if(F=!1,Q=void 0,Z(z),G)I($)},J=T(()=>{if(A=!0,Q?.abort(),$.size)I($);else J.cleanup()});J.off(()=>{Q?.abort()});let L=()=>f(()=>{if(F)throw new U("computed");if(G=!1,_(x)){if(Q)return B;Q=new AbortController,Q.signal.addEventListener("abort",()=>{F=!1,Q=void 0,L()},{once:!0})}let Z;F=!0;try{Z=Q?x(Q.signal):x()}catch(z){if(j(z))N();else R(z);F=!1;return}if(Z instanceof Promise)Z.then(C(D),C(R));else if(Z==null||H===Z)N();else D(Z);F=!1},J);return{[Symbol.toStringTag]:v,get:()=>{if(S($),g(),A)L();if(W)throw W;return B}}},u=(x)=>P(x,v),i=(x)=>Y(x)&&x.length<2;var s=(x)=>{let $=_(x),B=!1,W,Q=T(()=>f(()=>{if(B)throw new U("effect");B=!0,W?.abort(),W=void 0;let A;try{if($){W=new AbortController;let G=W;x(W.signal).then((F)=>{if(Y(F)&&W===G)Q.off(F)}).catch((F)=>{if(!j(F))console.error("Async effect error:",F)})}else if(A=x(),Y(A))Q.off(A)}catch(G){if(!j(G))console.error("Effect callback error:",G)}B=!1},Q));return Q(),()=>{W?.abort(),Q.cleanup()}};function Gx(x,$){try{if(x.pending)$.nil?.();else if(x.errors)$.err?.(x.errors);else if(x.ok)$.ok(x.values)}catch(B){if($.err&&(!x.errors||!x.errors.includes(M(B))))$.err(x.errors?[...x.errors,M(B)]:[M(B)]);else throw B}}function Ax(x){let $=[],B=!1,W={};for(let[Q,A]of Object.entries(x))try{let G=A.get();if(G===H)B=!0;else W[Q]=G}catch(G){$.push(M(G))}if(B)return{ok:!1,pending:!0};if($.length>0)return{ok:!1,errors:$};return{ok:!0,values:W}}var t="State",y=(x)=>{let $=new Set,B=x,W={[Symbol.toStringTag]:t,get:()=>{return S($),B},set:(Q)=>{if(q(B,Q))return;if(B=Q,I($),H===B)$.clear()},update:(Q)=>{W.set(Q(B))}};return W},E=(x)=>P(x,t);var l="Store",r="store-add",Jx="store-change",Lx="store-remove",zx=["add","get","remove","set","update","addEventListener","removeEventListener","dispatchEvent","size"],V=(x)=>{let $=new Set,B=new EventTarget,W=new Map,Q=new Map,A=y(0),G=()=>{let C={};for(let[J,L]of W)C[String(J)]=L.get();return C},F=(C,J)=>B.dispatchEvent(new CustomEvent(C,{detail:J})),D=(C,J)=>{let L=String(C),X=a(J);W.set(L,X);let Z=s(()=>{let z=X.get();if(z!=null)F(Jx,{[C]:z})});Q.set(L,Z)},N=(C)=>{let J=String(C);W.delete(J);let L=Q.get(J);if(L)L();Q.delete(J)},R=(C,J,L)=>{let X=h(C,J);return n(()=>{if(Object.keys(X.add).length){for(let Z in X.add){let z=X.add[Z];if(z!=null)D(Z,z)}if(L)setTimeout(()=>{F(r,X.add)},0);else F(r,X.add)}if(Object.keys(X.change).length){for(let Z in X.change){let z=W.get(Z),e=X.change[Z];if(z&&e!=null&&Bx(z,"set"))z.set(e)}F(Jx,X.change)}if(Object.keys(X.remove).length){for(let Z in X.remove)N(Z);F(Lx,X.remove)}A.set(W.size)}),X.changed};return R({},x,!0),new Proxy({},{get(C,J){switch(J){case"add":return(L,X)=>{if(!W.has(String(L)))D(L,X),I($),F(r,{[L]:X}),A.set(W.size)};case"get":return()=>{return S($),b(G())};case"remove":return(L)=>{if(W.has(String(L)))N(L),I($),F(Lx,{[L]:H}),A.set(W.size)};case"set":return(L)=>{if(R(G(),L)){if(I($),H===L)$.clear()}};case"update":return(L)=>{let X=G(),Z=L(b(X));if(R(X,Z)){if(I($),H===Z)$.clear()}};case"addEventListener":return B.addEventListener.bind(B);case"removeEventListener":return B.removeEventListener.bind(B);case"dispatchEvent":return B.dispatchEvent.bind(B);case"size":return A}if(J===Symbol.toStringTag)return l;if(J===Symbol.iterator)return function*(){for(let[L,X]of W)yield[L,X]};return W.get(String(J))},has(C,J){let L=String(J);return W.has(L)||zx.includes(L)||J===Symbol.toStringTag||J===Symbol.iterator},ownKeys(){return Array.from(W.keys()).map((C)=>String(C))},getOwnPropertyDescriptor(C,J){let L=W.get(String(J));return L?{enumerable:!0,configurable:!0,writable:!0,value:L}:void 0}})},p=(x)=>P(x,l);var Qx=(x)=>E(x)||u(x)||p(x);function Cx(x){if(Qx(x))return x;if(i(x))return c(x);if(Array.isArray(x))return V(x);if(Array.isArray(x)||K(x))return V(x);return y(x)}function a(x){if(E(x)||p(x))return x;if(Array.isArray(x))return V(x);if(K(x))return V(x);return y(x)}export{T as watch,Cx as toSignal,a as toMutableSignal,M as toError,S as subscribe,V as store,y as state,Ax as resolve,f as observe,I as notify,Gx as match,xx as isString,p as isStore,E as isState,Qx as isSignal,O as isRecordOrArray,K as isRecord,$x as isNumber,Y as isFunction,q as isEqual,i as isComputedCallback,u as isComputed,_ as isAsyncFunction,j as isAbortError,g as flush,Fx as enqueue,s as effect,h as diff,c as computed,n as batch,H as UNSET,l as TYPE_STORE,t as TYPE_STATE,v as TYPE_COMPUTED,U as CircularDependencyError};
