function y($){return typeof $==="function"}function t($){return y($)&&$.constructor.name==="AsyncFunction"}function J$($){return y($)&&$.constructor.name!=="AsyncFunction"}function f($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function w($){return f($,"Object")}function V$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function D$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class z$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class I$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class r extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class X$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${D$(J)} is invalid`);this.name="InvalidSignalValueError"}}class A$ extends TypeError{constructor($,J){super(`[${$}] Callback ${D$(J)} is invalid`);this.name="InvalidCallbackError"}}class P$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class n extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function O($,J,z){if(J==null)throw new I$($);if(z&&!z(J))throw new X$($,J)}function Z$($,J){if(J==null)throw new r($)}function L($,J,z=y){if(!z(J))throw new A$($,J)}var k="State",v="Memo",c="Task",u="Sensor",b="List",g="Collection",d="Store",_=0,R$=1,P=2,Q$=4,G=null,p=null,F$=[],C=0,Y$=!1,l=($,J)=>$===J,f$=($,J)=>!1;function p$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function x($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,Q=J.flags&Q$;if(Q){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let W=$.sinksTail;if(W?.sink===J&&(!Q||p$(W,J)))return;let q={source:$,sink:J,nextSource:X,prevSink:W,nextSink:null};if(J.sourcesTail=$.sinksTail=q,z)z.nextSource=q;else J.sources=q;if(W)W.nextSink=q;else $.sinks=q}function y$($){let{source:J,nextSource:z,nextSink:X,prevSink:Q}=$;if(X)X.prevSink=Q;else J.sinksTail=Q;if(Q)Q.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function B$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=y$(z);if(J)J.nextSource=null;else $.sources=null}function V($,J=P){let z=$.flags;if("sinks"in $){if((z&(P|R$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)V(X.sink,R$)}else{if(z&P)return;$.flags=P,F$.push($)}}function q$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)V(z.sink);if(C===0)Y()}function a($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function K$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function g$($){let J=G;G=$,$.sourcesTail=null,$.flags=Q$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{G=J,B$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&R$)X.sink.flags|=P}$.flags=_}function k$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=G;G=$,$.sourcesTail=null,$.flags=Q$;let X;try{X=$.fn($.value,J.signal)}catch(Q){$.controller=void 0,$.error=Q instanceof Error?Q:Error(String(Q));return}finally{G=z,B$($)}X.then((Q)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(Q,$.value)){$.value=Q,$.error=void 0;for(let W=$.sinks;W;W=W.nextSink)V(W.sink);if(C===0)Y()}},(Q)=>{if(J.signal.aborted)return;$.controller=void 0;let W=Q instanceof Error?Q:Error(String(Q));if(!$.error||W.name!==$.error.name||W.message!==$.error.message){$.error=W;for(let q=$.sinks;q;q=q.nextSink)V(q.sink);if(C===0)Y()}}),$.flags=_}function w$($){K$($);let J=G,z=p;G=p=$,$.sourcesTail=null,$.flags=Q$;try{let X=$.fn();if(typeof X==="function")a($,X)}finally{G=J,p=z,B$($)}$.flags=_}function T($){if($.flags&R$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)T(J.source);if($.flags&P)break}if($.flags&Q$)throw new z$("controller"in $?c:("value"in $)?v:"Effect");if($.flags&P)if("controller"in $)k$($);else if("value"in $)g$($);else w$($);else $.flags=_}function Y(){if(Y$)return;Y$=!0;try{for(let $=0;$<F$.length;$++){let J=F$[$];if(J.flags&P)T(J)}F$.length=0}finally{Y$=!1}}function e($){C++;try{$()}finally{if(C--,C===0)Y()}}function s($){let J=G;G=null;try{return $()}finally{G=J}}function v$($){let J=p,z={cleanup:null};p=z;try{let X=$();if(typeof X==="function")a(z,X);let Q=()=>K$(z);if(J)a(J,Q);return Q}finally{p=J}}function S($,J){O(k,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??l,guard:J?.guard};return{[Symbol.toStringTag]:k,get(){if(G)x(z,G);return z.value},set(X){O(k,X,z.guard),q$(z,X)},update(X){L(k,X);let Q=X(z.value);O(k,Q,z.guard),q$(z,Q)}}}function M$($){return f($,k)}function o($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new z$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let Q=$,W=J;if(Q.length!==W.length)return!1;for(let q=0;q<Q.length;q++)if(!o(Q[q],W[q],z))return!1;return!0}if(w($)&&w(J)){let Q=Object.keys($),W=Object.keys(J);if(Q.length!==W.length)return!1;for(let q of Q){if(!(q in J))return!1;if(!o($[q],J[q],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function U$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function L$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function c$($,J,z,X,Q){let W=new WeakSet,q={},M={},R={},F=[],j=!1,Z=new Map;for(let D=0;D<$.length;D++){let H=z[D];if(H&&$[D])Z.set(H,$[D])}let m=new Set;for(let D=0;D<J.length;D++){let H=J[D];if(H===void 0)continue;let B=Q?X(H):z[D]??X(H);if(m.has(B))throw new n(b,B,H);if(F.push(B),m.add(B),!Z.has(B))q[B]=H,j=!0;else{let U=Z.get(B);if(!o(U,H,W))M[B]=H,j=!0}}for(let[D]of Z)if(!m.has(D))R[D]=null,j=!0;if(!j&&!U$(z,F))j=!0;return{add:q,change:M,remove:R,newKeys:F,changed:j}}function j$($,J){O(b,$,Array.isArray);let z=new Map,X=[],[Q,W]=L$(J?.keyConfig),q=()=>X.map((H)=>z.get(H)?.get()).filter((H)=>H!==void 0),M={fn:q,value:$,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:o,error:void 0},R=(H)=>{let B={};for(let U=0;U<H.length;U++){let N=H[U];if(N===void 0)continue;let K=X[U];if(!K)K=Q(N),X[U]=K;B[K]=N}return B},F=(H)=>{let B=!1;for(let U in H.add){let N=H.add[U];O(`${b} item for key "${U}"`,N),z.set(U,S(N)),B=!0}if(Object.keys(H.change).length)e(()=>{for(let U in H.change){let N=H.change[U];O(`${b} item for key "${U}"`,N);let K=z.get(U);if(K)K.set(N)}});for(let U in H.remove){z.delete(U);let N=X.indexOf(U);if(N!==-1)X.splice(N,1);B=!0}if(B)M.sources=null,M.sourcesTail=null;return H.changed},j=J?.watched,Z=j?()=>{if(G){if(!M.sinks)M.stop=j();x(M,G)}}:()=>{if(G)x(M,G)},m=R($);for(let H in m){let B=m[H];O(`${b} item for key "${H}"`,B),z.set(H,S(B))}M.value=$,M.flags=0;let D={[Symbol.toStringTag]:b,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of X){let B=z.get(H);if(B)yield B}},get length(){return Z(),X.length},get(){if(Z(),M.sources){if(M.flags)M.value=s(q),M.flags=_}else if(T(M),M.error)throw M.error;return M.value},set(H){let B=M.flags&P?q():M.value,U=c$(B,H,X,Q,W);if(U.changed){X=U.newKeys,F(U),M.flags|=P;for(let N=M.sinks;N;N=N.nextSink)V(N.sink);if(C===0)Y()}},update(H){D.set(H(D.get()))},at(H){return z.get(X[H])},keys(){return Z(),X.values()},byKey(H){return z.get(H)},keyAt(H){return X[H]},indexOfKey(H){return X.indexOf(H)},add(H){let B=Q(H);if(z.has(B))throw new n(b,B,H);if(!X.includes(B))X.push(B);O(`${b} item for key "${B}"`,H),z.set(B,S(H)),M.sources=null,M.sourcesTail=null,M.flags|=P;for(let U=M.sinks;U;U=U.nextSink)V(U.sink);if(C===0)Y();return B},remove(H){let B=typeof H==="number"?X[H]:H;if(z.delete(B)){let N=typeof H==="number"?H:X.indexOf(B);if(N>=0)X.splice(N,1);M.sources=null,M.sourcesTail=null,M.flags|=P;for(let K=M.sinks;K;K=K.nextSink)V(K.sink);if(C===0)Y()}},sort(H){let U=X.map((N)=>[N,z.get(N)?.get()]).sort(y(H)?(N,K)=>H(N[1],K[1]):(N,K)=>String(N[1]).localeCompare(String(K[1]))).map(([N])=>N);if(!U$(X,U)){X=U,M.flags|=P;for(let N=M.sinks;N;N=N.nextSink)V(N.sink);if(C===0)Y()}},splice(H,B,...U){let N=X.length,K=H<0?Math.max(0,N+H):Math.min(H,N),$$=Math.max(0,Math.min(B??Math.max(0,N-Math.max(0,K)),N-K)),I={},A={};for(let E=0;E<$$;E++){let i=K+E,C$=X[i];if(C$){let E$=z.get(C$);if(E$)A[C$]=E$.get()}}let h=X.slice(0,K);for(let E of U){let i=Q(E);if(z.has(i)&&!(i in A))throw new n(b,i,E);h.push(i),I[i]=E}h.push(...X.slice(K+$$));let m$=!!(Object.keys(I).length||Object.keys(A).length);if(m$){F({add:I,change:{},remove:A,changed:m$}),X=h,M.flags|=P;for(let E=M.sinks;E;E=E.nextSink)V(E.sink);if(C===0)Y()}return Object.values(A)},deriveCollection(H){return O$(D,H)}};return D}function N$($){return f($,b)}function W$($,J){if(L(v,$,J$),J?.value!==void 0)O(v,J.value,J?.guard);let z={fn:$,value:J?.value,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??l,error:void 0,stop:void 0},X=J?.watched,Q=X?()=>{if(G){if(!z.sinks)z.stop=X(()=>{z.flags|=P;for(let W=z.sinks;W;W=W.nextSink)V(W.sink);if(C===0)Y()});x(z,G)}}:()=>{if(G)x(z,G)};return{[Symbol.toStringTag]:v,get(){if(Q(),T(z),z.error)throw z.error;return Z$(v,z.value),z.value}}}function b$($){return f($,v)}function H$($,J){if(L(c,$,t),J?.value!==void 0)O(c,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:P,equals:J?.equals??l,controller:void 0,error:void 0,stop:void 0},X=J?.watched,Q=X?()=>{if(G){if(!z.sinks)z.stop=X(()=>{z.flags|=P;for(let W=z.sinks;W;W=W.nextSink)V(W.sink);if(C===0)Y()});x(z,G)}}:()=>{if(G)x(z,G)};return{[Symbol.toStringTag]:c,get(){if(Q(),T(z),z.error)throw z.error;return Z$(c,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function _$($){return f($,c)}function O$($,J){if(L(g,J),!d$($))throw TypeError(`[${g}] Invalid collection source: expected a List or Collection`);let z=t(J),X=new Map,Q=(j)=>{let Z=z?H$(async(m,D)=>{let H=$.byKey(j)?.get();if(H==null)return m;return J(H,D)}):W$(()=>{let m=$.byKey(j)?.get();if(m==null)return;return J(m)});X.set(j,Z)};function W(){let j=Array.from($.keys()),Z=q.value;if(!U$(Z,j)){let m=new Set(Z),D=new Set(j);for(let H of Z)if(!D.has(H))X.delete(H);for(let H of j)if(!m.has(H))Q(H)}return j}let q={fn:W,value:[],flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:U$,error:void 0};function M(){if(q.sources){if(q.flags)q.value=s(W),q.flags=_}else if(T(q),q.error)throw q.error;return q.value}let R=Array.from($.keys());for(let j of R)Q(j);q.value=R;let F={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let j of q.value){let Z=X.get(j);if(Z)yield Z}},get length(){if(G)x(q,G);return M().length},keys(){if(G)x(q,G);return M().values()},get(){if(G)x(q,G);let j=M(),Z=[];for(let m of j)try{let D=X.get(m)?.get();if(D!=null)Z.push(D)}catch(D){if(!(D instanceof r))throw D}return Z},at(j){return X.get(q.value[j])},byKey(j){return X.get(j)},keyAt(j){return q.value[j]},indexOfKey(j){return q.value.indexOf(j)},deriveCollection(j){return O$(F,j)}};return F}function u$($,J){let z=J?.value??[];if(z.length)O(g,z,Array.isArray);L(g,$,J$);let X=new Map,Q=[],W=new Map,[q,M]=L$(J?.keyConfig),R=(B)=>W.get(B)??(M?q(B):void 0),F=J?.createItem??((B,U)=>S(U));function j(){let B=[];for(let U of Q)try{let N=X.get(U)?.get();if(N!=null)B.push(N)}catch(N){if(!(N instanceof r))throw N}return B}let Z={fn:j,value:z,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:f$,error:void 0};function m(B){let{add:U,change:N,remove:K}=B;if(!U?.length&&!N?.length&&!K?.length)return;let $$=!1;e(()=>{if(U)for(let I of U){let A=q(I);if(X.set(A,F(A,I)),W.set(I,A),!Q.includes(A))Q.push(A);$$=!0}if(N)for(let I of N){let A=R(I);if(!A)continue;let h=X.get(A);if(h&&M$(h)){let m$=h.get();W.delete(m$),h.set(I),W.set(I,A)}}if(K)for(let I of K){let A=R(I);if(!A)continue;W.delete(I),X.delete(A);let h=Q.indexOf(A);if(h!==-1)Q.splice(h,1);$$=!0}if($$)Z.sources=null,Z.sourcesTail=null;Z.flags=P;for(let I=Z.sinks;I;I=I.nextSink)V(I.sink)})}for(let B of z){let U=q(B);X.set(U,F(U,B)),W.set(B,U),Q.push(U)}Z.value=z,Z.flags=P;function D(){if(G){if(!Z.sinks)Z.stop=$(m);x(Z,G)}}let H={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let B of Q){let U=X.get(B);if(U)yield U}},get length(){return D(),Q.length},keys(){return D(),Q.values()},get(){if(D(),Z.sources){if(Z.flags)Z.value=s(j),Z.flags=_}else if(T(Z),Z.error)throw Z.error;return Z.value},at(B){return X.get(Q[B])},byKey(B){return X.get(B)},keyAt(B){return Q[B]},indexOfKey(B){return Q.indexOf(B)},deriveCollection(B){return O$(H,B)}};return H}function S$($){return f($,g)}function d$($){return N$($)||S$($)}function t$($){L("Effect",$);let J={fn:$,flags:P,sources:null,sourcesTail:null,cleanup:null},z=()=>{K$(J),J.fn=void 0,J.flags=_,J.sourcesTail=null,B$(J)};if(p)a(p,z);return w$(J),z}function r$($,J){if(!p)throw new P$("match");let{ok:z,err:X=console.error,nil:Q}=J,W,q=!1,M=Array($.length);for(let F=0;F<$.length;F++)try{M[F]=$[F].get()}catch(j){if(j instanceof r){q=!0;continue}if(!W)W=[];W.push(j instanceof Error?j:Error(String(j)))}let R;try{if(q)R=Q?.();else if(W)R=X(W);else R=z(M)}catch(F){X([F instanceof Error?F:Error(String(F))])}if(typeof R==="function")return R;if(R instanceof Promise){let F=p,j=new AbortController;a(F,()=>j.abort()),R.then((Z)=>{if(!j.signal.aborted&&typeof Z==="function")a(F,Z)}).catch((Z)=>{X([Z instanceof Error?Z:Error(String(Z))])})}}function l$($,J){if(L(u,$,J$),J?.value!==void 0)O(u,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??l,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:u,get(){if(G){if(!z.sinks)z.stop=$((X)=>{O(u,X,z.guard),q$(z,X)});x(z,G)}return Z$(u,z.value),z.value}}}function s$($){return f($,u)}function o$($,J){let z=w($)||Array.isArray($),X=w(J)||Array.isArray(J);if(!z||!X){let Z=!Object.is($,J);return{changed:Z,add:Z&&X?J:{},change:{},remove:Z&&z?$:{}}}let Q=new WeakSet,W={},q={},M={},R=!1,F=Object.keys($),j=Object.keys(J);for(let Z of j)if(Z in $){if(!o($[Z],J[Z],Q))q[Z]=J[Z],R=!0}else W[Z]=J[Z],R=!0;for(let Z of F)if(!(Z in J))M[Z]=void 0,R=!0;return{add:W,change:q,remove:M,changed:R}}function G$($,J){O(d,$,w);let z=new Map,X=(j,Z)=>{if(O(`${d} for key "${j}"`,Z),Array.isArray(Z))z.set(j,j$(Z));else if(w(Z))z.set(j,G$(Z));else z.set(j,S(Z))},Q=()=>{let j={};return z.forEach((Z,m)=>{j[m]=Z.get()}),j},W={fn:Q,value:$,flags:P,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:o,error:void 0},q=(j)=>{let Z=!1;for(let m in j.add)X(m,j.add[m]),Z=!0;if(Object.keys(j.change).length)e(()=>{for(let m in j.change){let D=j.change[m];O(`${d} for key "${m}"`,D);let H=z.get(m);if(H)if(w(D)!==x$(H))X(m,D),Z=!0;else H.set(D)}});for(let m in j.remove)z.delete(m),Z=!0;if(Z)W.sources=null,W.sourcesTail=null;return j.changed},M=J?.watched,R=M?()=>{if(G){if(!W.sinks)W.stop=M();x(W,G)}}:()=>{if(G)x(W,G)};for(let j of Object.keys($))X(j,$[j]);let F={[Symbol.toStringTag]:d,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let j of Array.from(z.keys())){let Z=z.get(j);if(Z)yield[j,Z]}},keys(){return R(),z.keys()},byKey(j){return z.get(j)},get(){if(R(),W.sources){if(W.flags)W.value=s(Q),W.flags=_}else if(T(W),W.error)throw W.error;return W.value},set(j){let Z=W.flags&P?Q():W.value,m=o$(Z,j);if(q(m)){W.flags|=P;for(let D=W.sinks;D;D=D.nextSink)V(D.sink);if(C===0)Y()}},update(j){F.set(j(F.get()))},add(j,Z){if(z.has(j))throw new n(d,j,Z);X(j,Z),W.sources=null,W.sourcesTail=null,W.flags|=P;for(let m=W.sinks;m;m=m.nextSink)V(m.sink);if(C===0)Y();return j},remove(j){if(z.delete(j)){W.sources=null,W.sourcesTail=null,W.flags|=P;for(let m=W.sinks;m;m=m.nextSink)V(m.sink);if(C===0)Y()}}};return new Proxy(F,{get(j,Z){if(Z in j)return Reflect.get(j,Z);if(typeof Z!=="symbol")return j.byKey(Z)},has(j,Z){if(Z in j)return!0;return j.byKey(String(Z))!==void 0},ownKeys(j){return Array.from(j.keys())},getOwnPropertyDescriptor(j,Z){if(Z in j)return Reflect.getOwnPropertyDescriptor(j,Z);if(typeof Z==="symbol")return;let m=j.byKey(String(Z));return m?{enumerable:!0,configurable:!0,writable:!0,value:m}:void 0}})}function x$($){return f($,d)}function i$($,J){return t($)?H$($,J):W$($,J)}function n$($){if(T$($))return $;if($==null)throw new X$("createSignal",$);if(t($))return H$($);if(y($))return W$($);if(V$($))return j$($);if(w($))return G$($);return S($)}function a$($){if(h$($))return $;if($==null||y($)||T$($))throw new X$("createMutableSignal",$);if(V$($))return j$($);if(w($))return G$($);return S($)}function e$($){return b$($)||_$($)}function T$($){let J=[k,v,c,u,b,g,d],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function h$($){return M$($)||x$($)||N$($)}export{D$ as valueString,s as untrack,r$ as match,_$ as isTask,x$ as isStore,M$ as isState,T$ as isSignal,s$ as isSensor,w as isRecord,f as isObjectOfType,h$ as isMutableSignal,b$ as isMemo,N$ as isList,y as isFunction,o as isEqual,e$ as isComputed,S$ as isCollection,t as isAsyncFunction,H$ as createTask,G$ as createStore,S as createState,n$ as createSignal,l$ as createSensor,v$ as createScope,a$ as createMutableSignal,W$ as createMemo,j$ as createList,t$ as createEffect,i$ as createComputed,u$ as createCollection,e as batch,r as UnsetSignalValueError,f$ as SKIP_EQUALITY,P$ as RequiredOwnerError,I$ as NullishSignalValueError,X$ as InvalidSignalValueError,A$ as InvalidCallbackError,z$ as CircularDependencyError};
