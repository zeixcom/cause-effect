function Y($){return typeof $==="function"}function v($){return Y($)&&$.constructor.name==="AsyncFunction"}function q$($){return Y($)&&$.constructor.name!=="AsyncFunction"}function C($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function O($){return C($,"Object")}function I$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function j$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class n extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class C$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class c extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class a extends TypeError{constructor($,J){super(`[${$}] Signal value ${j$(J)} is invalid`);this.name="InvalidSignalValueError"}}class V$ extends TypeError{constructor($,J){super(`[${$}] Callback ${j$(J)} is invalid`);this.name="InvalidCallbackError"}}class m$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class l extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function F($,J,z){if(J==null)throw new C$($);if(z&&!z(J))throw new a($,J)}function e($,J){if(J==null)throw new c($)}function _($,J,z=Y){if(!z(J))throw new V$($,J)}var h="State",p="Memo",y="Task",g="Sensor",w="List",S="Collection",k="Store",f=0,x$=1,G=2,Z$=4,j=null,E=null,N$=[],V=0,A$=!1,u=($,J)=>$===J,S$=($,J)=>!1;function h$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function R($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,U=J.flags&Z$;if(U){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let B=$.sinksTail;if(B?.sink===J&&(!U||h$(B,J)))return;let M={source:$,sink:J,nextSource:X,prevSink:B,nextSink:null};if(J.sourcesTail=$.sinksTail=M,z)z.nextSource=M;else J.sources=M;if(B)B.nextSink=M;else $.sinks=M}function p$($){let{source:J,nextSource:z,nextSink:X,prevSink:U}=$;if(X)X.prevSink=U;else J.sinksTail=U;if(U)U.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function Q$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=p$(z);if(J)J.nextSource=null;else $.sources=null}function A($,J=G){let z=$.flags;if("sinks"in $){if((z&(G|x$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)A(X.sink,x$)}else{if(z&G)return;$.flags=G,N$.push($)}}function H$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)A(z.sink);if(V===0)L()}function i($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function G$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function y$($){let J=j;j=$,$.sourcesTail=null,$.flags=Z$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{j=J,Q$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&x$)X.sink.flags|=G}$.flags=f}function g$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=j;j=$,$.sourcesTail=null,$.flags=Z$;let X;try{X=$.fn($.value,J.signal)}catch(U){$.controller=void 0,$.error=U instanceof Error?U:Error(String(U));return}finally{j=z,Q$($)}X.then((U)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(U,$.value)){$.value=U,$.error=void 0;for(let B=$.sinks;B;B=B.nextSink)A(B.sink);if(V===0)L()}},(U)=>{if(J.signal.aborted)return;$.controller=void 0;let B=U instanceof Error?U:Error(String(U));if(!$.error||B.name!==$.error.name||B.message!==$.error.message){$.error=B;for(let M=$.sinks;M;M=M.nextSink)A(M.sink);if(V===0)L()}}),$.flags=f}function Y$($){G$($);let J=j,z=E;j=E=$,$.sourcesTail=null,$.flags=Z$;try{let X=$.fn();if(typeof X==="function")i($,X)}finally{j=J,E=z,Q$($)}$.flags=f}function b($){if($.flags&x$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)b(J.source);if($.flags&G)break}if($.flags&Z$)throw new n("controller"in $?y:("value"in $)?p:"Effect");if($.flags&G)if("controller"in $)g$($);else if("value"in $)y$($);else Y$($);else $.flags=f}function L(){if(A$)return;A$=!0;try{for(let $=0;$<N$.length;$++){let J=N$[$];if(J.flags&G)b(J)}N$.length=0}finally{A$=!1}}function o($){V++;try{$()}finally{if(V--,V===0)L()}}function d($){let J=j;j=null;try{return $()}finally{j=J}}function k$($){let J=E,z={cleanup:null};E=z;try{let X=$();if(typeof X==="function")i(z,X);let U=()=>G$(z);if(J)i(J,U);return U}finally{E=J}}function T($,J){F(h,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard};return{[Symbol.toStringTag]:h,get(){if(j)R(z,j);return z.value},set(X){F(h,X,z.guard),H$(z,X)},update(X){_(h,X);let U=X(z.value);F(h,U,z.guard),H$(z,U)}}}function W$($){return C($,h)}function B$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function t($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new n("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let U=$,B=J;if(U.length!==B.length)return!1;for(let M=0;M<U.length;M++)if(!t(U[M],B[M],z))return!1;return!0}if(O($)&&O(J)){let U=Object.keys($),B=Object.keys(J);if(U.length!==B.length)return!1;for(let M of U){if(!(M in J))return!1;if(!t($[M],J[M],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function v$($,J,z,X,U){let B=new WeakSet,M={},K={},W={},Q=[],H=!1,m=new Map;for(let D=0;D<$.length;D++){let Z=z[D];if(Z&&$[D])m.set(Z,$[D])}let P=new Set;for(let D=0;D<J.length;D++){let Z=J[D];if(Z===void 0)continue;let q=U?X(Z):z[D]??X(Z);if(P.has(q))throw new l(w,q,Z);if(Q.push(q),P.add(q),!m.has(q))M[q]=Z,H=!0;else{let N=m.get(q);if(!t(N,Z,B))K[q]=Z,H=!0}}for(let[D]of m)if(!P.has(D))W[D]=null,H=!0;if(!H&&!B$(z,Q))H=!0;return{add:M,change:K,remove:W,newKeys:Q,changed:H}}function $$($,J){F(w,$,Array.isArray);let z=new Map,X=[],U=0,B=J?.keyConfig,M=Y(B),K=typeof B==="string"?()=>`${B}${U++}`:M?(Z)=>B(Z):()=>String(U++),W=()=>X.map((Z)=>z.get(Z)?.get()).filter((Z)=>Z!==void 0),Q={fn:W,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:t,error:void 0},H=(Z)=>{let q={};for(let N=0;N<Z.length;N++){let x=Z[N];if(x===void 0)continue;let I=X[N];if(!I)I=K(x),X[N]=I;q[I]=x}return q},m=(Z)=>{let q=!1;for(let N in Z.add){let x=Z.add[N];F(`${w} item for key "${N}"`,x),z.set(N,T(x)),q=!0}if(Object.keys(Z.change).length)o(()=>{for(let N in Z.change){let x=Z.change[N];F(`${w} item for key "${N}"`,x);let I=z.get(N);if(I)I.set(x)}});for(let N in Z.remove){z.delete(N);let x=X.indexOf(N);if(x!==-1)X.splice(x,1);q=!0}if(q)Q.sources=null,Q.sourcesTail=null;return Z.changed},P=H($);for(let Z in P){let q=P[Z];F(`${w} item for key "${Z}"`,q),z.set(Z,T(q))}Q.value=$,Q.flags=0;let D={[Symbol.toStringTag]:w,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of X){let q=z.get(Z);if(q)yield q}},get length(){if(j){if(!Q.sinks&&J?.watched)Q.stop=J.watched();R(Q,j)}return X.length},get(){if(j){if(!Q.sinks&&J?.watched)Q.stop=J.watched();R(Q,j)}if(Q.sources){if(Q.flags)Q.value=d(W),Q.flags=f}else if(b(Q),Q.error)throw Q.error;return Q.value},set(Z){let q=Q.flags&G?W():Q.value,N=v$(q,Z,X,K,M);if(N.changed){if(X=N.newKeys,m(N),A(Q),Q.flags|=G,V===0)L()}},update(Z){D.set(Z(D.get()))},at(Z){return z.get(X[Z])},keys(){if(j){if(!Q.sinks&&J?.watched)Q.stop=J.watched();R(Q,j)}return X.values()},byKey(Z){return z.get(Z)},keyAt(Z){return X[Z]},indexOfKey(Z){return X.indexOf(Z)},add(Z){let q=K(Z);if(z.has(q))throw new l(w,q,Z);if(!X.includes(q))X.push(q);if(F(`${w} item for key "${q}"`,Z),z.set(q,T(Z)),Q.sources=null,Q.sourcesTail=null,A(Q),Q.flags|=G,V===0)L();return q},remove(Z){let q=typeof Z==="number"?X[Z]:Z;if(z.delete(q)){let x=typeof Z==="number"?Z:X.indexOf(q);if(x>=0)X.splice(x,1);if(Q.sources=null,Q.sourcesTail=null,A(Q),Q.flags|=G,V===0)L()}},sort(Z){let N=X.map((x)=>[x,z.get(x)?.get()]).sort(Y(Z)?(x,I)=>Z(x[1],I[1]):(x,I)=>String(x[1]).localeCompare(String(I[1]))).map(([x])=>x);if(!B$(X,N)){if(X=N,A(Q),Q.flags|=G,V===0)L()}},splice(Z,q,...N){let x=X.length,I=Z<0?Math.max(0,x+Z):Math.min(Z,x),_$=Math.max(0,Math.min(q??Math.max(0,x-Math.max(0,I)),x-I)),P$={},X$={};for(let r=0;r<_$;r++){let s=I+r,R$=X[s];if(R$){let b$=z.get(R$);if(b$)X$[R$]=b$.get()}}let F$=X.slice(0,I);for(let r of N){let s=K(r);if(z.has(s)&&!(s in X$))throw new l(w,s,r);F$.push(s),P$[s]=r}F$.push(...X.slice(I+_$));let w$=!!(Object.keys(P$).length||Object.keys(X$).length);if(w$){if(m({add:P$,change:{},remove:X$,changed:w$}),X=F$,A(Q),Q.flags|=G,V===0)L()}return Object.values(X$)},deriveCollection(Z){return D$(D,Z)}};return D}function U$($){return C($,w)}function J$($,J){if(_(p,$,q$),J?.value!==void 0)F(p,J.value,J?.guard);let z={fn:$,value:J?.value,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??u,error:void 0};return{[Symbol.toStringTag]:p,get(){if(j)R(z,j);if(b(z),z.error)throw z.error;return e(p,z.value),z.value}}}function L$($){return C($,p)}function z$($,J){if(_(y,$,v),J?.value!==void 0)F(y,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:G,equals:J?.equals??u,controller:void 0,error:void 0};return{[Symbol.toStringTag]:y,get(){if(j)R(z,j);if(b(z),z.error)throw z.error;return e(y,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function f$($){return C($,y)}function D$($,J){if(_(S,J),!u$($))throw TypeError(`[${S}] Invalid collection source: expected a List or Collection`);let z=v(J),X=new Map,U=(H)=>{let m=z?z$(async(P,D)=>{let Z=$.byKey(H)?.get();if(Z==null)return P;return J(Z,D)}):J$(()=>{let P=$.byKey(H)?.get();if(P==null)return;return J(P)});X.set(H,m)};function B(){let H=Array.from($.keys()),m=M.value;if(!B$(m,H)){let P=new Set(m),D=new Set(H);for(let Z of m)if(!D.has(Z))X.delete(Z);for(let Z of H)if(!P.has(Z))U(Z)}return H}let M={fn:B,value:[],flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:B$,error:void 0};function K(){if(M.sources){if(M.flags)M.value=d(B),M.flags=f}else if(b(M),M.error)throw M.error;return M.value}let W=Array.from($.keys());for(let H of W)U(H);M.value=W;let Q={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of M.value){let m=X.get(H);if(m)yield m}},get length(){if(j)R(M,j);return K().length},keys(){if(j)R(M,j);return K().values()},get(){if(j)R(M,j);let H=K(),m=[];for(let P of H)try{let D=X.get(P)?.get();if(D!=null)m.push(D)}catch(D){if(!(D instanceof c))throw D}return m},at(H){return X.get(M.value[H])},byKey(H){return X.get(H)},keyAt(H){return M.value[H]},indexOfKey(H){return M.value.indexOf(H)},deriveCollection(H){return D$(Q,H)}};return Q}function c$($,J){let z=J?.value??[];if(z.length)F(S,z,Array.isArray);_(S,$);let X=new Map,U=[],B=0,M=J?.keyConfig,K=typeof M==="string"?()=>`${M}${B++}`:Y(M)?(Z)=>M(Z):()=>String(B++),W=J?.createItem??((Z,q)=>T(q));function Q(){let Z=[];for(let q of U)try{let N=X.get(q)?.get();if(N!=null)Z.push(N)}catch(N){if(!(N instanceof c))throw N}return Z}let H={fn:Q,value:z,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:()=>!1,error:void 0};function m(Z){if(!Z.changed)return;let q=!1;o(()=>{for(let N in Z.add){let x=Z.add[N];if(X.set(N,W(N,x)),!U.includes(N))U.push(N);q=!0}for(let N in Z.change){let x=X.get(N);if(x&&W$(x))x.set(Z.change[N])}for(let N in Z.remove){X.delete(N);let x=U.indexOf(N);if(x!==-1)U.splice(x,1);q=!0}if(q)H.sources=null,H.sourcesTail=null;H.flags=f,A(H),H.flags|=G})}for(let Z of z){let q=K(Z);X.set(q,W(q,Z)),U.push(q)}H.value=z,H.flags=G;function P(){if(!H.sinks)H.stop=$(m)}let D={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let Z of U){let q=X.get(Z);if(q)yield q}},get length(){if(j)P(),R(H,j);return U.length},keys(){if(j)P(),R(H,j);return U.values()},get(){if(j)P(),R(H,j);if(H.sources){if(H.flags)H.value=d(Q),H.flags=f}else if(b(H),H.error)throw H.error;return H.value},at(Z){return X.get(U[Z])},byKey(Z){return X.get(Z)},keyAt(Z){return U[Z]},indexOfKey(Z){return U.indexOf(Z)},deriveCollection(Z){return D$(D,Z)}};return D}function T$($){return C($,S)}function u$($){return U$($)||T$($)}function d$($){_("Effect",$);let J={fn:$,flags:G,sources:null,sourcesTail:null,cleanup:null},z=()=>{G$(J),J.fn=void 0,J.flags=f,J.sourcesTail=null,Q$(J)};if(E)i(E,z);return Y$(J),z}function t$($,J){if(!E)throw new m$("match");let{ok:z,err:X=console.error,nil:U}=J,B,M=!1,K=Array($.length);for(let Q=0;Q<$.length;Q++)try{K[Q]=$[Q].get()}catch(H){if(H instanceof c){M=!0;continue}if(!B)B=[];B.push(H instanceof Error?H:Error(String(H)))}let W;try{if(M)W=U?.();else if(B)W=X(B);else W=z(K)}catch(Q){X([Q instanceof Error?Q:Error(String(Q))])}if(typeof W==="function")return W;if(W instanceof Promise){let Q=E,H=new AbortController;i(Q,()=>H.abort()),W.then((m)=>{if(!H.signal.aborted&&typeof m==="function")i(Q,m)}).catch((m)=>{X([m instanceof Error?m:Error(String(m))])})}}function r$($,J){if(_(g,$,q$),J?.value!==void 0)F(g,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:g,get(){if(j){if(!z.sinks)z.stop=$((X)=>{F(g,X,z.guard),H$(z,X)});R(z,j)}return e(g,z.value),z.value}}}function s$($){return C($,g)}function l$($,J){let z=O($)||Array.isArray($),X=O(J)||Array.isArray(J);if(!z||!X){let m=!Object.is($,J);return{changed:m,add:m&&X?J:{},change:{},remove:m&&z?$:{}}}let U=new WeakSet,B={},M={},K={},W=!1,Q=Object.keys($),H=Object.keys(J);for(let m of H)if(m in $){if(!t($[m],J[m],U))M[m]=J[m],W=!0}else B[m]=J[m],W=!0;for(let m of Q)if(!(m in J))K[m]=void 0,W=!0;return{add:B,change:M,remove:K,changed:W}}function M$($,J){F(k,$,O);let z=new Map,X=(W,Q)=>{if(F(`${k} for key "${W}"`,Q),Array.isArray(Q))z.set(W,$$(Q));else if(O(Q))z.set(W,M$(Q));else z.set(W,T(Q))},U=()=>{let W={};return z.forEach((Q,H)=>{W[H]=Q.get()}),W},B={fn:U,value:$,flags:G,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:t,error:void 0},M=(W)=>{let Q=!1;for(let H in W.add)X(H,W.add[H]),Q=!0;if(Object.keys(W.change).length)o(()=>{for(let H in W.change){let m=W.change[H];F(`${k} for key "${H}"`,m);let P=z.get(H);if(P)if(O(m)!==K$(P))X(H,m),Q=!0;else P.set(m)}});for(let H in W.remove)z.delete(H),Q=!0;if(Q)B.sources=null,B.sourcesTail=null;return W.changed};for(let W of Object.keys($))X(W,$[W]);let K={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let Q=z.get(W);if(Q)yield[W,Q]}},keys(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();R(B,j)}return z.keys()},byKey(W){return z.get(W)},get(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();R(B,j)}if(B.sources){if(B.flags)B.value=d(U),B.flags=f}else if(b(B),B.error)throw B.error;return B.value},set(W){let Q=B.flags&G?U():B.value,H=l$(Q,W);if(M(H)){if(A(B),B.flags|=G,V===0)L()}},update(W){K.set(W(K.get()))},add(W,Q){if(z.has(W))throw new l(k,W,Q);if(X(W,Q),B.sources=null,B.sourcesTail=null,A(B),B.flags|=G,V===0)L();return W},remove(W){if(z.delete(W)){if(B.sources=null,B.sourcesTail=null,A(B),B.flags|=G,V===0)L()}}};return new Proxy(K,{get(W,Q){if(Q in W){let H=Reflect.get(W,Q);return Y(H)?H.bind(W):H}if(typeof Q!=="symbol")return W.byKey(Q)},has(W,Q){if(Q in W)return!0;return W.byKey(String(Q))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Q){if(Q in W)return Reflect.getOwnPropertyDescriptor(W,Q);if(typeof Q==="symbol")return;let H=W.byKey(String(Q));return H?{enumerable:!0,configurable:!0,writable:!0,value:H}:void 0}})}function K$($){return C($,k)}function i$($,J){return v($)?z$($,J):J$($,J)}function o$($){if(O$($))return $;if($==null)throw new a("createSignal",$);if(v($))return z$($);if(Y($))return J$($);if(I$($))return $$($);if(O($))return M$($);return T($)}function n$($){if(E$($))return $;if($==null||Y($)||O$($))throw new a("createMutableSignal",$);if(I$($))return $$($);if(O($))return M$($);return T($)}function a$($){return L$($)||f$($)}function O$($){let J=[h,p,y,g,w,S,k],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function E$($){return W$($)||K$($)||U$($)}export{j$ as valueString,d as untrack,t$ as match,f$ as isTask,K$ as isStore,W$ as isState,O$ as isSignal,s$ as isSensor,O as isRecord,C as isObjectOfType,E$ as isMutableSignal,L$ as isMemo,U$ as isList,Y as isFunction,t as isEqual,a$ as isComputed,T$ as isCollection,v as isAsyncFunction,z$ as createTask,M$ as createStore,T as createState,o$ as createSignal,r$ as createSensor,k$ as createScope,n$ as createMutableSignal,J$ as createMemo,$$ as createList,d$ as createEffect,i$ as createComputed,c$ as createCollection,o as batch,c as UnsetSignalValueError,S$ as SKIP_EQUALITY,m$ as RequiredOwnerError,C$ as NullishSignalValueError,a as InvalidSignalValueError,V$ as InvalidCallbackError,n as CircularDependencyError};
