var H=Symbol(),d=($)=>typeof $==="string",u=($)=>typeof $==="number",F=($)=>typeof $==="symbol",A=($)=>typeof $==="function",N=($)=>A($)&&$.constructor.name==="AsyncFunction",L$=($)=>A($)&&$.constructor.name!=="AsyncFunction",$$=($)=>$!=null&&typeof $==="object",Y=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,L=($)=>Y($,"Object"),n=($)=>L($)||Array.isArray($),J$=($,J=(z)=>z!=null)=>Array.isArray($)&&$.every(J);var W=($)=>$ instanceof DOMException&&$.name==="AbortError",R=($)=>$ instanceof Error?$:Error(String($)),E=($)=>d($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var _=($,J,z)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!$$($)||!$$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new U("isEqual");z.add($),z.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let G=0;G<$.length;G++)if(!_($[G],J[G],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(L($)&&L(J)){let G=Object.keys($),X=Object.keys(J);if(G.length!==X.length)return!1;for(let Z of G){if(!(Z in J))return!1;if(!_($[Z],J[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}},w=($,J)=>{let z=n($),G=n(J);if(!z||!G){let M=!Object.is($,J);return{changed:M,add:M&&G?J:{},change:{},remove:M&&z?$:{}}}let X=new WeakSet,Z={},Q={},B={},V=Object.keys($),h=Object.keys(J),j=new Set([...V,...h]);for(let M of j){let C=M in $,m=M in J;if(!C&&m){Z[M]=J[M];continue}else if(C&&!m){B[M]=H;continue}let U$=$[M],I$=J[M];if(!_(U$,I$,X))Q[M]=I$}return{add:Z,change:Q,remove:B,changed:!!(Object.keys(Z).length||Object.keys(Q).length||Object.keys(B).length)}};var f,b=new Set,o=0,x=($)=>{let J=new Set,z=$;return z.onCleanup=(G)=>{J.add(G)},z.stop=()=>{for(let G of J)G();J.clear()},z},K=($)=>{if(f&&!$.has(f)){let J=f;J.onCleanup(()=>$.delete(J)),$.add(J)}},q=($)=>{for(let J of $)if(o)b.add(J);else J()},g=()=>{while(b.size){let $=Array.from(b);b.clear();for(let J of $)J()}},z$=($)=>{o++;try{$()}finally{g(),o--}},P=($,J)=>{let z=f;f=$||void 0;try{J()}finally{f=z}},D=($,J)=>{for(let z of $)if(o)b.add(()=>z(J));else z(J)};var c="Computed";class y{#z=new Set;#J;#G;#$;#Z=!0;#Q=!1;#X;constructor($,J=H){T("memo",$,s),I("memo",J),this.#J=$,this.#G=J,this.#X=x(()=>{if(this.#Z=!0,this.#z.size)q(this.#z);else this.#X.stop()})}get[Symbol.toStringTag](){return c}get(){if(K(this.#z),g(),this.#Z)P(this.#X,()=>{if(this.#Q)throw new U("memo");let $;this.#Q=!0;try{$=this.#J(this.#G)}catch(J){this.#G=H,this.#$=R(J),this.#Q=!1;return}if($==null||H===$)this.#G=H,this.#$=void 0;else this.#G=$,this.#$=void 0,this.#Z=!1;this.#Q=!1});if(this.#$)throw this.#$;return this.#G}}class k{#z=new Set;#J;#G;#$;#Z=!0;#Q=!1;#X=!1;#q;#H;constructor($,J=H){T("task",$,i),I("task",J),this.#J=$,this.#G=J,this.#q=x(()=>{if(this.#Z=!0,this.#H?.abort(),this.#z.size)q(this.#z);else this.#q.stop()}),this.#q.onCleanup(()=>{this.#H?.abort()})}get[Symbol.toStringTag](){return c}get(){K(this.#z),g();let $=(Z)=>{if(!_(Z,this.#G))this.#G=Z,this.#X=!0;this.#$=void 0,this.#Z=!1},J=()=>{this.#X=H!==this.#G,this.#G=H,this.#$=void 0},z=(Z)=>{let Q=R(Z);this.#X=!this.#$||Q.name!==this.#$.name||Q.message!==this.#$.message,this.#G=H,this.#$=Q},G=(Z)=>(Q)=>{if(this.#Q=!1,this.#H=void 0,Z(Q),this.#X)q(this.#z)},X=()=>P(this.#q,()=>{if(this.#Q)throw new U("task");if(this.#X=!1,this.#H)return this.#G;this.#H=new AbortController,this.#H.signal.addEventListener("abort",()=>{this.#Q=!1,this.#H=void 0,X()},{once:!0});let Z;this.#Q=!0;try{Z=this.#J(this.#G,this.#H.signal)}catch(Q){if(W(Q))J();else z(Q);this.#Q=!1;return}if(Z instanceof Promise)Z.then(G($),G(z));else if(Z==null||H===Z)J();else $(Z);this.#Q=!1});if(this.#Z)X();if(this.#$)throw this.#$;return this.#G}}var G$=($,J=H)=>N($)?new k($,J):new y($,J),X$=($)=>Y($,c),s=($)=>L$($)&&$.length<2,i=($)=>N($)&&$.length<3;class p{#z;#J=new Map;#G=new Map;#$={add:new Set,change:new Set,remove:new Set};#Z=!1;constructor($,J){this.#z=J,this.change({add:$,change:{},remove:{},changed:!0},!0)}#Q($){let J=x(()=>{P(J,()=>{if(this.#J.get($)?.get(),!this.#Z)D(this.#$.change,[$])})});this.#G.set($,J),J()}#X($){let J=this.#G.get($);if(J)J.stop(),this.#G.delete($)}keys(){return this.#J.keys()}values(){return this.#J.values()}entries(){return this.#J.entries()}has($){return this.#J.has($)}get($){return this.#J.get($)}add($,J){if(!this.#z($,J))return!1;let z=R$(J);if(this.#J.set($,z),this.#$.change.size)this.#Q($);if(!this.#Z)D(this.#$.add,[$]);return!0}remove($){if(!this.#J.delete($))return!1;if(this.#X($),!this.#Z)D(this.#$.remove,[$]);return!0}change($,J){if(this.#Z=!0,Object.keys($.add).length){for(let G in $.add)this.add(G,$.add[G]);let z=()=>D(this.#$.add,Object.keys($.add));if(J)setTimeout(z,0);else z()}if(Object.keys($.change).length)z$(()=>{for(let z in $.change){let G=$.change[z];if(!this.#z(z,G))continue;let X=this.#J.get(z);if(_$(`list item "${z}"`,G,X))X.set(G)}}),D(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let z in $.remove)this.remove(z);D(this.#$.remove,Object.keys($.remove))}return this.#Z=!1,$.changed}clear(){let $=Array.from(this.#J.keys());return this.#J.clear(),this.#G.clear(),D(this.#$.remove,$),!0}on($,J){if(this.#$[$].add(J),$==="change"&&!this.#G.size){this.#Z=!0;for(let z of this.#J.keys())this.#Q(z);this.#Z=!1}return()=>{if(this.#$[$].delete(J),$==="change"&&!this.#$.change.size){if(this.#G.size){for(let z of this.#G.values())z.stop();this.#G.clear()}}}}}var Z$="List";class Q${#z;#J=new Set;#G={sort:new Set};#$=[];#Z;constructor($,J){I("list",$,Array.isArray);let z=0;this.#Z=d(J)?()=>`${J}${z++}`:A(J)?(G)=>J(G):()=>String(z++),this.#z=new p(this.#Q($),(G,X)=>{return I(`list for key "${G}"`,X),!0})}#Q($){let J={};for(let z=0;z<$.length;z++){let G=$[z];if(G===void 0)continue;let X=this.#$[z];if(!X)X=this.#Z(G),this.#$[z]=X;J[X]=G}return J}get#X(){return this.#$.map(($)=>this.#z.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return Z$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let J=this.#z.get($);if(J)yield J}}get length(){return K(this.#J),this.#$.length}get(){return K(this.#J),this.#X}set($){if(H===$){this.#z.clear(),q(this.#J),this.#J.clear();return}let J=this.#X,z=w(this.#Q(J),this.#Q($)),G=Object.keys(z.remove);if(this.#z.change(z)){for(let Z of G){let Q=this.#$.indexOf(Z);if(Q!==-1)this.#$.splice(Q,1)}this.#$=this.#$.filter(()=>!0),q(this.#J)}}update($){this.set($(this.get()))}at($){return this.#z.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#z.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let J=this.#Z($);if(this.#z.has(J))throw new O("store",J,$);if(!this.#$.includes(J))this.#$.push(J);if(this.#z.add(J,$))q(this.#J);return J}remove($){let J=u($)?this.#$[$]:$;if(this.#z.remove(J)){let G=u($)?$:this.#$.indexOf(J);if(G>=0)this.#$.splice(G,1);this.#$=this.#$.filter(()=>!0),q(this.#J)}}sort($){let z=this.#$.map((G)=>[G,this.#z.get(G)?.get()]).sort(A($)?(G,X)=>$(G[1],X[1]):(G,X)=>String(G[1]).localeCompare(String(X[1]))).map(([G])=>G);if(!_(this.#$,z))this.#$=z,q(this.#J),D(this.#G.sort,this.#$)}splice($,J,...z){let G=this.#$.length,X=$<0?Math.max(0,G+$):Math.min($,G),Z=Math.max(0,Math.min(J??Math.max(0,G-Math.max(0,X)),G-X)),Q={},B={};for(let j=0;j<Z;j++){let M=X+j,C=this.#$[M];if(C){let m=this.#z.get(C);if(m)B[C]=m.get()}}let V=this.#$.slice(0,X);for(let j of z){let M=this.#Z(j);V.push(M),Q[M]=j}V.push(...this.#$.slice(X+Z));let h=!!(Object.keys(Q).length||Object.keys(B).length);if(h)this.#z.change({add:Q,change:{},remove:B,changed:h}),this.#$=V.filter(()=>!0),q(this.#J);return Object.values(B)}on($,J){if($==="sort")return this.#G.sort.add(J),()=>this.#G.sort.delete(J);return this.#z.on($,J)}deriveCollection($){return t(this,$)}}var l=($,J)=>{let z=new Q$($,J),G=(X)=>{let Z=Number(X);return Number.isInteger(Z)&&Z>=0?z.at(Z):z.byKey(X)};return new Proxy(z,{get(X,Z){if(Z in X){let Q=Reflect.get(X,Z);return A(Q)?Q.bind(X):Q}return!F(Z)?G(Z):void 0},has(X,Z){if(Z in X)return!0;return!F(Z)?G(Z)!==void 0:!1},ownKeys(X){return Object.getOwnPropertyNames(X.keys())},getOwnPropertyDescriptor(X,Z){if(F(Z))return;if(Z==="length")return{enumerable:!1,configurable:!1,writable:!1,value:X.length};let Q=Number(Z);if(Number.isInteger(Q)&&Q>=0&&Q<X.length){let B=X.at(Q);return B?{enumerable:!0,configurable:!0,writable:!0,value:B}:void 0}return}})},H$=($)=>Y($,Z$);var q$="State";class S{#z=new Set;#J;constructor($){I("state",$),this.#J=$}get[Symbol.toStringTag](){return q$}get(){return K(this.#z),this.#J}set($){if(I("state",$),_(this.#J,$))return;if(this.#J=$,q(this.#z),H===this.#J)this.#z.clear()}update($){T("state update",$),this.set($(this.#J))}}var j$=($)=>new S($),r=($)=>Y($,q$);var B$="Store";class A${#z;#J=new Set;constructor($){I("store",$,L),this.#z=new p($,(J,z)=>{return I(`store for key "${J}"`,z),!0})}get#G(){let $={};for(let[J,z]of this.#z.entries())$[J]=z.get();return $}get[Symbol.toStringTag](){return B$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,J]of this.#z.entries())yield[$,J]}get(){return K(this.#J),this.#G}set($){if(H===$){this.#z.clear(),q(this.#J),this.#J.clear();return}let J=this.#G;if(this.#z.change(w(J,$)))q(this.#J)}keys(){return this.#z.keys()}byKey($){return this.#z.get($)}update($){this.set($(this.get()))}add($,J){if(this.#z.has($))throw new O("store",$,J);if(this.#z.add($,J))q(this.#J);return $}remove($){if(this.#z.remove($))q(this.#J)}on($,J){return this.#z.on($,J)}}var a=($)=>{let J=new A$($);return new Proxy(J,{get(z,G){if(G in z){let X=Reflect.get(z,G);return A(X)?X.bind(z):X}if(!F(G))return z.byKey(G)},has(z,G){if(G in z)return!0;return z.byKey(String(G))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,G){if(G in z)return Reflect.getOwnPropertyDescriptor(z,G);if(F(G))return;let X=z.byKey(String(G));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},e=($)=>Y($,B$);var N$=($)=>r($)||X$($)||e($),M$=($)=>r($)||e($)||H$($);function T$($){if(s($))return new y($);if(i($))return new k($);if(J$($))return l($);if(L($))return a($);return new S($)}function R$($){if(J$($))return l($);if(L($))return a($);return new S($)}class U extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class O extends Error{constructor($,J,z){super(`Could not add ${$} key "${J}"${z?` with value ${E(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class v extends TypeError{constructor($,J){super(`Invalid ${$} callback ${E(J)}`);this.name="InvalidCallbackError"}}class D$ extends TypeError{constructor($,J){super(`Invalid signal value ${E(J)} in ${$}`);this.name="InvalidSignalValueError"}}class F$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class K$ extends Error{constructor($,J){super(`Could not set ${$} to ${E(J)} because signal is read-only`);this.name="ReadonlySignalError"}}var T=($,J,z=A)=>{if(!z(J))throw new v($,J)},I=($,J,z=()=>!(F(J)&&J!==H)||A(J))=>{if(J==null)throw new F$($);if(!z(J))throw new D$($,J)},_$=($,J,z)=>{if(!M$(z))throw new K$($,J);return!0};var Y$="Collection";class P${#z=new Set;#J;#G;#$=new Map;#Z=new Map;#Q={add:new Set,change:new Set,remove:new Set,sort:new Set};#X=[];constructor($,J){this.#J=$,this.#G=J;for(let z=0;z<this.#J.length;z++){let G=this.#J.keyAt(z);if(!G)continue;this.#H(G)}this.#J.on("add",(z)=>{for(let G of z)if(!this.#$.has(G)){this.#H(G);let X=this.#$.get(G);if(X&&x$(this.#G))X.get()}q(this.#z),D(this.#Q.add,z)}),this.#J.on("remove",(z)=>{for(let G of z){if(!this.#$.has(G))continue;this.#$.delete(G);let X=this.#X.indexOf(G);if(X>=0)this.#X.splice(X,1);this.#A(G)}this.#X=this.#X.filter(()=>!0),q(this.#z),D(this.#Q.remove,z)}),this.#J.on("sort",(z)=>{this.#X=[...z],q(this.#z),D(this.#Q.sort,z)})}get#q(){return this.#X.map(($)=>this.#$.get($)?.get()).filter(($)=>$!=null&&$!==H)}#H($){let J=x$(this.#G)?async(G,X)=>{let Z=this.#J.byKey($);if(!Z)return H;let Q=Z.get();if(Q===H)return H;return this.#G(Q,X)}:()=>{let G=this.#J.byKey($);if(!G)return H;let X=G.get();if(X===H)return H;return this.#G(X)},z=G$(J);if(this.#$.set($,z),!this.#X.includes($))this.#X.push($);if(this.#Q.change.size)this.#B($);return!0}#B($){let J=x(()=>{P(J,()=>{this.#$.get($)?.get()})});this.#Z.set($,J),J()}#A($){let J=this.#Z.get($);if(J)J.stop(),this.#Z.delete($)}get[Symbol.toStringTag](){return Y$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#X){let J=this.#$.get($);if(J)yield J}}get length(){return K(this.#z),this.#X.length}get(){return K(this.#z),this.#q}at($){return this.#$.get(this.#X[$])}keys(){return this.#X.values()}byKey($){return this.#$.get($)}keyAt($){return this.#X[$]}indexOfKey($){return this.#X.indexOf($)}on($,J){if(this.#Q[$].add(J),$==="change"&&!this.#Z.size)for(let z of this.#$.keys())this.#B(z);return()=>{if(this.#Q[$].delete(J),$==="change"&&!this.#Q.change.size){if(this.#Z.size){for(let z of this.#Z.values())z.stop();this.#Z.clear()}}}}deriveCollection($){return t(this,$)}}function t($,J){if(T("collection",J),A($))$=$();let z=new P$($,J),G=(X)=>{let Z=Number(X);return Number.isInteger(Z)&&Z>=0?z.at(Z):z.byKey(X)};return new Proxy(z,{get(X,Z){if(Z in X){let Q=Reflect.get(X,Z);return A(Q)?Q.bind(X):Q}if(!F(Z))return G(Z)},has(X,Z){if(Z in X)return!0;return!F(Z)?G(Z)!==void 0:!1},ownKeys(X){return Object.getOwnPropertyNames(X.keys())},getOwnPropertyDescriptor(X,Z){if(F(Z))return;if(Z==="length")return{enumerable:!1,configurable:!1,writable:!1,value:X.length};let Q=Number(Z);if(Number.isInteger(Q)&&Q>=0&&Q<X.length){let B=X.at(Q);return B?{enumerable:!0,configurable:!0,writable:!0,value:B}:void 0}return}})}var C$=($)=>Y($,Y$),x$=($)=>N($);var W$=($)=>{if(!A($)||$.length>1)throw new v("effect",$);let J=N($),z=!1,G,X=x(()=>P(X,()=>{if(z)throw new U("effect");z=!0,G?.abort(),G=void 0;let Z;try{if(J){G=new AbortController;let Q=G;$(G.signal).then((B)=>{if(A(B)&&G===Q)X.onCleanup(B)}).catch((B)=>{if(!W(B))console.error("Async effect error:",B)})}else if(Z=$(),A(Z))X.onCleanup(Z)}catch(Q){if(!W(Q))console.error("Effect callback error:",Q)}z=!1}));return X(),()=>{G?.abort(),X.stop()}};function E$($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(z){if(J.err&&(!$.errors||!$.errors.includes(R(z))))J.err($.errors?[...$.errors,R(z)]:[R(z)]);else throw z}}function f$($){let J=[],z=!1,G={};for(let[X,Z]of Object.entries($))try{let Q=Z.get();if(Q===H)z=!0;else G[X]=Q}catch(Q){J.push(R(Q))}if(z)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:G}}export{E as valueString,P as trackSignalReads,R as toError,K as subscribeActiveWatcher,f$ as resolve,q as notifyWatchers,E$ as match,i as isTaskCallback,F as isSymbol,d as isString,e as isStore,r as isState,N$ as isSignal,n as isRecordOrArray,L as isRecord,Y as isObjectOfType,u as isNumber,M$ as isMutableSignal,s as isMemoCallback,H$ as isList,A as isFunction,_ as isEqual,X$ as isComputed,C$ as isCollection,N as isAsyncFunction,W as isAbortError,g as flushPendingReactions,D as emitNotification,w as diff,x as createWatcher,a as createStore,j$ as createState,T$ as createSignal,l as createList,W$ as createEffect,G$ as createComputed,t as createCollection,z$ as batchSignalWrites,H as UNSET,k as Task,B$ as TYPE_STORE,q$ as TYPE_STATE,Z$ as TYPE_LIST,c as TYPE_COMPUTED,Y$ as TYPE_COLLECTION,S as State,K$ as ReadonlySignalError,F$ as NullishSignalValueError,y as Memo,D$ as InvalidSignalValueError,v as InvalidCallbackError,O as DuplicateKeyError,U as CircularDependencyError,A$ as BaseStore,Q$ as BaseList};
