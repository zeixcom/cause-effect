var q=(x)=>typeof x==="function";var M=(x,B)=>Object.prototype.toString.call(x)===`[object ${B}]`,f=(x)=>(B)=>B instanceof x,I=f(Error),m=f(Promise),V=(x)=>I(x)?x:new Error(String(x));var Z,R=new Set,T=0,w=new Map,N,g=()=>{N=void 0;let x=Array.from(w.values());w.clear();for(let B of x)B()},v=()=>{if(N)cancelAnimationFrame(N);N=requestAnimationFrame(g)};queueMicrotask(g);var D=(x)=>{if(Z&&!x.includes(Z))x.push(Z)},j=(x)=>{for(let B of x)if(T)R.add(B);else B()},S=()=>{while(R.size){let x=Array.from(R);R.clear();for(let B of x)B()}},n=(x)=>{T++;try{x()}finally{S(),T--}},C=(x,B)=>{let z=Z;Z=B;try{x()}finally{Z=z}},i=(x,B)=>new Promise((z,$)=>{let L=()=>{try{z(x())}catch(Q){$(Q)}};if(B)w.set(B,L);v()});function O(x,...B){let z=!1,$=()=>C(()=>{if(z)throw new Error("Circular dependency in effect detected");z=!0;let L=_(B,x);if(I(L))console.error("Unhandled error in effect:",L);z=!1},$);$()}var p="Computed",c=(x,B)=>{if(!B)return!1;return x.name===B.name&&x.message===B.message},A=(x,...B)=>{let z=[],$=J,L,Q=!0,G=!1,W=!1,H=(F)=>{if(!Object.is(F,$))$=F,Q=!1,L=void 0,G=!1},K=()=>{G=J===$,$=J,L=void 0},Y=(F)=>{let P=V(F);G=c(P,L),$=J,L=P},X=()=>{if(Q=!0,!G)j(z)},d=()=>C(()=>{if(W)throw new Error("Circular dependency in computed detected");G=!0,W=!0;let F=_(B,x);if(m(F))K(),F.then((P)=>{H(P),j(z)}).catch(Y);else if(F==null||J===F)K();else if(I(F))Y(F);else H(F);W=!1},X),y={[Symbol.toStringTag]:p,get:()=>{if(D(z),S(),Q)d();if(L)throw L;return $},map:(F)=>A(F,y),match:(F)=>{return O(F,y),y}};return y},U=(x)=>M(x,p);var b="State",k=(x)=>{let B=[],z=x,$={[Symbol.toStringTag]:b,get:()=>{return D(B),z},set:(L)=>{if(Object.is(z,L))return;if(z=L,j(B),J===z)B.length=0},update:(L)=>{$.set(L(z))},map:(L)=>A(L,$),match:(L)=>{return O(L,$),$}};return $},E=(x)=>M(x,b);var J=Symbol(),h=(x)=>E(x)||U(x),o=(x)=>q(x)&&!x.length||typeof x==="object"&&x!==null&&("ok"in x)&&q(x.ok),t=(x)=>h(x)?x:o(x)?A(x):k(x),_=(x,B)=>{let{ok:z,nil:$,err:L}=q(B)?{ok:B}:B,Q=[],G=[],W=!1;for(let K=0;K<x.length;K++){let Y=x[K];try{let X=Y.get();if(X===J)W=!0;Q[K]=X}catch(X){G.push(V(X))}}let H=void 0;try{if(W&&$)H=$();else if(G.length)H=L?L(...G):G[0];else if(!W)H=z(...Q)}catch(K){if(H=V(K),L)H=L(H)}return H};export{C as watch,t as toSignal,k as state,E as isState,h as isSignal,o as isComputedCallbacks,U as isComputed,i as enqueue,O as effect,A as computed,n as batch,J as UNSET};
