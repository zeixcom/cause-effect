function n($){return typeof $==="string"}function m$($){return typeof $==="number"}function N$($){return typeof $==="symbol"}function f($){return typeof $==="function"}function v($){return f($)&&$.constructor.name==="AsyncFunction"}function x$($){return f($)&&$.constructor.name!=="AsyncFunction"}function f$($){return $!=null&&typeof $==="object"}function A($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function w($){return A($,"Object")}function D$($){return w($)||Array.isArray($)}function V$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function k$($){return $ instanceof DOMException&&$.name==="AbortError"}function G$($){return n($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class a extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class L$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class c extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class e extends TypeError{constructor($,J){super(`[${$}] Signal value ${G$(J)} is invalid`);this.name="InvalidSignalValueError"}}class O$ extends TypeError{constructor($,J){super(`[${$}] Callback ${G$(J)} is invalid`);this.name="InvalidCallbackError"}}class K$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class o extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function R($,J,z){if(J==null)throw new L$($);if(z&&!z(J))throw new e($,J)}function $$($,J){if(J==null)throw new c($)}function O($,J,z=f){if(!z(J))throw new O$($,J)}var h="State",p="Memo",y="Task",g="Sensor",b="List",S="Collection",k="Store",L=0,R$=1,D=2,Z$=4,j=null,E=null,P$=[],C=0,b$=!1;function u($,J){return $===J}var v$=()=>!1;function c$($,J){let z=J.sourcesTail;if(z){let Q=J.sources;while(Q){if(Q===$)return!0;if(Q===z)break;Q=Q.nextSource}}return!1}function F($,J){let z=J.sourcesTail;if(z?.source===$)return;let Q=null,U=J.flags&Z$;if(U){if(Q=z?z.nextSource:J.sources,Q?.source===$){J.sourcesTail=Q;return}}let B=$.sinksTail;if(B?.sink===J&&(!U||c$(B,J)))return;let M={source:$,sink:J,nextSource:Q,prevSink:B,nextSink:null};if(J.sourcesTail=$.sinksTail=M,z)z.nextSource=M;else J.sources=M;if(B)B.nextSink=M;else $.sinks=M}function u$($){let{source:J,nextSource:z,nextSink:Q,prevSink:U}=$;if(Q)Q.prevSink=U;else J.sinksTail=U;if(U)U.nextSink=Q;else J.sinks=Q;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function H$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=u$(z);if(J)J.nextSource=null;else $.sources=null}function Y($,J=D){let z=$.flags;if("sinks"in $){if((z&(D|R$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)Y(Q.sink,R$)}else{if(z&D)return;$.flags=D,P$.push($)}}function W$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)Y(z.sink);if(C===0)V()}function l($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function F$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function d$($){let J=j;j=$,$.sourcesTail=null,$.flags=Z$;let z=!1;try{let Q=$.fn($.value);if($.error||!$.equals(Q,$.value))$.value=Q,$.error=void 0,z=!0}catch(Q){z=!0,$.error=Q instanceof Error?Q:Error(String(Q))}finally{j=J,H$($)}if(z){for(let Q=$.sinks;Q;Q=Q.nextSink)if(Q.sink.flags&R$)Q.sink.flags|=D}$.flags=L}function r$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=j;j=$,$.sourcesTail=null,$.flags=Z$;let Q;try{Q=$.fn($.value,J.signal)}catch(U){$.controller=void 0,$.error=U instanceof Error?U:Error(String(U));return}finally{j=z,H$($)}Q.then((U)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(U,$.value)){$.value=U,$.error=void 0;for(let B=$.sinks;B;B=B.nextSink)Y(B.sink);if(C===0)V()}},(U)=>{if(J.signal.aborted)return;$.controller=void 0;let B=U instanceof Error?U:Error(String(U));if(!$.error||B.name!==$.error.name||B.message!==$.error.message){$.error=B;for(let M=$.sinks;M;M=M.nextSink)Y(M.sink);if(C===0)V()}}),$.flags=L}function _$($){F$($);let J=j,z=E;j=E=$,$.sourcesTail=null,$.flags=Z$;try{let Q=$.fn();if(typeof Q==="function")l($,Q)}finally{j=J,E=z,H$($)}$.flags=L}function _($){if($.flags&R$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)_(J.source);if($.flags&D)break}if($.flags&Z$)throw new a("controller"in $?y:("value"in $)?p:"Effect");if($.flags&D)if("controller"in $)r$($);else if("value"in $)d$($);else _$($);else $.flags=L}function V(){if(b$)return;b$=!0;try{for(let $=0;$<P$.length;$++){let J=P$[$];if(J.flags&D)_(J)}P$.length=0}finally{b$=!1}}function i($){C++;try{$()}finally{if(C--,C===0)V()}}function d($){let J=j;j=null;try{return $()}finally{j=J}}function t$($){let J=E,z={cleanup:null};E=z;try{let Q=$();if(typeof Q==="function")l(z,Q);let U=()=>F$(z);if(J)l(J,U);return U}finally{E=J}}function T($,J){R(h,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard};return{[Symbol.toStringTag]:h,get(){if(j)F(z,j);return z.value},set(Q){R(h,Q,z.guard),W$(z,Q)},update(Q){O(h,Q);let U=Q(z.value);R(h,U,z.guard),W$(z,U)}}}function B$($){return A($,h)}function U$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function r($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!f$($)||!f$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new a("isEqual");z.add($),z.add(J);try{let Q=Array.isArray($);if(Q!==Array.isArray(J))return!1;if(Q){let U=$,B=J;if(U.length!==B.length)return!1;for(let M=0;M<U.length;M++)if(!r(U[M],B[M],z))return!1;return!0}if(w($)&&w(J)){let U=Object.keys($),B=Object.keys(J);if(U.length!==B.length)return!1;for(let M of U){if(!(M in J))return!1;if(!r($[M],J[M],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function s$($,J,z,Q,U){let B=new WeakSet,M={},K={},W={},Z=[],H=!1,m=new Map;for(let G=0;G<$.length;G++){let X=z[G];if(X&&$[G])m.set(X,$[G])}let P=new Set;for(let G=0;G<J.length;G++){let X=J[G];if(X===void 0)continue;let q=U?Q(X):z[G]??Q(X);if(P.has(q))throw new o(b,q,X);if(Z.push(q),P.add(q),!m.has(q))M[q]=X,H=!0;else{let N=m.get(q);if(!r(N,X,B))K[q]=X,H=!0}}for(let[G]of m)if(!P.has(G))W[G]=null,H=!0;if(!H&&!U$(z,Z))H=!0;return{add:M,change:K,remove:W,newKeys:Z,changed:H}}function J$($,J){R(b,$,Array.isArray);let z=new Map,Q=[],U=0,B=J?.keyConfig,M=f(B),K=n(B)?()=>`${B}${U++}`:M?(X)=>B(X):()=>String(U++),W=()=>Q.map((X)=>z.get(X)?.get()).filter((X)=>X!==void 0),Z={fn:W,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:r,error:void 0},H=(X)=>{let q={};for(let N=0;N<X.length;N++){let x=X[N];if(x===void 0)continue;let I=Q[N];if(!I)I=K(x),Q[N]=I;q[I]=x}return q},m=(X)=>{let q=!1;for(let N in X.add){let x=X.add[N];R(`${b} item for key "${N}"`,x),z.set(N,T(x)),q=!0}if(Object.keys(X.change).length)i(()=>{for(let N in X.change){let x=X.change[N];R(`${b} item for key "${N}"`,x);let I=z.get(N);if(I)I.set(x)}});for(let N in X.remove){z.delete(N);let x=Q.indexOf(N);if(x!==-1)Q.splice(x,1);q=!0}if(q)Z.sources=null,Z.sourcesTail=null;return X.changed},P=H($);for(let X in P){let q=P[X];R(`${b} item for key "${X}"`,q),z.set(X,T(q))}Z.value=$,Z.flags=0;let G={[Symbol.toStringTag]:b,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of Q){let q=z.get(X);if(q)yield q}},get length(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();F(Z,j)}return Q.length},get(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();F(Z,j)}if(Z.sources){if(Z.flags)Z.value=d(W),Z.flags=L}else if(_(Z),Z.error)throw Z.error;return Z.value},set(X){let q=Z.flags&D?W():Z.value,N=s$(q,X,Q,K,M);if(N.changed){if(Q=N.newKeys,m(N),Y(Z),Z.flags|=D,C===0)V()}},update(X){G.set(X(G.get()))},at(X){return z.get(Q[X])},keys(){if(j){if(!Z.sinks&&J?.watched)Z.stop=J.watched();F(Z,j)}return Q.values()},byKey(X){return z.get(X)},keyAt(X){return Q[X]},indexOfKey(X){return Q.indexOf(X)},add(X){let q=K(X);if(z.has(q))throw new o(b,q,X);if(!Q.includes(q))Q.push(q);if(R(`${b} item for key "${q}"`,X),z.set(q,T(X)),Z.sources=null,Z.sourcesTail=null,Y(Z),Z.flags|=D,C===0)V();return q},remove(X){let q=m$(X)?Q[X]:X;if(z.delete(q)){let x=m$(X)?X:Q.indexOf(q);if(x>=0)Q.splice(x,1);if(Z.sources=null,Z.sourcesTail=null,Y(Z),Z.flags|=D,C===0)V()}},sort(X){let N=Q.map((x)=>[x,z.get(x)?.get()]).sort(f(X)?(x,I)=>X(x[1],I[1]):(x,I)=>String(x[1]).localeCompare(String(I[1]))).map(([x])=>x);if(!U$(Q,N)){if(Q=N,Y(Z),Z.flags|=D,C===0)V()}},splice(X,q,...N){let x=Q.length,I=X<0?Math.max(0,x+X):Math.min(X,x),S$=Math.max(0,Math.min(q??Math.max(0,x-Math.max(0,I)),x-I)),A$={},X$={};for(let t=0;t<S$;t++){let s=I+t,Y$=Q[s];if(Y$){let p$=z.get(Y$);if(p$)X$[Y$]=p$.get()}}let C$=Q.slice(0,I);for(let t of N){let s=K(t);if(z.has(s)&&!(s in X$))throw new o(b,s,t);C$.push(s),A$[s]=t}C$.push(...Q.slice(I+S$));let h$=!!(Object.keys(A$).length||Object.keys(X$).length);if(h$){if(m({add:A$,change:{},remove:X$,changed:h$}),Q=C$,Y(Z),Z.flags|=D,C===0)V()}return Object.values(X$)},deriveCollection(X){return q$(G,X)}};return G}function M$($){return A($,b)}function z$($,J){if(O(p,$,x$),J?.value!==void 0)R(p,J.value,J?.guard);let z={fn:$,value:J?.value,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??u,error:void 0};return{[Symbol.toStringTag]:p,get(){if(j)F(z,j);if(_(z),z.error)throw z.error;return $$(p,z.value),z.value}}}function w$($){return A($,p)}function Q$($,J){if(O(y,$,v),J?.value!==void 0)R(y,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:D,equals:J?.equals??u,controller:void 0,error:void 0};return{[Symbol.toStringTag]:y,get(){if(j)F(z,j);if(_(z),z.error)throw z.error;return $$(y,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function T$($){return A($,y)}function q$($,J){if(O(S,J),!l$($))throw TypeError(`[${S}] Invalid collection source: expected a List or Collection`);let z=v(J),Q=new Map,U=(H)=>{let m=z?Q$(async(P,G)=>{let X=$.byKey(H)?.get();if(X==null)return P;return J(X,G)}):z$(()=>{let P=$.byKey(H)?.get();if(P==null)return;return J(P)});Q.set(H,m)};function B(){let H=Array.from($.keys()),m=M.value;if(!U$(m,H)){let P=new Set(m),G=new Set(H);for(let X of m)if(!G.has(X))Q.delete(X);for(let X of H)if(!P.has(X))U(X)}return H}let M={fn:B,value:[],flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:U$,error:void 0};function K(){if(M.sources){if(M.flags)M.value=d(B),M.flags=L}else if(_(M),M.error)throw M.error;return M.value}let W=Array.from($.keys());for(let H of W)U(H);M.value=W;let Z={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of M.value){let m=Q.get(H);if(m)yield m}},get length(){if(j)F(M,j);return K().length},keys(){if(j)F(M,j);return K().values()},get(){if(j)F(M,j);let H=K(),m=[];for(let P of H)try{let G=Q.get(P)?.get();if(G!=null)m.push(G)}catch(G){if(!(G instanceof c))throw G}return m},at(H){return Q.get(M.value[H])},byKey(H){return Q.get(H)},keyAt(H){return M.value[H]},indexOfKey(H){return M.value.indexOf(H)},deriveCollection(H){return q$(Z,H)}};return Z}function o$($,J,z){R(S,$,Array.isArray),O(S,J);let Q=new Map,U=[],B=0,M=z?.keyConfig,K=n(M)?()=>`${M}${B++}`:f(M)?(X)=>M(X):()=>String(B++),W=z?.createItem??((X,q)=>T(q));function Z(){let X=[];for(let q of U)try{let N=Q.get(q)?.get();if(N!=null)X.push(N)}catch(N){if(!(N instanceof c))throw N}return X}let H={fn:Z,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:()=>!1,error:void 0};function m(X){if(!X.changed)return;let q=!1;i(()=>{for(let N in X.add){let x=X.add[N];if(Q.set(N,W(N,x)),!U.includes(N))U.push(N);q=!0}for(let N in X.change){let x=Q.get(N);if(x&&B$(x))x.set(X.change[N])}for(let N in X.remove){Q.delete(N);let x=U.indexOf(N);if(x!==-1)U.splice(x,1);q=!0}if(q)H.sources=null,H.sourcesTail=null;H.flags=L,Y(H),H.flags|=D})}for(let X of $){let q=K(X);Q.set(q,W(q,X)),U.push(q)}H.value=$,H.flags=D;function P(){if(!H.sinks)H.stop=J(m)}let G={[Symbol.toStringTag]:S,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let X of U){let q=Q.get(X);if(q)yield q}},get length(){if(j)P(),F(H,j);return U.length},keys(){if(j)P(),F(H,j);return U.values()},get(){if(j)P(),F(H,j);if(H.sources){if(H.flags)H.value=d(Z),H.flags=L}else if(_(H),H.error)throw H.error;return H.value},at(X){return Q.get(U[X])},byKey(X){return Q.get(X)},keyAt(X){return U[X]},indexOfKey(X){return U.indexOf(X)},deriveCollection(X){return q$(G,X)}};return G}function y$($){return A($,S)}function l$($){return M$($)||y$($)}function i$($){O("Effect",$);let J={fn:$,flags:D,sources:null,sourcesTail:null,cleanup:null},z=()=>{F$(J),J.fn=void 0,J.flags=L,J.sourcesTail=null,H$(J)};if(E)l(E,z);return _$(J),z}function n$($,J){if(!E)throw new K$("match");let{ok:z,err:Q=console.error,nil:U}=J,B,M=!1,K=Array($.length);for(let Z=0;Z<$.length;Z++)try{K[Z]=$[Z].get()}catch(H){if(H instanceof c){M=!0;continue}if(!B)B=[];B.push(H instanceof Error?H:Error(String(H)))}let W;try{if(M)W=U?.();else if(B)W=Q(B);else W=z(K)}catch(Z){Q([Z instanceof Error?Z:Error(String(Z))])}if(typeof W==="function")return W;if(W instanceof Promise){let Z=E,H=new AbortController;l(Z,()=>H.abort()),W.then((m)=>{if(!H.signal.aborted&&typeof m==="function")l(Z,m)}).catch((m)=>{Q([m instanceof Error?m:Error(String(m))])})}}function a$($,J){if(O(g,$,x$),J?.value!==void 0)R(g,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??u,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:g,get(){if(j){if(!z.sinks)z.stop=$((Q)=>{R(g,Q,z.guard),W$(z,Q)});F(z,j)}return $$(g,z.value),z.value}}}function e$($){return A($,g)}function $J($,J){let z=D$($),Q=D$(J);if(!z||!Q){let m=!Object.is($,J);return{changed:m,add:m&&Q?J:{},change:{},remove:m&&z?$:{}}}let U=new WeakSet,B={},M={},K={},W=!1,Z=Object.keys($),H=Object.keys(J);for(let m of H)if(m in $){if(!r($[m],J[m],U))M[m]=J[m],W=!0}else B[m]=J[m],W=!0;for(let m of Z)if(!(m in J))K[m]=void 0,W=!0;return{add:B,change:M,remove:K,changed:W}}function j$($,J){R(k,$,w);let z=new Map,Q=(W,Z)=>{if(R(`${k} for key "${W}"`,Z),Array.isArray(Z))z.set(W,J$(Z));else if(w(Z))z.set(W,j$(Z));else z.set(W,T(Z))},U=()=>{let W={};return z.forEach((Z,H)=>{W[H]=Z.get()}),W},B={fn:U,value:$,flags:D,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:r,error:void 0},M=(W)=>{let Z=!1;for(let H in W.add)Q(H,W.add[H]),Z=!0;if(Object.keys(W.change).length)i(()=>{for(let H in W.change){let m=W.change[H];R(`${k} for key "${H}"`,m);let P=z.get(H);if(P)if(w(m)!==I$(P))Q(H,m),Z=!0;else P.set(m)}});for(let H in W.remove)z.delete(H),Z=!0;if(Z)B.sources=null,B.sourcesTail=null;return W.changed};for(let W of Object.keys($))Q(W,$[W]);let K={[Symbol.toStringTag]:k,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let Z=z.get(W);if(Z)yield[W,Z]}},keys(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();F(B,j)}return z.keys()},byKey(W){return z.get(W)},get(){if(j){if(!B.sinks&&J?.watched)B.stop=J.watched();F(B,j)}if(B.sources){if(B.flags)B.value=d(U),B.flags=L}else if(_(B),B.error)throw B.error;return B.value},set(W){let Z=B.flags&D?U():B.value,H=$J(Z,W);if(M(H)){if(Y(B),B.flags|=D,C===0)V()}},update(W){K.set(W(K.get()))},add(W,Z){if(z.has(W))throw new o(k,W,Z);if(Q(W,Z),B.sources=null,B.sourcesTail=null,Y(B),B.flags|=D,C===0)V();return W},remove(W){if(z.delete(W)){if(B.sources=null,B.sourcesTail=null,Y(B),B.flags|=D,C===0)V()}}};return new Proxy(K,{get(W,Z){if(Z in W){let H=Reflect.get(W,Z);return f(H)?H.bind(W):H}if(!N$(Z))return W.byKey(Z)},has(W,Z){if(Z in W)return!0;return W.byKey(String(Z))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Z){if(Z in W)return Reflect.getOwnPropertyDescriptor(W,Z);if(N$(Z))return;let H=W.byKey(String(Z));return H?{enumerable:!0,configurable:!0,writable:!0,value:H}:void 0}})}function I$($){return A($,k)}function JJ($,J){return v($)?Q$($,J):z$($,J)}function zJ($){if(E$($))return $;if($==null)throw new e("createSignal",$);if(v($))return Q$($);if(f($))return z$($);if(V$($))return J$($);if(w($))return j$($);return T($)}function QJ($){if(g$($))return $;if($==null||f($)||E$($))throw new e("createMutableSignal",$);if(V$($))return J$($);if(w($))return j$($);return T($)}function XJ($){return w$($)||T$($)}function E$($){let J=[h,p,y,g,b,S,k],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function g$($){return B$($)||I$($)||M$($)}export{G$ as valueString,d as untrack,n$ as match,T$ as isTask,N$ as isSymbol,n as isString,I$ as isStore,B$ as isState,E$ as isSignal,e$ as isSensor,D$ as isRecordOrArray,w as isRecord,A as isObjectOfType,m$ as isNumber,g$ as isMutableSignal,w$ as isMemo,M$ as isList,f as isFunction,r as isEqual,XJ as isComputed,y$ as isCollection,v as isAsyncFunction,k$ as isAbortError,Q$ as createTask,j$ as createStore,T as createState,o$ as createSourceCollection,zJ as createSignal,a$ as createSensor,t$ as createScope,QJ as createMutableSignal,z$ as createMemo,J$ as createList,i$ as createEffect,JJ as createComputed,q$ as createCollection,i as batch,c as UnsetSignalValueError,v$ as SKIP_EQUALITY,K$ as RequiredOwnerError,L$ as NullishSignalValueError,e as InvalidSignalValueError,O$ as InvalidCallbackError,a as CircularDependencyError};
