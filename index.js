var F=Symbol(),G$=($)=>typeof $==="string",e=($)=>typeof $==="number",E=($)=>typeof $==="symbol",P=($)=>typeof $==="function",g=($)=>P($)&&$.constructor.name==="AsyncFunction";var S=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,m=($)=>S($,"Object"),Q$=($)=>m($)||Array.isArray($);var c=($)=>$ instanceof DOMException&&$.name==="AbortError",b=($)=>$ instanceof Error?$:Error(String($)),n=($)=>G$($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);class p extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class s extends Error{constructor($,B,z){super(`Could not add ${$} key "${B}"${z?` with value ${n(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class f$ extends Error{constructor($,B,z){super(`Forbidden method call ${$} in ${B} because ${z}`);this.name="ForbiddenMethodCallError"}}class h extends TypeError{constructor($,B){super(`Invalid ${$} callback ${n(B)}`);this.name="InvalidCallbackError"}}class t extends TypeError{constructor($,B){super(`Invalid signal value ${n(B)} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class i extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreIndexRangeError"}}class l extends Error{constructor($,B){super(`Could not set store key "${$}" to ${n(B)} because it is read-only`);this.name="StoreKeyReadonlyError"}}var v=($,B,z)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(B))throw new p("isEqual");z.add($),z.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let Q=0;Q<$.length;Q++)if(!v($[Q],B[Q],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(m($)&&m(B)){let Q=Object.keys($),q=Object.keys(B);if(Q.length!==q.length)return!1;for(let Z of Q){if(!(Z in B))return!1;if(!v($[Z],B[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(B)}},$$=($,B)=>{let z=Q$($),Q=Q$(B);if(!z||!Q){let U=!Object.is($,B);return{changed:U,add:U&&Q?B:{},change:{},remove:U&&z?$:{}}}let q=new WeakSet,Z={},K={},D={},C=Object.keys($),j=Object.keys(B),O=new Set([...C,...j]);for(let U of O){let X=U in $,Y=U in B;if(!X&&Y){Z[U]=B[U];continue}else if(X&&!Y){D[U]=F;continue}let A=$[U],J=B[U];if(!v(A,J,q))K[U]=J}return{add:Z,change:K,remove:D,changed:!!(Object.keys(Z).length||Object.keys(K).length||Object.keys(D).length)}};var r,X$=new Set,U$=0,V=($)=>{let B=new Set,z=$;return z.unwatch=(Q)=>{B.add(Q)},z.cleanup=()=>{for(let Q of B)Q();B.clear()},z},T=($)=>{if(r&&!$.has(r)){let B=r;B.unwatch(()=>{$.delete(B)}),$.add(B)}},N=($)=>{for(let B of $)if(U$)X$.add(B);else B()},Z$=()=>{while(X$.size){let $=Array.from(X$);X$.clear();for(let B of $)B()}},A$=($)=>{U$++;try{$()}finally{Z$(),U$--}},w=($,B)=>{let z=r;r=B;try{$()}finally{r=z}},W=($,B)=>{for(let z of $)z(B)};var S$=($)=>{if(!P($)||$.length>1)throw new h("effect",$);let B=g($),z=!1,Q,q=V(()=>w(()=>{if(z)throw new p("effect");z=!0,Q?.abort(),Q=void 0;let Z;try{if(B){Q=new AbortController;let K=Q;$(Q.signal).then((D)=>{if(P(D)&&Q===K)q.unwatch(D)}).catch((D)=>{if(!c(D))console.error("Async effect error:",D)})}else if(Z=$(),P(Z))q.unwatch(Z)}catch(K){if(!c(K))console.error("Effect callback error:",K)}z=!1},q));return q(),()=>{Q?.abort(),q.cleanup()}};function H$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(z){if(B.err&&(!$.errors||!$.errors.includes(b(z))))B.err($.errors?[...$.errors,b(z)]:[b(z)]);else throw z}}function q$($){let B=[],z=!1,Q={};for(let[q,Z]of Object.entries($))try{let K=Z.get();if(K===F)z=!0;else Q[q]=K}catch(K){B.push(b(K))}if(z)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:Q}}var _$="Computed",M$=($,B=F)=>{if(!D$($))throw new h("computed",$);if(B==null)throw new f("computed");let z=new Set,Q=B,q,Z,K=!0,D=!1,C=!1,j=(H)=>{if(!v(H,Q))Q=H,D=!0;q=void 0,K=!1},O=()=>{D=F!==Q,Q=F,q=void 0},U=(H)=>{let R=b(H);D=!q||R.name!==q.name||R.message!==q.message,Q=F,q=R},X=(H)=>(R)=>{if(C=!1,Z=void 0,H(R),D)N(z)},Y=V(()=>{if(K=!0,Z?.abort(),z.size)N(z);else Y.cleanup()});Y.unwatch(()=>{Z?.abort()});let A=()=>w(()=>{if(C)throw new p("computed");if(D=!1,g($)){if(Z)return Q;Z=new AbortController,Z.signal.addEventListener("abort",()=>{C=!1,Z=void 0,A()},{once:!0})}let H;C=!0;try{H=Z?$(Q,Z.signal):$(Q)}catch(R){if(c(R))O();else U(R);C=!1;return}if(H instanceof Promise)H.then(X(j),X(U));else if(H==null||F===H)O();else j(H);C=!1},Y),J={};return Object.defineProperties(J,{[Symbol.toStringTag]:{value:_$},get:{value:()=>{if(T(z),Z$(),K)A();if(q)throw q;return Q}}}),J},y=($)=>S($,_$),D$=($)=>P($)&&$.length<3;var W$="Collection",N$=($,B)=>{let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},q=new Map,Z=new Map,K=[],D=(X)=>{let Y=g(B)?async(H,R)=>{let I=$.byKey(X);if(!I)return F;let M=F;return H$(q$({originSignal:I}),{ok:async({originSignal:G})=>{M=await B(G,R)},err:(G)=>{console.log(G)}}),M}:()=>{let H=$.byKey(X);if(!H)return F;let R=F;return H$(q$({originSignal:H}),{ok:({originSignal:I})=>{R=B(I)},err:(I)=>{console.log(I)}}),R},A=M$(Y);if(q.set(X,A),!K.includes(X))K.push(X);let J=V(()=>w(()=>{A.get(),W(Q.change,[X])},J));return J(),Z.set(X,J),!0},C=(X)=>{if(!q.delete(X))return;let A=K.indexOf(X);if(A>=0)K.splice(A,1);let J=Z.get(X);if(J)J.cleanup();Z.delete(X)};for(let X=0;X<$.length;X++){let Y=$.keyAt(X);if(!Y)continue;D(Y)}$.on("add",(X)=>{for(let Y of X)if(!q.has(Y))D(Y);N(z),W(Q.add,X)}),$.on("remove",(X)=>{for(let Y of Object.keys(X)){if(!q.has(Y))continue;C(Y)}K=K.filter(()=>!0),N(z),W(Q.remove,X)}),$.on("sort",(X)=>{K=[...X],N(z),W(Q.sort,X)});let j=(X)=>{let Y=X,A=Number(X);if(Number.isInteger(A)&&A>=0)Y=K[A]??X;return q.get(Y)},O=()=>K.map((X)=>q.get(X)?.get()).filter((X)=>X!==F),U={};return Object.defineProperties(U,{[Symbol.toStringTag]:{value:W$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let X of K){let Y=q.get(X);if(Y)yield Y}}},byKey:{value(X){return j(X)}},keyAt:{value(X){return K[X]}},indexOfKey:{value(X){return K.indexOf(X)}},get:{value:()=>{return T(z),O()}},sort:{value:(X)=>{K=K.map((A,J)=>{let H=q.get(A);return[J,A,H?H.get():void 0]}).sort(X?(A,J)=>X(A[2],J[2]):(A,J)=>String(A[2]).localeCompare(String(J[2]))).map(([A,J])=>J),N(z),W(Q.sort,K)}},on:{value:(X,Y)=>{return Q[X].add(Y),()=>Q[X].delete(Y)}},length:{get(){return T(z),q.size}}}),new Proxy(U,{get(X,Y){if(Y in X)return Reflect.get(X,Y);if(!E(Y))return j(Y)},has(X,Y){if(Y in X)return!0;return q.has(String(Y))},ownKeys(X){let Y=Reflect.ownKeys(X);return[...new Set([...K,...Y])]},getOwnPropertyDescriptor(X,Y){if(Y in X)return Reflect.getOwnPropertyDescriptor(X,Y);if(E(Y))return;let A=j(Y);return A?{enumerable:!0,configurable:!0,writable:!0,value:A}:void 0}})},O$=($)=>S($,W$);var x$="State",d=($)=>{if($==null)throw new f("state");let B=new Set,z=$,Q=(Z)=>{if(Z==null)throw new f("state");if(v(z,Z))return;if(z=Z,N(B),F===z)B.clear()},q={};return Object.defineProperties(q,{[Symbol.toStringTag]:{value:x$},get:{value:()=>{return T(B),z}},set:{value:(Z)=>{Q(Z)}},update:{value:(Z)=>{if(!P(Z))throw new h("state update",Z);Q(Z(z))}}}),q},k=($)=>S($,x$);var I$="Store",a=($)=>{if($==null)throw new f("store");let B=new Set,z={add:new Set,change:new Set,remove:new Set,sort:new Set},Q=new Map,q=new Map,Z=[],K=()=>{let A={};for(let J of Z){let H=Q.get(J);if(H)A[J]=H.get()}return A},D=(A,J)=>{if(J==null)throw new f(`store for key "${A}"`);if(J===F)return!0;if(E(J)||P(J)||y(J))throw new t(`store for key "${A}"`,J);return!0},C=(A,J,H=!1)=>{if(!D(A,J))return!1;let R=k(J)||u(J)?J:m(J)||Array.isArray(J)?a(J):d(J);if(Q.set(A,R),!Z.includes(A))Z.push(A);let I=V(()=>w(()=>{R.get(),W(z.change,[A])},I));if(I(),q.set(A,I),H)N(B),W(z.add,[A]);return!0},j=(A,J=!1)=>{if(!Q.delete(A))return;let R=Z.indexOf(A);if(R>=0)Z.splice(R,1);let I=q.get(A);if(I)I.cleanup();if(q.delete(A),J)Z=Z.filter(()=>!0),N(B),W(z.remove,[A])},O=(A,J)=>{if(Object.keys(A.add).length){for(let H in A.add)C(H,A.add[H],!1);if(J)setTimeout(()=>{W(z.add,Object.keys(A.add))},0);else W(z.add,Object.keys(A.add))}if(Object.keys(A.change).length)A$(()=>{for(let H in A.change){let R=A.change[H];if(!D(H,R))continue;let I=Q.get(H);if(B$(I))I.set(R);else throw new l(H,R)}W(z.change,Object.keys(A.change))});if(Object.keys(A.remove).length){for(let H in A.remove)j(H);Z=Z.filter(()=>!0),W(z.remove,Object.keys(A.remove))}return A.changed},U=(A,J,H)=>O($$(A,J),H);U({},$,!0);let X={};return Object.defineProperties(X,{[Symbol.toStringTag]:{value:I$},[Symbol.iterator]:{value:function*(){for(let A of Z){let J=Q.get(A);if(J)yield[A,J]}}},add:{value:(A,J)=>{if(!Q.has(A))return C(A,J,!0),A;else throw new s("store",A,J)}},byKey:{value:(A)=>{return Q.get(A)}},keyAt:{value(A){return Z[A]}},indexOfKey:{value(A){return Z.indexOf(A)}},get:{value:()=>{return T(B),K()}},remove:{value:(A)=>{let J=String(A);if(e(A)){if(!Z[A])throw new i(A);J=Z[A]}if(Q.has(J))j(J,!0)}},set:{value:(A)=>{if(U(K(),A)){if(N(B),F===A)B.clear()}}},update:{value:(A)=>{let J=K(),H=A(J);if(U(J,H)){if(N(B),F===H)B.clear()}}},sort:{value:(A)=>{Z=Z.map((H,R)=>{let I=Q.get(H);return[R,H,I?I.get():void 0]}).sort(A?(H,R)=>A(H[2],R[2]):(H,R)=>String(H[2]).localeCompare(String(R[2]))).map(([H,R])=>R),N(B),W(z.sort,Z)}},on:{value:(A,J)=>{return z[A].add(J),()=>z[A].delete(J)}},length:{get(){return T(B),Q.size}}}),new Proxy(X,{get(A,J){if(J in A)return Reflect.get(A,J);if(!E(J))return Q.get(J)},has(A,J){if(J in A)return!0;return Q.has(String(J))},ownKeys(A){let J=Reflect.ownKeys(A);return[...new Set([...Z,...J])]},getOwnPropertyDescriptor(A,J){if(J in A)return Reflect.getOwnPropertyDescriptor(A,J);if(E(J))return;let H=Q.get(J);return H?{enumerable:!0,configurable:!0,writable:!0,value:H}:void 0}})},u=($)=>S($,I$);var C$="List",Y$=($,B)=>{if($==null)throw new f("store");let z=new Set,Q={add:new Set,change:new Set,remove:new Set,sort:new Set},q=new Map,Z=new Map,K=0,D=[],C=(M)=>{let G=M,L=Number(M);if(Number.isInteger(L)&&L>=0)G=D[L]??M;return q.get(G)},j=(M)=>{let G=K++;return G$(B)?`${B}${G}`:P(B)?B(M):String(G)},O=(M)=>{let G={};for(let L=0;L<M.length;L++){let _=M[L];if(_===void 0)continue;let x=D[L];if(!x)x=j(_),D[L]=x;G[x]=_}return G},U=()=>D.map((M)=>q.get(M)?.get()).filter((M)=>M!==void 0),X=(M,G)=>{if(G==null)throw new f(`store for key "${M}"`);if(G===F)return!0;if(E(G)||P(G)||y(G))throw new t(`store for key "${M}"`,G);return!0},Y=(M,G,L=!1)=>{if(!X(M,G))return!1;let _=k(G)||u(G)||K$(G)?G:m(G)?a(G):Array.isArray(G)?Y$(G):d(G);if(q.set(M,_),!D.includes(M))D.push(M);let x=V(()=>w(()=>{_.get(),W(Q.change,[M])},x));if(x(),Z.set(M,x),L)N(z),W(Q.add,[M]);return!0},A=(M,G=!1)=>{if(!q.delete(M))return;let _=D.indexOf(M);if(_>=0)D.splice(_,1);let x=Z.get(M);if(x)x.cleanup();if(Z.delete(M),G)D=D.filter(()=>!0),N(z),W(Q.remove,[M])},J=(M,G)=>{if(Object.keys(M.add).length){for(let L in M.add)Y(L,M.add[L],!1);if(G)setTimeout(()=>{W(Q.add,Object.keys(M.add))},0);else W(Q.add,Object.keys(M.add))}if(Object.keys(M.change).length)A$(()=>{for(let L in M.change){let _=M.change[L];if(!X(L,_))continue;let x=q.get(L);if(B$(x))x.set(_);else throw new l(L,_)}W(Q.change,Object.keys(M.change))});if(Object.keys(M.remove).length){for(let L in M.remove)A(L);D=D.filter(()=>!0),W(Q.remove,Object.keys(M.remove))}return M.changed},H=(M,G,L)=>J($$(O(M),O(G)),L);H([],$,!0);let R={};Object.defineProperties(R,{[Symbol.toStringTag]:{value:C$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let M of D){let G=q.get(M);if(G)yield G}}},add:{value:(M)=>{let G=j(M);if(!q.has(G))return Y(G,M,!0),G;else throw new s("store",G,M)}},byKey:{value:(M)=>{return C(M)}},deriveCollection:{value:(M)=>{return N$(I,M)}},keyAt:{value(M){return D[M]}},indexOfKey:{value(M){return D.indexOf(M)}},get:{value:()=>{return T(z),U()}},remove:{value:(M)=>{let G=String(M);if(e(M)){if(!D[M])throw new i(M);G=D[M]}if(q.has(G))A(G,!0)}},set:{value:(M)=>{if(H(U(),M)){if(N(z),F===M)z.clear()}}},update:{value:(M)=>{let G=U(),L=M(G);if(H(G,L)){if(N(z),F===L)z.clear()}}},sort:{value:(M)=>{D=D.map((L,_)=>{let x=q.get(L);return[_,L,x?x.get():void 0]}).sort(M?(L,_)=>M(L[2],_[2]):(L,_)=>String(L[2]).localeCompare(String(_[2]))).map(([L,_])=>_),N(z),W(Q.sort,D)}},splice:{value:(M,G,...L)=>{let _=q.size,x=M<0?Math.max(0,_+M):Math.min(M,_),j$=Math.max(0,Math.min(G??Math.max(0,_-Math.max(0,x)),_-x)),L$={},J$={};for(let o=0;o<j$;o++){let z$=x+o,F$=D[z$];if(F$){let T$=q.get(F$);if(T$)J$[F$]=T$.get()}}let R$=D.slice(0,x);for(let o of L){let z$=j(o);R$.push(z$),L$[z$]=o}R$.push(...D.slice(x+j$)),D=R$.filter(()=>!0);let P$=!!(Object.keys(L$).length||Object.keys(J$).length);if(P$)J({add:L$,change:{},remove:J$,changed:P$});return N(z),Object.values(J$)}},on:{value:(M,G)=>{return Q[M].add(G),()=>Q[M].delete(G)}},length:{get(){return T(z),q.size}}});let I=new Proxy(R,{get(M,G){if(G in M)return Reflect.get(M,G);if(!E(G))return C(G)},has(M,G){if(G in M)return!0;return q.has(String(G))},ownKeys(M){let G=Reflect.ownKeys(M);return[...new Set([...D,...G])]},getOwnPropertyDescriptor(M,G){if(G in M)return Reflect.getOwnPropertyDescriptor(M,G);if(E(G))return;let L=C(G);return L?{enumerable:!0,configurable:!0,writable:!0,value:L}:void 0}});return I},K$=($)=>S($,C$);var E$=($)=>k($)||y($)||u($),B$=($)=>k($)||u($)||K$($);function m$($){if(E$($))return $;if(D$($))return M$($);if(Array.isArray($))return Y$($);if(m($))return a($);return d($)}export{n as valueString,m$ as toSignal,b as toError,T as subscribe,q$ as resolve,w as observe,N as notify,H$ as match,E as isSymbol,G$ as isString,u as isStore,k as isState,E$ as isSignal,Q$ as isRecordOrArray,m as isRecord,S as isObjectOfType,e as isNumber,B$ as isMutableSignal,K$ as isList,P as isFunction,v as isEqual,D$ as isComputedCallback,y as isComputed,O$ as isCollection,g as isAsyncFunction,c as isAbortError,Z$ as flush,W as emit,$$ as diff,V as createWatcher,a as createStore,d as createState,Y$ as createList,S$ as createEffect,M$ as createComputed,N$ as createCollection,A$ as batch,F as UNSET,I$ as TYPE_STORE,x$ as TYPE_STATE,C$ as TYPE_LIST,_$ as TYPE_COMPUTED,W$ as TYPE_COLLECTION,l as StoreKeyReadonlyError,i as StoreIndexRangeError,f as NullishSignalValueError,t as InvalidSignalValueError,h as InvalidCallbackError,f$ as ForbiddenMethodCallError,s as DuplicateKeyError,p as CircularDependencyError};
