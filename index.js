var X=(T)=>typeof T==="function",S=(T)=>X(T)&&/^async\s+/.test(T.toString()),F=(T)=>X(T)&&T.length<2,E=(T)=>(x)=>x instanceof T,C=E(Error),U=E(Promise),B=(T)=>C(T)?T:new Error(String(T));var p="Computed",G=(T,x)=>{x=x??S(T);let j=[],J=A,L=null,q=!0,V=()=>{if(q=!0,x)Q(j)},K={[Symbol.toStringTag]:p,get:()=>{if(x)Z(j);if(!x||q)$(()=>{let I=(y)=>{J=y,q=!1,L=null};try{let y=T(J);U(y)?y.then((z)=>{I(z),Q(j)}).catch((z)=>{L=B(z)}):I(y)}catch(y){L=B(y)}},V);if(C(L))throw L;return J},map:(I)=>G(()=>I(K.get()))};return K},N=(T)=>!!T&&typeof T==="object"&&T[Symbol.toStringTag]===p;var H,R=!1,Y=[],A=Symbol(),O=(T)=>P(T)||N(T),g=(T,x=!1)=>O(T)?T:F(T)?G(T,x):D(T),Z=(T)=>{if(H&&!T.includes(H))T.push(H)},Q=(T)=>T.forEach((x)=>R?Y.push(x):x()),$=(T,x)=>{let j=H;H=x,T(),H=j},w=(T)=>{R=!0,T(),R=!1,Y.forEach((x)=>x()),Y.length=0};class M{value;watchers=[];constructor(T){this.value=T}get(){return Z(this.watchers),this.value}set(T){if(Object.is(this.value,T))return;if(this.value=T,Q(this.watchers),A===T)this.watchers=[]}update(T){this.set(T(this.value))}map(T){return G(()=>T(this.get()))}}var D=(T)=>new M(T),P=(T)=>T instanceof M;function _(T,...x){let j=X(T)?{ok:T}:T,{ok:J,nil:L,err:q}=j,V=()=>$(()=>{let K=[],I=[],y=!1;for(let z of x)try{let W=z.get();if(W===A)y=!0;K.push(W)}catch(W){I.push(B(W))}try{if(!y&&!I.length)J(...K);else if(I.length&&q)q(...I);else if(y&&L)L()}catch(z){q?.(B(z))}},V);V()}export{g as toSignal,D as state,P as isState,O as isSignal,N as isComputed,_ as effect,G as computed,w as batch,A as UNSET,M as State};
