<<<<<<< Updated upstream
class L extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class c extends TypeError{constructor($,R){super(`Invalid signal value ${R} in ${$}`);this.name="InvalidSignalValueError"}}class f extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class v extends Error{constructor($,R){super(`Could not add store key "${$}" with value ${R} because it already exists`);this.name="StoreKeyExistsError"}}class n extends RangeError{constructor($){super(`Could not remove store index ${String($)} because it is out of range`);this.name="StoreKeyRangeError"}}class u extends Error{constructor($,R){super(`Could not set store key "${$}" to ${R} because it is readonly`);this.name="StoreKeyReadonlyError"}}var K=Symbol(),e=($)=>typeof $==="string",C$=($)=>typeof $==="number",y=($)=>typeof $==="symbol",Y=($)=>typeof $==="function",g=($)=>Y($)&&$.constructor.name==="AsyncFunction",V=($,R)=>Object.prototype.toString.call($)===`[object ${R}]`,T=($)=>V($,"Object"),t=($)=>T($)||Array.isArray($),I$=($)=>{if(!$.length)return null;let R=$.map((G)=>e(G)?parseInt(G,10):C$(G)?G:NaN);return R.every((G)=>Number.isFinite(G)&&G>=0)?R.sort((G,J)=>G-J):null};var O=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var s=($)=>{let R=I$(Object.keys($));if(R===null)return $;let G=[];for(let J of R)G.push($[String(J)]);return G},b=($)=>e($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var A=($,R,G)=>{if(Object.is($,R))return!0;if(typeof $!==typeof R)return!1;if(typeof $!=="object"||$===null||R===null)return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(R))throw new L("isEqual");G.add($),G.add(R);try{if(Array.isArray($)&&Array.isArray(R)){if($.length!==R.length)return!1;for(let J=0;J<$.length;J++)if(!A($[J],R[J],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(R))return!1;if(T($)&&T(R)){let J=Object.keys($),X=Object.keys(R);if(J.length!==X.length)return!1;for(let C of J){if(!(C in R))return!1;if(!A($[C],R[C],G))return!1}return!0}return!1}finally{G.delete($),G.delete(R)}},$$=($,R)=>{let G=t($),J=t(R);if(!G||!J){let I=!Object.is($,R);return{changed:I,add:I&&J?R:{},change:{},remove:I&&G?$:{}}}let X=new WeakSet,C={},W={},H={},D=Object.keys($),P=Object.keys(R),m=new Set([...D,...P]);for(let I of m){let z=I in $,F=I in R;if(!z&&F){C[I]=R[I];continue}else if(z&&!F){H[I]=K;continue}let B=$[I],x=R[I];if(!A(B,x,X))W[I]=x}return{changed:Object.keys(C).length>0||Object.keys(W).length>0||Object.keys(H).length>0,add:C,change:W,remove:H}};var S,i=new Set,R$=0,k=($)=>{let R=new Set,G=$;return G.off=(J)=>{R.add(J)},G.cleanup=()=>{for(let J of R)J();R.clear()},G},_=($)=>{if(S&&!$.has(S)){let R=S;$.add(R),S.off(()=>{$.delete(R)})}},N=($)=>{for(let R of $)if(R$)i.add(R);else R()},r=()=>{while(i.size){let $=Array.from(i);i.clear();for(let R of $)R()}},x$=($)=>{R$++;try{$()}finally{r(),R$--}},h=($,R)=>{let G=S;S=R;try{$()}finally{S=G}};var B$="Computed",J$=($)=>{let R=new Set,G=K,J,X,C=!0,W=!1,H=!1,D=(B)=>{if(!A(B,G))G=B,W=!0;J=void 0,C=!1},P=()=>{W=K!==G,G=K,J=void 0},m=(B)=>{let x=U(B);W=!J||x.name!==J.name||x.message!==J.message,G=K,J=x},j=(B)=>(x)=>{if(H=!1,X=void 0,B(x),W)N(R)},I=k(()=>{if(C=!0,X?.abort(),R.size)N(R);else I.cleanup()});I.off(()=>{X?.abort()});let z=()=>h(()=>{if(H)throw new L("computed");if(W=!1,g($)){if(X)return G;X=new AbortController,X.signal.addEventListener("abort",()=>{H=!1,X=void 0,z()},{once:!0})}let B;H=!0;try{B=X?$(X.signal):$()}catch(x){if(O(x))P();else m(x);H=!1;return}if(B instanceof Promise)B.then(j(D),j(m));else if(B==null||K===B)P();else D(B);H=!1},I);return{[Symbol.toStringTag]:B$,get:()=>{if(_(R),r(),C)z();if(J)throw J;return G}}},d=($)=>V($,B$),G$=($)=>Y($)&&$.length<2;var M$=($)=>{let R=g($),G=!1,J,X=k(()=>h(()=>{if(G)throw new L("effect");G=!0,J?.abort(),J=void 0;let C;try{if(R){J=new AbortController;let W=J;$(J.signal).then((H)=>{if(Y(H)&&J===W)X.off(H)}).catch((H)=>{if(!O(H))console.error("Async effect error:",H)})}else if(C=$(),Y(C))X.off(C)}catch(W){if(!O(W))console.error("Effect callback error:",W)}G=!1},X));return X(),()=>{J?.abort(),X.cleanup()}};function K$($,R){try{if($.pending)R.nil?.();else if($.errors)R.err?.($.errors);else if($.ok)R.ok($.values)}catch(G){if(R.err&&(!$.errors||!$.errors.includes(U(G))))R.err($.errors?[...$.errors,U(G)]:[U(G)]);else throw G}}function q$($){let R=[],G=!1,J={};for(let[X,C]of Object.entries($))try{let W=C.get();if(W===K)G=!0;else J[X]=W}catch(W){R.push(U(W))}if(G)return{ok:!1,pending:!0};if(R.length>0)return{ok:!1,errors:R};return{ok:!0,values:J}}var Q$="State",E=($)=>{let R=new Set,G=$,J={[Symbol.toStringTag]:Q$,get:()=>{return _(R),G},set:(X)=>{if(X==null)throw new f("state");if(A(G,X))return;if(G=X,N(R),K===G)R.clear()},update:(X)=>{J.set(X(G))}};return J},w=($)=>V($,Q$);var l="Store",a=($)=>{let R=new Set,G={add:new Set,change:new Set,remove:new Set,sort:new Set},J=new Map,X=new Map,C=Array.isArray($),W=E(0),H=()=>{let B={};for(let[x,M]of J)B[x]=M.get();return B},D=(B,x)=>{Object.freeze(x);for(let M of G[B])M(x)},P=()=>Array.from(J.keys()).map((B)=>Number(B)).filter((B)=>Number.isInteger(B)).sort((B,x)=>B-x),m=(B,x)=>{if(x==null)throw new f(`store for key "${B}"`);if(x===K)return!0;if(y(x)||Y(x)||d(x))throw new c(`store for key "${B}"`,b(x));return!0},j=(B,x,M=!1)=>{if(!m(B,x))return!1;let Q=w(x)||p(x)?x:T(x)||Array.isArray(x)?a(x):E(x);J.set(B,Q);let Z=M$(()=>{let q=Q.get();if(q!=null)D("change",{[B]:q})});if(X.set(B,Z),M)W.set(J.size),N(R),D("add",{[B]:x});return!0},I=(B,x=!1)=>{let M=J.delete(B);if(M){let Q=X.get(B);if(Q)Q();X.delete(B)}if(x)W.set(J.size),N(R),D("remove",{[B]:K});return M},z=(B,x,M)=>{let Q=$$(B,x);return x$(()=>{if(Object.keys(Q.add).length){for(let Z in Q.add){let q=Q.add[Z]??K;j(Z,q)}if(M)setTimeout(()=>{D("add",Q.add)},0);else D("add",Q.add)}if(Object.keys(Q.change).length){for(let Z in Q.change){let q=Q.change[Z];if(!m(Z,q))continue;let o=J.get(Z);if(X$(o))o.set(q);else throw new u(Z,b(q))}D("change",Q.change)}if(Object.keys(Q.remove).length){for(let Z in Q.remove)I(Z);D("remove",Q.remove)}W.set(J.size)}),Q.changed};z({},$,!0);let F={add:C?(B)=>{let x=J.size,M=String(x);j(M,B,!0)}:(B,x)=>{if(!J.has(B))j(B,x,!0);else throw new v(B,b(x))},get:()=>{return _(R),s(H())},remove:C?(B)=>{let x=s(H()),M=J.size;if(!Array.isArray(x)||B<=-M||B>=M)throw new n(B);let Q=[...x];if(Q.splice(B,1),z(x,Q))N(R)}:(B)=>{if(J.has(B))I(B,!0)},set:(B)=>{if(z(H(),B)){if(N(R),K===B)R.clear()}},update:(B)=>{let x=H(),M=B(s(x));if(z(x,M)){if(N(R),K===M)R.clear()}},sort:(B)=>{let x=Array.from(J.entries()).map(([Z,q])=>[Z,q.get()]).sort(B?(Z,q)=>B(Z[1],q[1]):(Z,q)=>String(Z[1]).localeCompare(String(q[1]))),M=x.map(([Z])=>String(Z)),Q=new Map;x.forEach(([Z],q)=>{let o=String(Z),H$=C?String(q):String(Z),Z$=J.get(o);if(Z$)Q.set(H$,Z$)}),J.clear(),Q.forEach((Z,q)=>J.set(q,Z)),N(R),D("sort",M)},on:(B,x)=>{return G[B].add(x),()=>G[B].delete(x)},size:W};return new Proxy({},{get(B,x){if(x===Symbol.toStringTag)return l;if(x===Symbol.isConcatSpreadable)return C;if(x===Symbol.iterator)return C?function*(){let M=P();for(let Q of M){let Z=J.get(String(Q));if(Z)yield Z}}:function*(){for(let[M,Q]of J)yield[M,Q]};if(y(x))return;if(x in F)return F[x];if(x==="length"&&C)return _(R),W.get();return J.get(x)},has(B,x){let M=String(x);return M&&J.has(M)||Object.keys(F).includes(M)||x===Symbol.toStringTag||x===Symbol.iterator||x===Symbol.isConcatSpreadable||x==="length"&&C},ownKeys(){return C?P().map((B)=>String(B)).concat(["length"]):Array.from(J.keys()).map((B)=>String(B))},getOwnPropertyDescriptor(B,x){let M=(Z)=>({enumerable:!1,configurable:!0,writable:!1,value:Z});if(x==="length"&&C)return{enumerable:!0,configurable:!0,writable:!1,value:W.get()};if(x===Symbol.isConcatSpreadable)return M(C);if(x===Symbol.toStringTag)return M(l);if(y(x))return;if(Object.keys(F).includes(x))return M(F[x]);let Q=J.get(x);return Q?{enumerable:!0,configurable:!0,writable:!0,value:Q}:void 0}})},p=($)=>V($,l);var W$=($)=>w($)||d($)||p($),X$=($)=>w($)||p($);function D$($){if(W$($))return $;if(G$($))return J$($);if(Array.isArray($)||T($))return a($);return E($)}export{b as valueString,D$ as toSignal,U as toError,_ as subscribe,q$ as resolve,h as observe,N as notify,K$ as match,y as isSymbol,e as isString,p as isStore,w as isState,W$ as isSignal,t as isRecordOrArray,T as isRecord,C$ as isNumber,X$ as isMutableSignal,Y as isFunction,A as isEqual,G$ as isComputedCallback,d as isComputed,g as isAsyncFunction,O as isAbortError,r as flush,$$ as diff,k as createWatcher,a as createStore,E as createState,M$ as createEffect,J$ as createComputed,x$ as batch,K as UNSET,l as TYPE_STORE,Q$ as TYPE_STATE,B$ as TYPE_COMPUTED,u as StoreKeyReadonlyError,n as StoreKeyRangeError,v as StoreKeyExistsError,f as NullishSignalValueError,c as InvalidSignalValueError,L as CircularDependencyError};
=======
var B=Symbol(),o=($)=>typeof $==="string",s=($)=>typeof $==="number",E=($)=>typeof $==="symbol",M=($)=>typeof $==="function",j=($)=>M($)&&$.constructor.name==="AsyncFunction",P$=($)=>M($)&&$.constructor.name!=="AsyncFunction",J$=($)=>$!=null&&typeof $==="object",K=($,G)=>Object.prototype.toString.call($)===`[object ${G}]`,D=($)=>K($,"Object"),c=($)=>D($)||Array.isArray($),z$=($,G=(J)=>J!=null)=>Array.isArray($)&&$.every(G);var S=($)=>$ instanceof DOMException&&$.name==="AbortError",T=($)=>o($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var L=($,G,J)=>{if(Object.is($,G))return!0;if(typeof $!==typeof G)return!1;if(!J$($)||!J$(G))return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(G))throw new U("isEqual");J.add($),J.add(G);try{if(Array.isArray($)&&Array.isArray(G)){if($.length!==G.length)return!1;for(let z=0;z<$.length;z++)if(!L($[z],G[z],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(G))return!1;if(D($)&&D(G)){let z=Object.keys($),X=Object.keys(G);if(z.length!==X.length)return!1;for(let Z of z){if(!(Z in G))return!1;if(!L($[Z],G[Z],J))return!1}return!0}return!1}finally{J.delete($),J.delete(G)}},w=($,G)=>{let J=c($),z=c(G);if(!J||!z){let H=!Object.is($,G);return{changed:H,add:H&&z?G:{},change:{},remove:H&&J?$:{}}}let X=new WeakSet,Z={},Q={},I={},f=Object.keys($),u=Object.keys(G),_=new Set([...f,...u]);for(let H of _){let W=H in $,m=H in G;if(!W&&m){Z[H]=G[H];continue}else if(W&&!m){I[H]=B;continue}let N$=$[H],Y$=G[H];if(!L(N$,Y$,X))Q[H]=Y$}return{add:Z,change:Q,remove:I,changed:!!(Object.keys(Z).length||Object.keys(Q).length||Object.keys(I).length)}};var O,g=new Set,i=0,Y=($)=>{let G=new Set,J=$;return J.onCleanup=(z)=>{G.add(z)},J.stop=()=>{for(let z of G)z();G.clear()},J},q=($)=>{if(O&&!$.has(O)){let G=O;G.onCleanup(()=>$.delete(G)),$.add(G)}},x=($)=>{for(let G of $)if(i)g.add(G);else G()},p=()=>{while(g.size){let $=Array.from(g);g.clear();for(let G of $)G()}},X$=($)=>{i++;try{$()}finally{p(),i--}},P=($,G)=>{let J=O;O=$||void 0;try{G()}finally{O=J}},A=($,G)=>{for(let J of $)if(i)g.add(()=>J(G));else J(G)};var t="Computed";class b{#G=new Set;#J;#z;#$;#X=!0;#Q=!1;#Z;constructor($,G=B){N("memo",$,l),F("memo",G),this.#J=$,this.#z=G,this.#Z=Y(()=>{if(this.#X=!0,this.#G.size)x(this.#G);else this.#Z.stop()})}get[Symbol.toStringTag](){return t}get(){if(q(this.#G),p(),this.#X)P(this.#Z,()=>{if(this.#Q)throw new U("memo");let $;this.#Q=!0;try{$=this.#J(this.#z)}catch(G){this.#z=B,this.#$=R(G),this.#Q=!1;return}if($==null||B===$)this.#z=B,this.#$=void 0;else this.#z=$,this.#$=void 0,this.#X=!1;this.#Q=!1});if(this.#$)throw this.#$;return this.#z}}class y{#G=new Set;#J;#z;#$;#X=!0;#Q=!1;#Z=!1;#x;#B;constructor($,G=B){N("task",$,r),F("task",G),this.#J=$,this.#z=G,this.#x=Y(()=>{if(this.#X=!0,this.#B?.abort(),this.#G.size)x(this.#G);else this.#x.stop()}),this.#x.onCleanup(()=>{this.#B?.abort()})}get[Symbol.toStringTag](){return t}get(){q(this.#G),p();let $=(Z)=>{if(!L(Z,this.#z))this.#z=Z,this.#Z=!0;this.#$=void 0,this.#X=!1},G=()=>{this.#Z=B!==this.#z,this.#z=B,this.#$=void 0},J=(Z)=>{let Q=R(Z);this.#Z=!this.#$||Q.name!==this.#$.name||Q.message!==this.#$.message,this.#z=B,this.#$=Q},z=(Z)=>(Q)=>{if(this.#Q=!1,this.#B=void 0,Z(Q),this.#Z)x(this.#G)},X=()=>P(this.#x,()=>{if(this.#Q)throw new U("task");if(this.#Z=!1,this.#B)return this.#z;this.#B=new AbortController,this.#B.signal.addEventListener("abort",()=>{this.#Q=!1,this.#B=void 0,X()},{once:!0});let Z;this.#Q=!0;try{Z=this.#J(this.#z,this.#B.signal)}catch(Q){if(S(Q))G();else J(Q);this.#Q=!1;return}if(Z instanceof Promise)Z.then(z($),z(J));else if(Z==null||B===Z)G();else $(Z);this.#Q=!1});if(this.#X)X();if(this.#$)throw this.#$;return this.#z}}var Z$=($,G=B)=>j($)?new y($,G):new b($,G),Q$=($)=>K($,t),l=($)=>P$($)&&$.length<2,r=($)=>j($)&&$.length<3;class k{signals=new Map;#G;#J;#z=new Map;#$={add:new Set,change:new Set,remove:new Set};#X=!1;constructor($,G,J){this.#G=G,this.#J=J,this.change({add:$,change:{},remove:{},changed:!0},!0)}#Q($){let G=Y(()=>{P(G,()=>{if(this.signals.get($)?.get(),!this.#X)A(this.#$.change,[$])})});this.#z.set($,G),G()}add($,G){if(!this.#G($,G))return!1;if(this.signals.set($,this.#J(G)),this.#$.change.size)this.#Q($);if(!this.#X)A(this.#$.add,[$]);return!0}remove($){if(!this.signals.delete($))return!1;let J=this.#z.get($);if(J)J.stop(),this.#z.delete($);if(!this.#X)A(this.#$.remove,[$]);return!0}change($,G){if(this.#X=!0,Object.keys($.add).length){for(let z in $.add)this.add(z,$.add[z]);let J=()=>A(this.#$.add,Object.keys($.add));if(G)setTimeout(J,0);else J()}if(Object.keys($.change).length)X$(()=>{for(let J in $.change){let z=$.change[J];if(!this.#G(J,z))continue;let X=this.signals.get(J);if(B$(`list item "${J}"`,z,X))X.set(z)}}),A(this.#$.change,Object.keys($.change));if(Object.keys($.remove).length){for(let J in $.remove)this.remove(J);A(this.#$.remove,Object.keys($.remove))}return this.#X=!1,$.changed}clear(){let $=Array.from(this.signals.keys());return this.signals.clear(),this.#z.clear(),A(this.#$.remove,$),!0}on($,G){if(this.#$[$].add(G),$==="change"&&!this.#z.size){this.#X=!0;for(let J of this.signals.keys())this.#Q(J);this.#X=!1}return()=>{if(this.#$[$].delete(G),$==="change"&&!this.#$.change.size){if(this.#z.size){for(let J of this.#z.values())J.stop();this.#z.clear()}}}}}var x$="State";class C{#G=new Set;#J;constructor($){F("state",$),this.#J=$}get[Symbol.toStringTag](){return x$}get(){return q(this.#G),this.#J}set($){if(F("state",$),L(this.#J,$))return;if(this.#J=$,x(this.#G),B===this.#J)this.#G.clear()}update($){N("state update",$),this.set($(this.#J))}}var a=($)=>K($,x$);var H$="List";class h{#G;#J=new Set;#z={sort:new Set};#$=[];#X;constructor($,G){F("list",$,Array.isArray);let J=0;this.#X=o(G)?()=>`${G}${J++}`:M(G)?(z)=>G(z):()=>String(J++),this.#G=new k(this.#Q($),(z,X)=>{return F(`list for key "${z}"`,X),!0},(z)=>new C(z))}#Q($){let G={};for(let J=0;J<$.length;J++){let z=$[J];if(z===void 0)continue;let X=this.#$[J];if(!X)X=this.#X(z),this.#$[J]=X;G[X]=z}return G}get#Z(){return this.#$.map(($)=>this.#G.signals.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return H$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let G=this.#G.signals.get($);if(G)yield G}}get length(){return q(this.#J),this.#$.length}get(){return q(this.#J),this.#Z}set($){if(B===$){this.#G.clear(),x(this.#J),this.#J.clear();return}let G=this.#Z,J=w(this.#Q(G),this.#Q($)),z=Object.keys(J.remove);if(this.#G.change(J)){for(let Z of z){let Q=this.#$.indexOf(Z);if(Q!==-1)this.#$.splice(Q,1)}this.#$=this.#$.filter(()=>!0),x(this.#J)}}update($){this.set($(this.get()))}at($){return this.#G.signals.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#G.signals.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let G=this.#X($);if(this.#G.signals.has(G))throw new V("store",G,$);if(!this.#$.includes(G))this.#$.push(G);if(this.#G.add(G,$))x(this.#J);return G}remove($){let G=s($)?this.#$[$]:$;if(this.#G.remove(G)){let z=s($)?$:this.#$.indexOf(G);if(z>=0)this.#$.splice(z,1);this.#$=this.#$.filter(()=>!0),x(this.#J)}}sort($){let J=this.#$.map((z)=>[z,this.#G.signals.get(z)?.get()]).sort(M($)?(z,X)=>$(z[1],X[1]):(z,X)=>String(z[1]).localeCompare(String(X[1]))).map(([z])=>z);if(!L(this.#$,J))this.#$=J,x(this.#J),A(this.#z.sort,this.#$)}splice($,G,...J){let z=this.#$.length,X=$<0?Math.max(0,z+$):Math.min($,z),Z=Math.max(0,Math.min(G??Math.max(0,z-Math.max(0,X)),z-X)),Q={},I={};for(let _=0;_<Z;_++){let H=X+_,W=this.#$[H];if(W){let m=this.#G.signals.get(W);if(m)I[W]=m.get()}}let f=this.#$.slice(0,X);for(let _ of J){let H=this.#X(_);f.push(H),Q[H]=_}f.push(...this.#$.slice(X+Z));let u=!!(Object.keys(Q).length||Object.keys(I).length);if(u)this.#G.change({add:Q,change:{},remove:I,changed:u}),this.#$=f.filter(()=>!0),x(this.#J);return Object.values(I)}on($,G){if($==="sort")return this.#z.sort.add(G),()=>{this.#z.sort.delete(G)};return this.#G.on($,G)}deriveCollection($){return new d(this,$)}}var v=($)=>K($,H$);var M$="Store";class q${#G;#J=new Set;constructor($){F("store",$,D),this.#G=new k($,(G,J)=>{return F(`store for key "${G}"`,J),!0},(G)=>U$(G))}get#z(){let $={};for(let[G,J]of this.#G.signals.entries())$[G]=J.get();return $}get[Symbol.toStringTag](){return M$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,G]of this.#G.signals.entries())yield[$,G]}get(){return q(this.#J),this.#z}set($){if(B===$){this.#G.clear(),x(this.#J),this.#J.clear();return}let G=this.#z;if(this.#G.change(w(G,$)))x(this.#J)}keys(){return this.#G.signals.keys()}byKey($){return this.#G.signals.get($)}update($){this.set($(this.get()))}add($,G){if(this.#G.signals.has($))throw new V("store",$,G);if(this.#G.add($,G))x(this.#J);return $}remove($){if(this.#G.remove($))x(this.#J)}on($,G){return this.#G.on($,G)}}var e=($)=>{let G=new q$($);return new Proxy(G,{get(J,z){if(z in J){let X=Reflect.get(J,z);return M(X)?X.bind(J):X}if(!E(z))return J.byKey(z)},has(J,z){if(z in J)return!0;return J.byKey(String(z))!==void 0},ownKeys(J){return Array.from(J.keys())},getOwnPropertyDescriptor(J,z){if(z in J)return Reflect.getOwnPropertyDescriptor(J,z);if(E(z))return;let X=J.byKey(String(z));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},$$=($)=>K($,M$);var T$=($)=>a($)||Q$($)||$$($),A$=($)=>a($)||$$($)||v($);function C$($){if(l($))return new b($);if(r($))return new y($);if(z$($))return new h($);if(D($))return e($);return new C($)}function U$($){if(z$($))return new h($);if(D($))return e($);return new C($)}class U extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class V extends Error{constructor($,G,J){super(`Could not add ${$} key "${G}"${J?` with value ${T(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class n extends TypeError{constructor($,G){super(`Invalid ${$} callback ${T(G)}`);this.name="InvalidCallbackError"}}class G$ extends TypeError{constructor($,G){super(`Invalid ${$} source ${T(G)}`);this.name="InvalidCollectionSourceError"}}class F$ extends TypeError{constructor($,G){super(`Invalid signal value ${T(G)} in ${$}`);this.name="InvalidSignalValueError"}}class I$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class K$ extends Error{constructor($,G){super(`Could not set ${$} to ${T(G)} because signal is read-only`);this.name="ReadonlySignalError"}}var R=($)=>$ instanceof Error?$:Error(String($)),N=($,G,J=M)=>{if(!J(G))throw new n($,G)},F=($,G,J=()=>!(E(G)&&G!==B)||M(G))=>{if(G==null)throw new I$($);if(!J(G))throw new F$($,G)},B$=($,G,J)=>{if(!A$(J))throw new K$($,G);return!0};var D$="Collection";class d{#G=new Set;#J;#z;#$=new Map;#X=new Map;#Q={add:new Set,change:new Set,remove:new Set,sort:new Set};#Z=[];constructor($,G){if(N("collection",G),M($))$=$();if(!W$($))throw new G$("derived collection",$);this.#J=$,this.#z=G;for(let J=0;J<this.#J.length;J++){let z=this.#J.keyAt(J);if(!z)continue;this.#x(z)}this.#J.on("add",(J)=>{for(let z of J)if(!this.#$.has(z)){this.#x(z);let X=this.#$.get(z);if(X&&_$(this.#z))X.get()}x(this.#G),A(this.#Q.add,J)}),this.#J.on("remove",(J)=>{for(let z of J){if(!this.#$.has(z))continue;this.#$.delete(z);let X=this.#Z.indexOf(z);if(X>=0)this.#Z.splice(X,1);let Z=this.#X.get(z);if(Z)Z.stop(),this.#X.delete(z)}this.#Z=this.#Z.filter(()=>!0),x(this.#G),A(this.#Q.remove,J)}),this.#J.on("sort",(J)=>{this.#Z=[...J],x(this.#G),A(this.#Q.sort,J)})}#x($){let G=_$(this.#z)?async(z,X)=>{let Z=this.#J.byKey($);if(!Z)return B;let Q=Z.get();if(Q===B)return B;return this.#z(Q,X)}:()=>{let z=this.#J.byKey($);if(!z)return B;let X=z.get();if(X===B)return B;return this.#z(X)},J=Z$(G);if(this.#$.set($,J),!this.#Z.includes($))this.#Z.push($);if(this.#Q.change.size)this.#B($);return!0}#B($){let G=Y(()=>{P(G,()=>{this.#$.get($)?.get()})});this.#X.set($,G),G()}get[Symbol.toStringTag](){return D$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#Z){let G=this.#$.get($);if(G)yield G}}get length(){return q(this.#G),this.#Z.length}get(){return q(this.#G),this.#Z.map(($)=>this.#$.get($)?.get()).filter(($)=>$!=null&&$!==B)}at($){return this.#$.get(this.#Z[$])}keys(){return this.#Z.values()}byKey($){return this.#$.get($)}keyAt($){return this.#Z[$]}indexOfKey($){return this.#Z.indexOf($)}on($,G){if(this.#Q[$].add(G),$==="change"&&!this.#X.size)for(let J of this.#$.keys())this.#B(J);return()=>{if(this.#Q[$].delete(G),$==="change"&&!this.#Q.change.size){if(this.#X.size){for(let J of this.#X.values())J.stop();this.#X.clear()}}}}deriveCollection($){return new d(this,$)}}var j$=($)=>K($,D$),W$=($)=>v($)||j$($),_$=($)=>j($);var L$="Ref";class R${#G=new Set;#J;constructor($,G){F("ref",$,G),this.#J=$}get[Symbol.toStringTag](){return L$}get(){return q(this.#G),this.#J}notify(){x(this.#G)}}var E$=($)=>K($,L$);var S$=($)=>{if(!M($)||$.length>1)throw new n("effect",$);let G=j($),J=!1,z,X=Y(()=>P(X,()=>{if(J)throw new U("effect");J=!0,z?.abort(),z=void 0;let Z;try{if(G){z=new AbortController;let Q=z;$(z.signal).then((I)=>{if(M(I)&&z===Q)X.onCleanup(I)}).catch((I)=>{if(!S(I))console.error("Async effect error:",I)})}else if(Z=$(),M(Z))X.onCleanup(Z)}catch(Q){if(!S(Q))console.error("Effect callback error:",Q)}J=!1}));return X(),()=>{z?.abort(),X.stop()}};function O$($,G){try{if($.pending)G.nil?.();else if($.errors)G.err?.($.errors);else if($.ok)G.ok($.values)}catch(J){let z=R(J);if(G.err&&(!$.errors||!$.errors.includes(z)))G.err($.errors?[...$.errors,z]:[z]);else throw z}}function V$($){let G=[],J=!1,z={};for(let[X,Z]of Object.entries($))try{let Q=Z.get();if(Q===B)J=!0;else z[X]=Q}catch(Q){G.push(R(Q))}if(J)return{ok:!1,pending:!0};if(G.length>0)return{ok:!1,errors:G};return{ok:!0,values:z}}export{T as valueString,F as validateSignalValue,N as validateCallback,P as trackSignalReads,q as subscribeActiveWatcher,V$ as resolve,x as notifyWatchers,O$ as match,r as isTaskCallback,E as isSymbol,o as isString,$$ as isStore,a as isState,T$ as isSignal,E$ as isRef,c as isRecordOrArray,D as isRecord,K as isObjectOfType,s as isNumber,A$ as isMutableSignal,l as isMemoCallback,v as isList,M as isFunction,L as isEqual,Q$ as isComputed,j$ as isCollection,j as isAsyncFunction,S as isAbortError,B$ as guardMutableSignal,p as flushPendingReactions,A as emitNotification,w as diff,Y as createWatcher,e as createStore,C$ as createSignal,R as createError,S$ as createEffect,Z$ as createComputed,X$ as batchSignalWrites,B as UNSET,y as Task,M$ as TYPE_STORE,x$ as TYPE_STATE,L$ as TYPE_REF,H$ as TYPE_LIST,t as TYPE_COMPUTED,D$ as TYPE_COLLECTION,C as State,R$ as Ref,K$ as ReadonlySignalError,I$ as NullishSignalValueError,b as Memo,h as List,F$ as InvalidSignalValueError,G$ as InvalidCollectionSourceError,n as InvalidCallbackError,V as DuplicateKeyError,d as DerivedCollection,U as CircularDependencyError,q$ as BaseStore};
>>>>>>> Stashed changes
