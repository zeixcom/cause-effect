var K=Symbol(),c=($)=>typeof $==="string",B$=($)=>typeof $==="number",C=($)=>typeof $==="symbol",Y=($)=>typeof $==="function",S=($)=>Y($)&&$.constructor.name==="AsyncFunction",T$=($)=>Y($)&&$.constructor.name!=="AsyncFunction",K$=($)=>$!=null&&typeof $==="object",T=($,J)=>Object.prototype.toString.call($)===`[object ${J}]`,V=($)=>T($,"Object"),i=($)=>V($)||Array.isArray($),q$=($,J=(z)=>z!=null)=>Array.isArray($)&&$.every(J);var m=($)=>$ instanceof DOMException&&$.name==="AbortError",W=($)=>$ instanceof Error?$:Error(String($)),y=($)=>c($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);function t($,J){try{if($.pending)J.nil?.();else if($.errors)J.err?.($.errors);else if($.ok)J.ok($.values)}catch(z){if(J.err&&(!$.errors||!$.errors.includes(W(z))))J.err($.errors?[...$.errors,W(z)]:[W(z)]);else throw z}}function l($){let J=[],z=!1,G={};for(let[Q,Z]of Object.entries($))try{let H=Z.get();if(H===K)z=!0;else G[Q]=H}catch(H){J.push(W(H))}if(z)return{ok:!1,pending:!0};if(J.length>0)return{ok:!1,errors:J};return{ok:!0,values:G}}var d,r=new Set,A$=0,j=($)=>{let J=new Set,z=$;return z.onCleanup=(G)=>{J.add(G)},z.stop=()=>{for(let G of J)G();J.clear()},z},L=($)=>{if(d&&!$.has(d)){let J=d;J.onCleanup(()=>{$.delete(J)}),$.add(J)}},I=($)=>{for(let J of $)if(A$)r.add(J);else J()},w=()=>{while(r.size){let $=Array.from(r);r.clear();for(let J of $)J()}},h=($)=>{A$++;try{$()}finally{w(),A$--}},U=($,J)=>{let z=d;d=$||void 0;try{J()}finally{d=z}},M=($,J)=>{for(let z of $)z(J)};var W$="Computed",N$=($,J=K)=>{if(!O$($))throw new b("computed",$);if(J==null)throw new g("computed");let z=new Set,G=J,Q,Z,H=!0,q=!1,R=!1,f=(F)=>{if(!O(F,G))G=F,q=!0;Q=void 0,H=!1},_=()=>{q=K!==G,G=K,Q=void 0},x=(F)=>{let P=W(F);q=!Q||P.name!==Q.name||P.message!==Q.message,G=K,Q=P},X=(F)=>(P)=>{if(R=!1,Z=void 0,F(P),q)I(z)},B=j(()=>{if(H=!0,Z?.abort(),z.size)I(z);else B.stop()});B.onCleanup(()=>{Z?.abort()});let A=()=>U(B,()=>{if(R)throw new E("computed");if(q=!1,S($)){if(Z)return G;Z=new AbortController,Z.signal.addEventListener("abort",()=>{R=!1,Z=void 0,A()},{once:!0})}let F;R=!0;try{F=Z?$(G,Z.signal):$(G)}catch(P){if(m(P))_();else x(P);R=!1;return}if(F instanceof Promise)F.then(X(f),X(x));else if(F==null||K===F)_();else f(F);R=!1}),D={};return Object.defineProperties(D,{[Symbol.toStringTag]:{value:W$},get:{value:()=>{if(L(z),w(),H)A();if(Q)throw Q;return G}}}),D};var O$=($)=>Y($)&&$.length<3;var I$="Collection",M$=($,J)=>{let z=new Set,G={add:new Set,change:new Set,remove:new Set,sort:new Set},Q=new Map,Z=new Map,H=[],q=(X)=>{let B=S(J)?async(F,P)=>{let p=$.byKey(X);if(!p)return K;let C$=K;return t(l({originSignal:p}),{ok:async({originSignal:H$})=>{C$=await J(H$,P)},err:(H$)=>{console.log(H$)}}),C$}:()=>{let F=$.byKey(X);if(!F)return K;let P=K;return t(l({originSignal:F}),{ok:({originSignal:p})=>{P=J(p)},err:(p)=>{console.log(p)}}),P},A=N$(B);if(Q.set(X,A),!H.includes(X))H.push(X);let D=j(()=>U(D,()=>{A.get(),M(G.change,[X])}));return D(),Z.set(X,D),!0},R=(X)=>{if(!Q.delete(X))return;let A=H.indexOf(X);if(A>=0)H.splice(A,1);let D=Z.get(X);if(D)D.stop(),Z.delete(X)};for(let X=0;X<$.length;X++){let B=$.keyAt(X);if(!B)continue;q(B)}$.on("add",(X)=>{for(let B of X)if(!Q.has(B))q(B);I(z),M(G.add,X)}),$.on("remove",(X)=>{for(let B of Object.keys(X)){if(!Q.has(B))continue;R(B)}H=H.filter(()=>!0),I(z),M(G.remove,X)}),$.on("sort",(X)=>{H=[...X],I(z),M(G.sort,X)});let f=(X)=>{let B=X,A=Number(X);if(Number.isInteger(A)&&A>=0)B=H[A]??X;return Q.get(B)},_=()=>H.map((X)=>Q.get(X)?.get()).filter((X)=>X!==K),x={};return Object.defineProperties(x,{[Symbol.toStringTag]:{value:I$},[Symbol.isConcatSpreadable]:{value:!0},[Symbol.iterator]:{value:function*(){for(let X of H){let B=Q.get(X);if(B)yield B}}},byKey:{value(X){return f(X)}},keyAt:{value(X){return H[X]}},indexOfKey:{value(X){return H.indexOf(X)}},get:{value:()=>{return L(z),_()}},sort:{value:(X)=>{H=H.map((A,D)=>{let F=Q.get(A);return[D,A,F?F.get():void 0]}).sort(X?(A,D)=>X(A[2],D[2]):(A,D)=>String(A[2]).localeCompare(String(D[2]))).map(([A,D])=>D),I(z),M(G.sort,H)}},on:{value:(X,B)=>{return G[X].add(B),()=>G[X].delete(B)}},length:{get(){return L(z),Q.size}}}),new Proxy(x,{get(X,B){if(B in X)return Reflect.get(X,B);if(!C(B))return f(B)},has(X,B){if(B in X)return!0;return Q.has(String(B))},ownKeys(X){let B=Reflect.ownKeys(X);return[...new Set([...H,...B])]},getOwnPropertyDescriptor(X,B){if(B in X)return Reflect.getOwnPropertyDescriptor(X,B);if(C(B))return;let A=f(B);return A?{enumerable:!0,configurable:!0,writable:!0,value:A}:void 0}})},f$=($)=>T($,I$);var x$="List";class D${watchers=new Set;listeners={add:new Set,change:new Set,remove:new Set,sort:new Set};signals=new Map;order=[];ownWatchers=new Map;batching=!1;keyCounter=0;keyConfig;constructor($,J){N("list",$,Array.isArray),this.keyConfig=J,this.reconcile([],$,!0)}generateKey($){let J=this.keyCounter++;return c(this.keyConfig)?`${this.keyConfig}${J}`:Y(this.keyConfig)?this.keyConfig($):String(J)}arrayToRecord($){let J={};for(let z=0;z<$.length;z++){let G=$[z];if(G===void 0)continue;let Q=this.order[z];if(!Q)Q=this.generateKey(G),this.order[z]=Q;J[Q]=G}return J}isValidValue($,J){return N(`list for key "${$}"`,J),!0}addOwnWatcher($,J){let z=j(()=>{U(z,()=>{if(J.get(),!this.batching)M(this.listeners.change,[$])})});this.ownWatchers.set($,z),z()}addProperty($,J,z=!1){if(!this.isValidValue($,J))return!1;let G=e(J);if(this.signals.set($,G),!this.order.includes($))this.order.push($);if(this.listeners.change.size)this.addOwnWatcher($,G);if(z)I(this.watchers),M(this.listeners.add,[$]);return!0}removeProperty($,J=!1){if(!this.signals.delete($))return;let G=this.order.indexOf($);if(G>=0)this.order.splice(G,1);let Q=this.ownWatchers.get($);if(Q)Q.stop(),this.ownWatchers.delete($);if(J)this.order=this.order.filter(()=>!0),I(this.watchers),M(this.listeners.remove,[$])}batchChanges($,J){if(Object.keys($.add).length){for(let z in $.add)this.addProperty(z,$.add[z],!1);if(J)setTimeout(()=>{M(this.listeners.add,Object.keys($.add))},0);else M(this.listeners.add,Object.keys($.add))}if(Object.keys($.change).length)this.batching=!0,h(()=>{for(let z in $.change){let G=$.change[z];if(!this.isValidValue(z,G))continue;let Q=this.signals.get(z);if($$(`list item "${z}"`,G,Q))Q.set(G)}}),this.batching=!1,M(this.listeners.change,Object.keys($.change));if(Object.keys($.remove).length){for(let z in $.remove)this.removeProperty(z);this.order=this.order.filter(()=>!0),M(this.listeners.remove,Object.keys($.remove))}return $.changed}reconcile($,J,z){return this.batchChanges(u(this.arrayToRecord($),this.arrayToRecord(J)),z)}get[Symbol.toStringTag](){return x$}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.order){let J=this.signals.get($);if(J)yield J}}get length(){return L(this.watchers),this.signals.size}get(){return L(this.watchers),this.order.map(($)=>this.signals.get($)?.get()).filter(($)=>$!==void 0)}set($){if(this.reconcile(this.get(),$)){if(I(this.watchers),K===$)this.watchers.clear()}}update($){this.set($(this.get()))}at($){return this.signals.get(this.order[$])}keys(){return this.order.values()}byKey($){return this.signals.get($)}keyAt($){return this.order[$]}indexOfKey($){return this.order.indexOf($)}add($){let J=this.generateKey($);if(!this.signals.has(J))return this.addProperty(J,$,!0),J;else throw new v("store",J,$)}remove($){let J=B$($)?this.order[$]:$;if(J&&this.signals.has(J))this.removeProperty(J,!0)}sort($){let z=this.order.map((G)=>[G,this.signals.get(G)?.get()]).sort(Y($)?(G,Q)=>$(G[1],Q[1]):(G,Q)=>String(G[1]).localeCompare(String(Q[1]))).map(([G])=>G);if(!O(this.order,z))this.order=z,I(this.watchers),M(this.listeners.sort,this.order)}splice($,J,...z){let G=this.signals.size,Q=$<0?Math.max(0,G+$):Math.min($,G),Z=Math.max(0,Math.min(J??Math.max(0,G-Math.max(0,Q)),G-Q)),H={},q={};for(let _=0;_<Z;_++){let x=Q+_,X=this.order[x];if(X){let B=this.signals.get(X);if(B)q[X]=B.get()}}let R=this.order.slice(0,Q);for(let _ of z){let x=this.generateKey(_);R.push(x),H[x]=_}R.push(...this.order.slice(Q+Z)),this.order=R.filter(()=>!0);let f=!!(Object.keys(H).length||Object.keys(q).length);if(f)this.batchChanges({add:H,change:{},remove:q,changed:f});return I(this.watchers),Object.values(q)}on($,J){if(this.listeners[$].add(J),$==="change"&&!this.ownWatchers.size){this.batching=!0;for(let[z,G]of this.signals)this.addOwnWatcher(z,G);for(let z of this.ownWatchers.values())z();this.batching=!1}return()=>{if(this.listeners[$].delete(J),$==="change"&&!this.listeners.change.size){if(this.ownWatchers.size){for(let z of this.ownWatchers.values())z.stop();this.ownWatchers.clear()}}}}deriveCollection($){return M$(this,$)}}var a=($,J)=>{let z=new D$($,J),G=(Q)=>{let Z=Number(Q);return Number.isInteger(Z)&&Z>=0?z.at(Z):z.byKey(Q)};return new Proxy(z,{get(Q,Z){if(Z in Q)return Reflect.get(Q,Z);return!C(Z)?G(Z):void 0},has(Q,Z){if(Z in Q)return!0;return!C(Z)?G(Z)!==void 0:!1},ownKeys(Q){return Object.getOwnPropertyNames(Q.keys())},getOwnPropertyDescriptor(Q,Z){if(C(Z))return;if(Z==="length")return{enumerable:!1,configurable:!1,writable:!1,value:Q.length};let H=Number(Z);if(Number.isInteger(H)&&H>=0&&H<Q.length){let q=Q.at(H);return q?{enumerable:!0,configurable:!0,writable:!0,value:q}:void 0}return}})},F$=($)=>T($,x$);var L$="State";class k{#z=new Set;#G;constructor($){N("state",$),this.#G=$}get[Symbol.toStringTag](){return L$}get(){return L(this.#z),this.#G}set($){if(N("state",$),O(this.#G,$))return;if(this.#G=$,I(this.#z),K===this.#G)this.#z.clear()}update($){o("state update",$),this.set($(this.#G))}}var E$=($)=>new k($),J$=($)=>T($,L$);var Y$="Store";class R${watchers=new Set;listeners={add:new Set,change:new Set,remove:new Set};signals=new Map;ownWatchers=new Map;batching=!1;constructor($){N("store",$,V),this.reconcile({},$,!0)}isValidValue($,J){return N(`store for key "${$}"`,J),!0}addOwnWatcher($,J){let z=j(()=>{U(z,()=>{if(J.get(),!this.batching)M(this.listeners.change,[$])})});this.ownWatchers.set($,z),z()}addProperty($,J,z=!1){N(`store for key "${$}"`,J);let G=e(J);if(this.signals.set($,G),this.listeners.change.size)this.addOwnWatcher($,G);if(z)I(this.watchers),M(this.listeners.add,[$]);return!0}removeProperty($,J=!1){if(!this.signals.delete($))return;let G=this.ownWatchers.get($);if(G)G.stop(),this.ownWatchers.delete($);if(J)I(this.watchers),M(this.listeners.remove,[$])}batchChanges($,J){if(Object.keys($.add).length){for(let z in $.add)this.addProperty(z,$.add[z],!1);if(J)setTimeout(()=>{M(this.listeners.add,Object.keys($.add))},0);else M(this.listeners.add,Object.keys($.add))}if(Object.keys($.change).length)this.batching=!0,h(()=>{for(let z in $.change){let G=$.change[z];if(!this.isValidValue(z,G))continue;let Q=this.signals.get(z);if($$(`store key "${z}"`,G,Q))Q.set(G)}}),this.batching=!1,M(this.listeners.change,Object.keys($.change));if(Object.keys($.remove).length){for(let z in $.remove)this.removeProperty(z);M(this.listeners.remove,Object.keys($.remove))}return $.changed}reconcile($,J,z){return this.batchChanges(u($,J),z)}get[Symbol.toStringTag](){return Y$}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,J]of this.signals)yield[$,J]}get(){L(this.watchers);let $={};for(let[J,z]of this.signals)$[J]=z.get();return $}set($){if(this.reconcile(this.get(),$)){if(I(this.watchers),K===$)this.watchers.clear()}}keys(){return this.signals.keys()}byKey($){return this.signals.get($)}update($){this.set($(this.get()))}add($,J){if(this.signals.has($))throw new v("store",$,J);return this.addProperty($,J,!0),$}remove($){if(this.signals.has($))this.removeProperty($,!0)}on($,J){if(this.listeners[$].add(J),$==="change"&&!this.ownWatchers.size){this.batching=!0;for(let[z,G]of this.signals)this.addOwnWatcher(z,G);for(let z of this.ownWatchers.values())z();this.batching=!1}return()=>{if(this.listeners[$].delete(J),$==="change"&&!this.listeners.change.size){if(this.ownWatchers.size){for(let z of this.ownWatchers.values())z.stop();this.ownWatchers.clear()}}}}}var z$=($)=>{let J=new R$($);return new Proxy(J,{get(z,G){if(G in z)return Reflect.get(z,G);if(!C(G))return z.byKey(G)},has(z,G){if(G in z)return!0;return z.byKey(String(G))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,G){if(C(G))return;if(G in z)return Reflect.getOwnPropertyDescriptor(z,G);let Q=z.byKey(String(G));return Q?{enumerable:!0,configurable:!0,writable:!0,value:Q}:void 0}})},G$=($)=>T($,Y$);var S$=($)=>J$($)||U$($)||G$($),j$=($)=>J$($)||G$($)||F$($);function V$($){if(Q$($))return new n($);if(X$($))return new s($);if(q$($))return a($);if(V($))return z$($);return new k($)}function e($){if(q$($))return a($);if(V($))return z$($);return new k($)}class E extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class v extends Error{constructor($,J,z){super(`Could not add ${$} key "${J}"${z?` with value ${y(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class b extends TypeError{constructor($,J){super(`Invalid ${$} callback ${y(J)}`);this.name="InvalidCallbackError"}}class _$ extends TypeError{constructor($,J){super(`Invalid signal value ${y(J)} in ${$}`);this.name="InvalidSignalValueError"}}class g extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class P$ extends Error{constructor($,J){super(`Could not set ${$} to ${y(J)} because signal is read-only`);this.name="ReadonlySignalError"}}var o=($,J,z=Y)=>{if(!z(J))throw new b($,J)},N=($,J,z=()=>!(C(J)&&J!==K)||Y(J))=>{if(J==null)throw new g($);if(!z(J))throw new _$($,J)},$$=($,J,z)=>{if(!j$(z))throw new P$($,J);return!0};var O=($,J,z)=>{if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if(!K$($)||!K$(J))return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new E("isEqual");z.add($),z.add(J);try{if(Array.isArray($)&&Array.isArray(J)){if($.length!==J.length)return!1;for(let G=0;G<$.length;G++)if(!O($[G],J[G],z))return!1;return!0}if(Array.isArray($)!==Array.isArray(J))return!1;if(V($)&&V(J)){let G=Object.keys($),Q=Object.keys(J);if(G.length!==Q.length)return!1;for(let Z of G){if(!(Z in J))return!1;if(!O($[Z],J[Z],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}},u=($,J)=>{let z=i($),G=i(J);if(!z||!G){let x=!Object.is($,J);return{changed:x,add:x&&G?J:{},change:{},remove:x&&z?$:{}}}let Q=new WeakSet,Z={},H={},q={},R=Object.keys($),f=Object.keys(J),_=new Set([...R,...f]);for(let x of _){let X=x in $,B=x in J;if(!X&&B){Z[x]=J[x];continue}else if(X&&!B){q[x]=K;continue}let A=$[x],D=J[x];if(!O(A,D,Q))H[x]=D}return{add:Z,change:H,remove:q,changed:!!(Object.keys(Z).length||Object.keys(H).length||Object.keys(q).length)}};var Z$="Computed";class n{#z=new Set;#G;#$;#J;#H=!0;#Q=!1;#X;constructor($,J=K){o("memo",$,Q$),N("memo",J),this.#G=$,this.#$=J,this.#X=j(()=>{if(this.#H=!0,this.#z.size)I(this.#z);else this.#X.stop()})}get[Symbol.toStringTag](){return Z$}get(){if(L(this.#z),w(),this.#H)U(this.#X,()=>{if(this.#Q)throw new E("memo");let $;this.#Q=!0;try{$=this.#G(this.#$)}catch(J){this.#$=K,this.#J=W(J),this.#Q=!1;return}if($==null||K===$)this.#$=K,this.#J=void 0;else this.#$=$,this.#J=void 0,this.#H=!1;this.#Q=!1});if(this.#J)throw this.#J;return this.#$}}class s{#z=new Set;#G;#$;#J;#H=!0;#Q=!1;#X=!1;#B;#Z;constructor($,J=K){o("task",$,X$),N("task",J),this.#G=$,this.#$=J,this.#B=j(()=>{if(this.#H=!0,this.#Z?.abort(),this.#z.size)I(this.#z);else this.#B.stop()}),this.#B.onCleanup(()=>{this.#Z?.abort()})}get[Symbol.toStringTag](){return Z$}get(){L(this.#z),w();let $=(Z)=>{if(!O(Z,this.#$))this.#$=Z,this.#X=!0;this.#J=void 0,this.#H=!1},J=()=>{this.#X=K!==this.#$,this.#$=K,this.#J=void 0},z=(Z)=>{let H=W(Z);this.#X=!this.#J||H.name!==this.#J.name||H.message!==this.#J.message,this.#$=K,this.#J=H},G=(Z)=>(H)=>{if(this.#Q=!1,this.#Z=void 0,Z(H),this.#X)I(this.#z)},Q=()=>U(this.#B,()=>{if(this.#Q)throw new E("task");if(this.#X=!1,this.#Z)return this.#$;this.#Z=new AbortController,this.#Z.signal.addEventListener("abort",()=>{this.#Q=!1,this.#Z=void 0,Q()},{once:!0});let Z;this.#Q=!0;try{Z=this.#G(this.#$,this.#Z.signal)}catch(H){if(m(H))J();else z(H);this.#Q=!1;return}if(Z instanceof Promise)Z.then(G($),G(z));else if(Z==null||K===Z)J();else $(Z);this.#Q=!1});if(this.#H)Q();if(this.#J)throw this.#J;return this.#$}}var m$=($,J=K)=>S($)?new s($,J):new n($,J),U$=($)=>T($,Z$),Q$=($)=>T$($)&&$.length<2,X$=($)=>S($)&&$.length<3;var w$=($)=>{if(!Y($)||$.length>1)throw new b("effect",$);let J=S($),z=!1,G,Q=j(()=>U(Q,()=>{if(z)throw new E("effect");z=!0,G?.abort(),G=void 0;let Z;try{if(J){G=new AbortController;let H=G;$(G.signal).then((q)=>{if(Y(q)&&G===H)Q.onCleanup(q)}).catch((q)=>{if(!m(q))console.error("Async effect error:",q)})}else if(Z=$(),Y(Z))Q.onCleanup(Z)}catch(H){if(!m(H))console.error("Effect callback error:",H)}z=!1}));return Q(),()=>{G?.abort(),Q.stop()}};export{y as valueString,U as trackSignalReads,W as toError,L as subscribeActiveWatcher,l as resolve,I as notifyWatchers,t as match,X$ as isTaskCallback,C as isSymbol,c as isString,G$ as isStore,J$ as isState,S$ as isSignal,i as isRecordOrArray,V as isRecord,T as isObjectOfType,B$ as isNumber,j$ as isMutableSignal,Q$ as isMemoCallback,F$ as isList,Y as isFunction,O as isEqual,U$ as isComputed,f$ as isCollection,S as isAsyncFunction,m as isAbortError,w as flushPendingReactions,M as emitNotification,u as diff,j as createWatcher,z$ as createStore,E$ as createState,V$ as createSignal,a as createList,w$ as createEffect,m$ as createComputed,M$ as createCollection,h as batchSignalWrites,K as UNSET,s as Task,Y$ as TYPE_STORE,L$ as TYPE_STATE,x$ as TYPE_LIST,Z$ as TYPE_COMPUTED,I$ as TYPE_COLLECTION,k as State,P$ as ReadonlySignalError,g as NullishSignalValueError,n as Memo,_$ as InvalidSignalValueError,b as InvalidCallbackError,v as DuplicateKeyError,E as CircularDependencyError,R$ as BaseStore,D$ as BaseList};
