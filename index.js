var K=Symbol(),J$=($)=>typeof $==="string",Q$=($)=>typeof $==="number",w=($)=>typeof $==="symbol",P=($)=>typeof $==="function",E=($)=>P($)&&$.constructor.name==="AsyncFunction",m=($,B)=>Object.prototype.toString.call($)===`[object ${B}]`,L=($)=>m($,"Object"),h=($)=>L($)||Array.isArray($),C$=($)=>{if(!$.length)return null;let B=$.map((x)=>J$(x)?parseInt(x,10):Q$(x)?x:NaN);return B.every((x)=>Number.isFinite(x)&&x>=0)?B.sort((x,J)=>x-J):null};var V=($)=>$ instanceof DOMException&&$.name==="AbortError",U=($)=>$ instanceof Error?$:Error(String($));var u=($)=>{let B=C$(Object.keys($));if(B===null)return $;let x=[];for(let J of B)x.push($[String(J)]);return x};class q extends Error{constructor($){super(`Circular dependency in ${$} detected`);this.name="CircularDependencyError"}}var D=($,B,x)=>{if(Object.is($,B))return!0;if(typeof $!==typeof B)return!1;if(typeof $!=="object"||$===null||B===null)return!1;if(!x)x=new WeakSet;if(x.has($)||x.has(B))throw new q("isEqual");x.add($),x.add(B);try{if(Array.isArray($)&&Array.isArray(B)){if($.length!==B.length)return!1;for(let J=0;J<$.length;J++)if(!D($[J],B[J],x))return!1;return!0}if(Array.isArray($)!==Array.isArray(B))return!1;if(L($)&&L(B)){let J=Object.keys($),Z=Object.keys(B);if(J.length!==Z.length)return!1;for(let G of J){if(!(G in B))return!1;if(!D($[G],B[G],x))return!1}return!0}return!1}finally{x.delete($),x.delete(B)}},t=($,B)=>{let x=h($),J=h(B);if(!x||!J){let M=!Object.is($,B);return{changed:M,add:M&&J?B:{},change:{},remove:M&&x?$:{}}}let Z=new WeakSet,G={},F={},C={},z=Object.keys($),N=Object.keys(B),A=new Set([...z,...N]);for(let M of A){let Y=M in $,Q=M in B;if(!Y&&Q){G[M]=B[M];continue}else if(Y&&!Q){C[M]=K;continue}let W=$[M],X=B[M];if(!D(W,X,Z))F[M]=X}return{changed:Object.keys(G).length>0||Object.keys(F).length>0||Object.keys(C).length>0,add:G,change:F,remove:C}};var j,p=new Set,i=0,s=new Map,d,X$=()=>{d=void 0;let $=Array.from(s.values());s.clear();for(let B of $)B()},M$=()=>{if(d)cancelAnimationFrame(d);d=requestAnimationFrame(X$)};queueMicrotask(X$);var g=($)=>{let B=new Set,x=$;return x.off=(J)=>{B.add(J)},x.cleanup=()=>{for(let J of B)J();B.clear()},x},S=($)=>{if(j&&!$.has(j)){let B=j;$.add(B),j.off(()=>{$.delete(B)})}},I=($)=>{for(let B of $)if(i)p.add(B);else B()},n=()=>{while(p.size){let $=Array.from(p);p.clear();for(let B of $)B()}},r=($)=>{i++;try{$()}finally{n(),i--}},k=($,B)=>{let x=j;j=B;try{$()}finally{j=x}},H$=($,B)=>new Promise((x,J)=>{s.set(B||Symbol(),()=>{try{x($())}catch(Z){J(Z)}}),M$()});var l="Computed",a=($)=>{let B=new Set,x=K,J,Z,G=!0,F=!1,C=!1,z=(W)=>{if(!D(W,x))x=W,F=!0;J=void 0,G=!1},N=()=>{F=K!==x,x=K,J=void 0},A=(W)=>{let X=U(W);F=!J||X.name!==J.name||X.message!==J.message,x=K,J=X},_=(W)=>(X)=>{if(C=!1,Z=void 0,W(X),F)I(B)},M=g(()=>{if(G=!0,Z?.abort(),B.size)I(B);else M.cleanup()});M.off(()=>{Z?.abort()});let Y=()=>k(()=>{if(C)throw new q("computed");if(F=!1,E($)){if(Z)return x;Z=new AbortController,Z.signal.addEventListener("abort",()=>{C=!1,Z=void 0,Y()},{once:!0})}let W;C=!0;try{W=Z?$(Z.signal):$()}catch(X){if(V(X))N();else A(X);C=!1;return}if(W instanceof Promise)W.then(_(z),_(A));else if(W==null||K===W)N();else z(W);C=!1},M);return{[Symbol.toStringTag]:l,get:()=>{if(S(B),n(),G)Y();if(J)throw J;return x}}},e=($)=>m($,l),$$=($)=>P($)&&$.length<2;var B$=($)=>{let B=E($),x=!1,J,Z=g(()=>k(()=>{if(x)throw new q("effect");x=!0,J?.abort(),J=void 0;let G;try{if(B){J=new AbortController;let F=J;$(J.signal).then((C)=>{if(P(C)&&J===F)Z.off(C)}).catch((C)=>{if(!V(C))console.error("Async effect error:",C)})}else if(G=$(),P(G))Z.off(G)}catch(F){if(!V(F))console.error("Effect callback error:",F)}x=!1},Z));return Z(),()=>{J?.abort(),Z.cleanup()}};function K$($,B){try{if($.pending)B.nil?.();else if($.errors)B.err?.($.errors);else if($.ok)B.ok($.values)}catch(x){if(B.err&&(!$.errors||!$.errors.includes(U(x))))B.err($.errors?[...$.errors,U(x)]:[U(x)]);else throw x}}function R$($){let B=[],x=!1,J={};for(let[Z,G]of Object.entries($))try{let F=G.get();if(F===K)x=!0;else J[Z]=F}catch(F){B.push(U(F))}if(x)return{ok:!1,pending:!0};if(B.length>0)return{ok:!1,errors:B};return{ok:!0,values:J}}var W$="State",T=($)=>{let B=new Set,x=$,J={[Symbol.toStringTag]:W$,get:()=>{return S(B),x},set:(Z)=>{if(D(x,Z))return;if(x=Z,I(B),K===x)B.clear()},update:(Z)=>{J.set(Z(x))}};return J},f=($)=>m($,W$);var o="Store",c="store-add",Z$="store-change",F$="store-remove",y=($)=>{let B=new Set,x=new EventTarget,J=new Map,Z=new Map,G=Array.isArray($),F=T(0),C=()=>{let Q={};for(let[W,X]of J)Q[W]=X.get();return Q},z=(Q,W)=>x.dispatchEvent(new CustomEvent(Q,{detail:W})),N=()=>Array.from(J.keys()).map((Q)=>Number(Q)).filter((Q)=>Number.isInteger(Q)).sort((Q,W)=>Q-W),A=(Q,W)=>{if(w(Q)||W==null)return!1;let X=f(W)||b(W)?W:L(W)?y(W):Array.isArray(W)?y(W):T(W);J.set(Q,X);let H=B$(()=>{let R=X.get();if(R!=null)z(Z$,{[Q]:R})});return Z.set(Q,H),!0},_=(Q)=>{let W=J.delete(Q);if(W){let X=Z.get(Q);if(X)X();Z.delete(Q)}return W},M=(Q,W,X)=>{let H=t(Q,W);return r(()=>{if(Object.keys(H.add).length){for(let R in H.add){let O=H.add[R];if(O!=null)A(R,O)}if(X)setTimeout(()=>{z(c,H.add)},0);else z(c,H.add)}if(Object.keys(H.change).length){for(let R in H.change){let O=J.get(R),v=H.change[R];if(x$(O)&&v!=null)O.set(v);else console.error(`Invalid change for key ${R}: ${v}`)}z(Z$,H.change)}if(Object.keys(H.remove).length){for(let R in H.remove)_(R);z(F$,H.remove)}F.set(J.size)}),H.changed};M({},$,!0);let Y={add:G?(Q)=>{let W=J.size;if(Q==null){console.error(`Invalid value for key ${String(W)}: ${Q}`);return}if(A(W,Q))F.set(J.size),I(B),z(c,{[W]:Q});else console.error(`Failed to add value ${Q} to key ${String(W)}`)}:(Q,W)=>{if(!J.has(Q)){if(W==null){console.error(`Invalid value for key ${Q}: ${W}`);return}if(A(Q,W))F.set(J.size),I(B),z(c,{[Q]:W});else console.error(`Failed to add value ${W} to key ${Q}`)}else console.error(`Key ${Q} already exists`)},get:()=>{return S(B),u(C())},remove:(Q)=>{if(J.has(Q))_(Q),I(B),z(F$,{[Q]:K}),F.set(J.size)},set:(Q)=>{if(M(C(),Q)){if(I(B),K===Q)B.clear()}},update:(Q)=>{let W=C(),X=Q(u(W));if(M(W,X)){if(I(B),K===X)B.clear()}},addEventListener:x.addEventListener.bind(x),removeEventListener:x.removeEventListener.bind(x),dispatchEvent:x.dispatchEvent.bind(x),size:F};return new Proxy({},{get(Q,W){if(W===Symbol.toStringTag)return o;if(W===Symbol.isConcatSpreadable)return G;if(W===Symbol.iterator)return G?function*(){let X=N();for(let H of X){let R=J.get(String(H));if(R)yield R}}:function*(){for(let[X,H]of J)yield[X,H]};if(w(W))return;if(W in Y)return Y[W];if(W==="length"&&G)return F.get();return J.get(W)},has(Q,W){let X=String(W);return X&&J.has(X)||Object.keys(Y).includes(X)||W===Symbol.toStringTag||W===Symbol.iterator||W===Symbol.isConcatSpreadable||W==="length"&&G},ownKeys(){return G?N().map((Q)=>String(Q)).concat(["length"]):Array.from(J.keys()).map((Q)=>String(Q))},getOwnPropertyDescriptor(Q,W){if(W==="length"&&G)return{enumerable:!1,configurable:!0,writable:!1,value:F.get()};if(W===Symbol.isConcatSpreadable)return{enumerable:!1,configurable:!0,writable:!1,value:G};if(W===Symbol.toStringTag)return{enumerable:!1,configurable:!0,writable:!1,value:o};if(w(W))return;if(Object.keys(Y).includes(W))return{enumerable:!1,configurable:!0,writable:!1,value:Y[W]};let X=J.get(W);return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},b=($)=>m($,o);var G$=($)=>f($)||e($)||b($),x$=($)=>f($)||b($);function z$($){if(G$($))return $;if($$($))return a($);if(Array.isArray($))return y($);if(Array.isArray($)||L($))return y($);return T($)}export{g as watch,z$ as toSignal,U as toError,S as subscribe,y as store,T as state,R$ as resolve,k as observe,I as notify,K$ as match,w as isSymbol,J$ as isString,b as isStore,f as isState,G$ as isSignal,h as isRecordOrArray,L as isRecord,Q$ as isNumber,x$ as isMutableSignal,P as isFunction,D as isEqual,$$ as isComputedCallback,e as isComputed,E as isAsyncFunction,V as isAbortError,n as flush,H$ as enqueue,B$ as effect,t as diff,a as computed,r as batch,K as UNSET,o as TYPE_STORE,W$ as TYPE_STATE,l as TYPE_COMPUTED,q as CircularDependencyError};
