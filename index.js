var M,V=new WeakMap,U$=new WeakMap,Y$=new WeakMap,s=new Set,B$=0,Z=Symbol(),Y=($,G)=>{let J=new Set,z=$;return z.run=()=>{let Q=M;M=z;try{G()}finally{M=Q}},z.onCleanup=(Q)=>{J.add(Q)},z.stop=()=>{try{for(let Q of J)Q()}finally{J.clear()}},z},q$=($)=>{let G=M;M=void 0;try{$()}finally{M=G}},K=($,G,J)=>{if(U$.set($,G),J)Y$.set($,J)},q=($)=>{if(!M||V.get($)?.has(M))return!1;let G=M;if(!V.has($))V.set($,new Set);let J=V.get($);if(j$(J),!J.size){let z=U$.get($);if(z)q$(z)}return J.add(G),G.onCleanup(()=>{if(J.delete(G),!J.size){let z=Y$.get($);if(z)q$(z)}}),!0};var C=($)=>{let G=V.get($);if(!G)return;for(let J of G)J.stop();G.clear()},x=($)=>{let G=V.get($);if(!G?.size)return!1;for(let J of G)if(B$)s.add(J);else J();return!0};var y=()=>{while(s.size){let $=Array.from(s);s.clear();for(let G of $)G()}},d=($)=>{B$++;try{$()}finally{y(),B$--}},E$=($,G)=>{let J=M;M=$||void 0;try{G()}finally{M=J}};var l=($)=>typeof $==="string",a=($)=>typeof $==="number",E=($)=>typeof $==="symbol",A=($)=>typeof $==="function",j=($)=>A($)&&$.constructor.name==="AsyncFunction",P$=($)=>A($)&&$.constructor.name!=="AsyncFunction",H$=($)=>$!=null&&typeof $==="object",F=($,G)=>Object.prototype.toString.call($)===`[object ${G}]`,L=($)=>F($,"Object"),e=($)=>L($)||Array.isArray($),A$=($,G=(J)=>J!=null)=>Array.isArray($)&&$.every(G);var T=($)=>$ instanceof DOMException&&$.name==="AbortError",_=($)=>l($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var N=($,G,J)=>{if(Object.is($,G))return!0;if(typeof $!==typeof G)return!1;if(!H$($)||!H$(G))return!1;if(!J)J=new WeakSet;if(J.has($)||J.has(G))throw new R("isEqual");J.add($),J.add(G);try{if(Array.isArray($)&&Array.isArray(G)){if($.length!==G.length)return!1;for(let z=0;z<$.length;z++)if(!N($[z],G[z],J))return!1;return!0}if(Array.isArray($)!==Array.isArray(G))return!1;if(L($)&&L(G)){let z=Object.keys($),Q=Object.keys(G);if(z.length!==Q.length)return!1;for(let X of z){if(!(X in G))return!1;if(!N($[X],G[X],J))return!1}return!0}return!1}finally{J.delete($),J.delete(G)}},k=($,G)=>{let J=e($),z=e(G);if(!J||!z){let H=!Object.is($,G);return{changed:H,add:H&&z?G:{},change:{},remove:H&&J?$:{}}}let Q=new WeakSet,X={},B={},D={},g=Object.keys($),t=Object.keys(G),U=new Set([...g,...t]);for(let H of U){let S=H in $,b=H in G;if(!S&&b){X[H]=G[H];continue}else if(S&&!b){D[H]=Z;continue}let C$=$[H],R$=G[H];if(!N(C$,R$,Q))B[H]=R$}return{add:X,change:B,remove:D,changed:!!(Object.keys(X).length||Object.keys(B).length||Object.keys(D).length)}};var $$="Computed";class v{#G;#$;#J;#z=!0;#Q=!1;#X;constructor($,G){m(this.constructor.name,$,G$);let J=G?.initialValue??Z;if(I(this.constructor.name,J,G?.guard),this.#G=$,this.#$=J,G?.watched)K(this,G.watched,G.unwatched)}#Z(){return this.#X||=Y(()=>{if(this.#z=!0,!x(this))this.#X?.stop()},()=>{if(this.#Q)throw new R("memo");let $;this.#Q=!0;try{$=this.#G(this.#$)}catch(G){this.#$=Z,this.#J=P(G),this.#Q=!1;return}if($==null||Z===$)this.#$=Z,this.#J=void 0;else this.#$=$,this.#J=void 0,this.#z=!1;this.#Q=!1}),this.#X.onCleanup(()=>{this.#X=void 0}),this.#X}get[Symbol.toStringTag](){return $$}get(){if(q(this),y(),this.#z)this.#Z().run();if(this.#J)throw this.#J;return this.#$}}class h{#G;#$;#J;#z=!0;#Q=!1;#X=!1;#Z;#x;constructor($,G){m(this.constructor.name,$,J$);let J=G?.initialValue??Z;if(I(this.constructor.name,J,G?.guard),this.#G=$,this.#$=J,G?.watched)K(this,G.watched,G.unwatched)}#B(){if(!this.#Z){let $=(Q)=>{if(!N(Q,this.#$))this.#$=Q,this.#X=!0;this.#J=void 0,this.#z=!1},G=()=>{this.#X=Z!==this.#$,this.#$=Z,this.#J=void 0},J=(Q)=>{let X=P(Q);this.#X=!this.#J||X.name!==this.#J.name||X.message!==this.#J.message,this.#$=Z,this.#J=X},z=(Q)=>(X)=>{if(this.#Q=!1,this.#x=void 0,Q(X),this.#X&&!x(this))this.#Z?.stop()};this.#Z=Y(()=>{if(this.#z=!0,this.#x?.abort(),!x(this))this.#Z?.stop()},()=>{if(this.#Q)throw new R("task");if(this.#X=!1,this.#x)return this.#$;this.#x=new AbortController,this.#x.signal.addEventListener("abort",()=>{this.#Q=!1,this.#x=void 0,this.#B().run()},{once:!0});let Q;this.#Q=!0;try{Q=this.#G(this.#$,this.#x.signal)}catch(X){if(T(X))G();else J(X);this.#Q=!1;return}if(Q instanceof Promise)Q.then(z($),z(J));else if(Q==null||Z===Q)G();else $(Q);this.#Q=!1}),this.#Z.onCleanup(()=>{this.#x?.abort(),this.#x=void 0,this.#Z=void 0})}return this.#Z}get[Symbol.toStringTag](){return $$}get(){if(q(this),y(),this.#z)this.#B().run();if(this.#J)throw this.#J;return this.#$}}var I$=($,G)=>j($)?new h($,G):new v($,G),D$=($)=>F($,$$),G$=($)=>P$($)&&$.length<2,J$=($)=>j($)&&$.length<3;var f="State";class W{#G;constructor($,G){if(I(f,$,G?.guard),this.#G=$,G?.watched)K(this,G.watched,G.unwatched)}get[Symbol.toStringTag](){return f}get(){return q(this),this.#G}set($){if(I(f,$),N(this.#G,$))return;if(this.#G=$,x(this),Z===this.#G)C(this)}update($){m(`${f} update`,$),this.set($(this.#G))}}var z$=($)=>F($,f);var O="List";class o{#G=new Map;#$=[];#J;#z;constructor($,G){I(O,$,Array.isArray);let J=0,z=G?.keyConfig;if(this.#J=l(z)?()=>`${z}${J++}`:A(z)?(Q)=>z(Q):()=>String(J++),this.#z=(Q,X)=>{return I(`${O} item for key "${Q}"`,X,G?.guard),!0},this.#Z({add:this.#Q($),change:{},remove:{},changed:!0}),G?.watched)K(this,G.watched,G.unwatched)}#Q($){let G={};for(let J=0;J<$.length;J++){let z=$[J];if(z===void 0)continue;let Q=this.#$[J];if(!Q)Q=this.#J(z),this.#$[J]=Q;G[Q]=z}return G}#X($,G){if(!this.#z($,G))return!1;return this.#G.set($,new W(G)),!0}#Z($){if(Object.keys($.add).length)for(let G in $.add)this.#X(G,$.add[G]);if(Object.keys($.change).length)d(()=>{for(let G in $.change){let J=$.change[G];if(!this.#z(G,J))continue;let z=this.#G.get(G);if(u(`${O} item "${G}"`,J,z))z.set(J)}});if(Object.keys($.remove).length){for(let G in $.remove){this.#G.delete(G);let J=this.#$.indexOf(G);if(J!==-1)this.#$.splice(J,1)}this.#$=this.#$.filter(()=>!0)}return $.changed}get#x(){return this.#$.map(($)=>this.#G.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return O}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let G=this.#G.get($);if(G)yield G}}get length(){return q(this),this.#$.length}get(){return q(this),this.#x}set($){if(Z===$){this.#G.clear(),x(this),C(this);return}let G=k(this.#Q(this.#x),this.#Q($));if(this.#Z(G))x(this)}update($){this.set($(this.get()))}at($){return this.#G.get(this.#$[$])}keys(){return q(this),this.#$.values()}byKey($){return this.#G.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let G=this.#J($);if(this.#G.has(G))throw new w("store",G,$);if(!this.#$.includes(G))this.#$.push(G);if(this.#X(G,$))x(this);return G}remove($){let G=a($)?this.#$[$]:$;if(this.#G.delete(G)){let z=a($)?$:this.#$.indexOf(G);if(z>=0)this.#$.splice(z,1);this.#$=this.#$.filter(()=>!0),x(this)}}sort($){let J=this.#$.map((z)=>[z,this.#G.get(z)?.get()]).sort(A($)?(z,Q)=>$(z[1],Q[1]):(z,Q)=>String(z[1]).localeCompare(String(Q[1]))).map(([z])=>z);if(!N(this.#$,J))this.#$=J,x(this)}splice($,G,...J){let z=this.#$.length,Q=$<0?Math.max(0,z+$):Math.min($,z),X=Math.max(0,Math.min(G??Math.max(0,z-Math.max(0,Q)),z-Q)),B={},D={};for(let U=0;U<X;U++){let H=Q+U,S=this.#$[H];if(S){let b=this.#G.get(S);if(b)D[S]=b.get()}}let g=this.#$.slice(0,Q);for(let U of J){let H=this.#J(U);g.push(H),B[H]=U}g.push(...this.#$.slice(Q+X));let t=!!(Object.keys(B).length||Object.keys(D).length);if(t)this.#Z({add:B,change:{},remove:D,changed:t}),this.#$=g.filter(()=>!0),x(this);return Object.values(D)}deriveCollection($,G){return new i(this,$,G)}}var n=($)=>F($,O);var p="Store";class F${#G=new Map;constructor($,G){if(I(p,$,G?.guard??L),this.#Q({add:$,change:{},remove:{},changed:!0}),G?.watched)K(this,G.watched,G.unwatched)}get#$(){let $={};for(let[G,J]of this.#G.entries())$[G]=J.get();return $}#J($,G){return I(`${p} for key "${$}"`,G),!0}#z($,G){if(!this.#J($,G))return!1;return this.#G.set($,m$(G)),!0}#Q($){if(Object.keys($.add).length)for(let G in $.add)this.add(G,$.add[G]);if(Object.keys($.change).length)d(()=>{for(let G in $.change){let J=$.change[G];if(!this.#J(G,J))continue;let z=this.#G.get(G);if(u(`list item "${G}"`,J,z))z.set(J)}});if(Object.keys($.remove).length)for(let G in $.remove)this.remove(G);return $.changed}get[Symbol.toStringTag](){return p}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,G]of this.#G.entries())yield[$,G]}keys(){return q(this),this.#G.keys()}byKey($){return this.#G.get($)}get(){return q(this),this.#$}set($){if(Z===$){this.#G.clear(),x(this),C(this);return}if(this.#Q(k(this.#$,$)))x(this)}update($){this.set($(this.get()))}add($,G){if(this.#G.has($))throw new w(p,$,G);if(this.#z($,G))x(this);return $}remove($){if(this.#G.delete($))x(this)}}var Q$=($,G)=>{let J=new F$($,G);return new Proxy(J,{get(z,Q){if(Q in z){let X=Reflect.get(z,Q);return A(X)?X.bind(z):X}if(!E(Q))return z.byKey(Q)},has(z,Q){if(Q in z)return!0;return z.byKey(String(Q))!==void 0},ownKeys(z){return Array.from(z.keys())},getOwnPropertyDescriptor(z,Q){if(Q in z)return Reflect.getOwnPropertyDescriptor(z,Q);if(E(Q))return;let X=z.byKey(String(Q));return X?{enumerable:!0,configurable:!0,writable:!0,value:X}:void 0}})},X$=($)=>F($,p);var T$=($)=>z$($)||D$($)||X$($),K$=($)=>z$($)||X$($)||n($);function f$($){if(G$($))return new v($);if(J$($))return new h($);if(A$($))return new o($);if(L($))return Q$($);return new W($)}function m$($){if(A$($))return new o($);if(L($))return Q$($);return new W($)}class R extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class w extends Error{constructor($,G,J){super(`Could not add ${$} key "${G}"${J?` with value ${_(J)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class _$ extends Error{constructor($="unexpected condition"){super(`Assertion failed: ${$}`);this.name="FailedAssertionError"}}class r extends TypeError{constructor($,G){super(`Invalid ${$} callback ${_(G)}`);this.name="InvalidCallbackError"}}class Z$ extends TypeError{constructor($,G){super(`Invalid ${$} source ${_(G)}`);this.name="InvalidCollectionSourceError"}}class W$ extends TypeError{constructor($,G){super(`Invalid hook "${G}" in  ${$}`);this.name="InvalidHookError"}}class M$ extends TypeError{constructor($,G){super(`Invalid signal value ${_(G)} in ${$}`);this.name="InvalidSignalValueError"}}class L$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class N$ extends Error{constructor($,G){super(`Could not set ${$} to ${_(G)} because signal is read-only`);this.name="ReadonlySignalError"}}function j$($,G){if(!$)throw new _$(G)}var P=($)=>$ instanceof Error?$:Error(String($)),m=($,G,J=A)=>{if(!J(G))throw new r($,G)},I=($,G,J=()=>!(E(G)&&G!==Z)||A(G))=>{if(G==null)throw new L$($);if(!J(G))throw new M$($,G)},u=($,G,J)=>{if(!K$(J))throw new N$($,G);return!0};var c="Collection";class i{#G;#$;#J=new Map;#z=[];#Q=!0;#X;constructor($,G,J){if(m(c,G),A($))$=$();if(!O$($))throw new Z$(c,$);this.#G=$,this.#$=G;for(let z=0;z<this.#G.length;z++){let Q=this.#G.keyAt(z);if(!Q)continue;this.#x(Q)}if(J?.watched)K(this,J.watched,J.unwatched)}#Z(){return this.#X||=Y(()=>{if(this.#Q=!0,!x(this))this.#X?.stop()},()=>{let $=Array.from(this.#G.keys()),G=new Set([...this.#z,...$]),J=[],z=[];for(let Q of G){let X=this.#z.includes(Q),B=$.includes(Q);if(!X&&B)J.push(Q);else if(X&&!B)z.push(Q)}for(let Q of z)this.#J.delete(Q);for(let Q of J)this.#x(Q);this.#z=$,this.#Q=!1}),this.#X.onCleanup(()=>{this.#X=void 0}),this.#X}#x($){let G=w$(this.#$)?async(z,Q)=>{let X=this.#G.byKey($)?.get();if(X===Z)return Z;return this.#$(X,Q)}:()=>{let z=this.#G.byKey($)?.get();if(z===Z)return Z;return this.#$(z)},J=I$(G);if(this.#J.set($,J),!this.#z.includes($))this.#z.push($);return!0}get[Symbol.toStringTag](){return c}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#z){let G=this.#J.get($);if(G)yield G}}keys(){if(q(this),this.#Q)this.#Z().run();return this.#z.values()}get(){if(q(this),this.#Q)this.#Z().run();return this.#z.map(($)=>this.#J.get($)?.get()).filter(($)=>$!=null&&$!==Z)}at($){return this.#J.get(this.#z[$])}byKey($){return this.#J.get($)}keyAt($){return this.#z[$]}indexOfKey($){return this.#z.indexOf($)}deriveCollection($,G){return new i(this,$,G)}get length(){if(q(this),this.#Q)this.#Z().run();return this.#z.length}}var S$=($)=>F($,c),O$=($)=>n($)||S$($),w$=($)=>j($);var x$="Ref";class V${#G;constructor($,G){if(I(x$,$,G?.guard),this.#G=$,G?.watched)K(this,G.watched,G.unwatched)}get[Symbol.toStringTag](){return x$}get(){return q(this),this.#G}notify(){x(this)}}var p$=($)=>F($,x$);var g$=($)=>{if(!A($)||$.length>1)throw new r("effect",$);let G=j($),J=!1,z,Q=Y(()=>{Q.run()},()=>{if(J)throw new R("effect");J=!0,z?.abort(),z=void 0;let X;try{if(G){z=new AbortController;let B=z;$(z.signal).then((D)=>{if(A(D)&&z===B)Q.onCleanup(D)}).catch((D)=>{if(!T(D))console.error("Error in async effect callback:",D)})}else if(X=$(),A(X))Q.onCleanup(X)}catch(B){if(!T(B))console.error("Error in effect callback:",B)}J=!1});return Q(),()=>{z?.abort();try{Q.stop()}catch(X){console.error("Error in effect cleanup:",X)}}};function b$($,G){try{if($.pending)G.nil?.();else if($.errors)G.err?.($.errors);else if($.ok)G.ok($.values)}catch(J){let z=P(J);if(G.err&&(!$.errors||!$.errors.includes(z)))G.err($.errors?[...$.errors,z]:[z]);else throw z}}function y$($){let G=[],J=!1,z={};for(let[Q,X]of Object.entries($))try{let B=X.get();if(B===Z)J=!0;else z[Q]=B}catch(B){G.push(P(B))}if(J)return{ok:!1,pending:!0};if(G.length>0)return{ok:!1,errors:G};return{ok:!0,values:z}}export{_ as valueString,I as validateSignalValue,m as validateCallback,q$ as untrack,E$ as track,q as subscribeTo,y$ as resolve,x as notifyOf,b$ as match,J$ as isTaskCallback,E as isSymbol,l as isString,X$ as isStore,z$ as isState,T$ as isSignal,p$ as isRef,e as isRecordOrArray,L as isRecord,F as isObjectOfType,a as isNumber,K$ as isMutableSignal,G$ as isMemoCallback,n as isList,A as isFunction,N as isEqual,D$ as isComputed,S$ as isCollection,j as isAsyncFunction,T as isAbortError,u as guardMutableSignal,y as flush,k as diff,Y as createWatcher,Q$ as createStore,f$ as createSignal,P as createError,g$ as createEffect,I$ as createComputed,d as batch,Z as UNSET,h as Task,p as TYPE_STORE,f as TYPE_STATE,x$ as TYPE_REF,O as TYPE_LIST,$$ as TYPE_COMPUTED,c as TYPE_COLLECTION,W as State,V$ as Ref,N$ as ReadonlySignalError,L$ as NullishSignalValueError,v as Memo,o as List,M$ as InvalidSignalValueError,W$ as InvalidHookError,Z$ as InvalidCollectionSourceError,r as InvalidCallbackError,w as DuplicateKeyError,i as DerivedCollection,R as CircularDependencyError,F$ as BaseStore};
