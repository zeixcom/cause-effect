function y($){return typeof $==="function"}function t($){return y($)&&$.constructor.name==="AsyncFunction"}function G$($){return y($)&&$.constructor.name!=="AsyncFunction"}function Y($,J){return Object.prototype.toString.call($)===`[object ${J}]`}function O($){return Y($,"Object")}function V$($,J=(z)=>z!=null){return Array.isArray($)&&$.every(J)}function D$($){return typeof $==="string"?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($)}class J$ extends Error{constructor($){super(`[${$}] Circular dependency detected`);this.name="CircularDependencyError"}}class Y$ extends TypeError{constructor($){super(`[${$}] Signal value cannot be null or undefined`);this.name="NullishSignalValueError"}}class r extends Error{constructor($){super(`[${$}] Signal value is unset`);this.name="UnsetSignalValueError"}}class z$ extends TypeError{constructor($,J){super(`[${$}] Signal value ${D$(J)} is invalid`);this.name="InvalidSignalValueError"}}class A$ extends TypeError{constructor($,J){super(`[${$}] Callback ${D$(J)} is invalid`);this.name="InvalidCallbackError"}}class m$ extends Error{constructor($){super(`[${$}] Active owner is required`);this.name="RequiredOwnerError"}}class n extends Error{constructor($,J,z){super(`[${$}] Could not add key "${J}"${z?` with value ${JSON.stringify(z)}`:""} because it already exists`);this.name="DuplicateKeyError"}}function K($,J,z){if(J==null)throw new Y$($);if(z&&!z(J))throw new z$($,J)}function X$($,J){if(J==null)throw new r($)}function _($,J,z=y){if(!z(J))throw new A$($,J)}var k="State",v="Memo",c="Task",u="Sensor",w="List",g="Collection",d="Store",b=0,F$=1,m=2,Q$=4,G=null,p=null,P$=[],A=0,f$=!1,s=($,J)=>$===J,L$=($,J)=>!1;function p$($,J){let z=J.sourcesTail;if(z){let X=J.sources;while(X){if(X===$)return!0;if(X===z)break;X=X.nextSource}}return!1}function V($,J){let z=J.sourcesTail;if(z?.source===$)return;let X=null,B=J.flags&Q$;if(B){if(X=z?z.nextSource:J.sources,X?.source===$){J.sourcesTail=X;return}}let Q=$.sinksTail;if(Q?.sink===J&&(!B||p$(Q,J)))return;let M={source:$,sink:J,nextSource:X,prevSink:Q,nextSink:null};if(J.sourcesTail=$.sinksTail=M,z)z.nextSource=M;else J.sources=M;if(Q)Q.nextSink=M;else $.sinks=M}function y$($){let{source:J,nextSource:z,nextSink:X,prevSink:B}=$;if(X)X.prevSink=B;else J.sinksTail=B;if(B)B.nextSink=X;else J.sinks=X;if(!J.sinks&&J.stop)J.stop(),J.stop=void 0;return z}function B$($){let J=$.sourcesTail,z=J?J.nextSource:$.sources;while(z)z=y$(z);if(J)J.nextSource=null;else $.sources=null}function f($,J=m){let z=$.flags;if("sinks"in $){if((z&(m|F$))>=J)return;if($.flags=z|J,"controller"in $&&$.controller)$.controller.abort(),$.controller=void 0;for(let X=$.sinks;X;X=X.nextSink)f(X.sink,F$)}else{if(z&m)return;$.flags=m,P$.push($)}}function q$($,J){if($.equals($.value,J))return;$.value=J;for(let z=$.sinks;z;z=z.nextSink)f(z.sink);if(A===0)L()}function a($,J){if(!$.cleanup)$.cleanup=J;else if(Array.isArray($.cleanup))$.cleanup.push(J);else $.cleanup=[$.cleanup,J]}function R$($){if(!$.cleanup)return;if(Array.isArray($.cleanup))for(let J=0;J<$.cleanup.length;J++)$.cleanup[J]();else $.cleanup();$.cleanup=null}function g$($){let J=G;G=$,$.sourcesTail=null,$.flags=Q$;let z=!1;try{let X=$.fn($.value);if($.error||!$.equals(X,$.value))$.value=X,$.error=void 0,z=!0}catch(X){z=!0,$.error=X instanceof Error?X:Error(String(X))}finally{G=J,B$($)}if(z){for(let X=$.sinks;X;X=X.nextSink)if(X.sink.flags&F$)X.sink.flags|=m}$.flags=b}function k$($){$.controller?.abort();let J=new AbortController;$.controller=J,$.error=void 0;let z=G;G=$,$.sourcesTail=null,$.flags=Q$;let X;try{X=$.fn($.value,J.signal)}catch(B){$.controller=void 0,$.error=B instanceof Error?B:Error(String(B));return}finally{G=z,B$($)}X.then((B)=>{if(J.signal.aborted)return;if($.controller=void 0,$.error||!$.equals(B,$.value)){$.value=B,$.error=void 0;for(let Q=$.sinks;Q;Q=Q.nextSink)f(Q.sink);if(A===0)L()}},(B)=>{if(J.signal.aborted)return;$.controller=void 0;let Q=B instanceof Error?B:Error(String(B));if(!$.error||Q.name!==$.error.name||Q.message!==$.error.message){$.error=Q;for(let M=$.sinks;M;M=M.nextSink)f(M.sink);if(A===0)L()}}),$.flags=b}function O$($){R$($);let J=G,z=p;G=p=$,$.sourcesTail=null,$.flags=Q$;try{let X=$.fn();if(typeof X==="function")a($,X)}finally{G=J,p=z,B$($)}$.flags=b}function T($){if($.flags&F$)for(let J=$.sources;J;J=J.nextSource){if("fn"in J.source)T(J.source);if($.flags&m)break}if($.flags&Q$)throw new J$("controller"in $?c:("value"in $)?v:"Effect");if($.flags&m)if("controller"in $)k$($);else if("value"in $)g$($);else O$($);else $.flags=b}function L(){if(f$)return;f$=!0;try{for(let $=0;$<P$.length;$++){let J=P$[$];if(J.flags&m)T(J)}P$.length=0}finally{f$=!1}}function e($){A++;try{$()}finally{if(A--,A===0)L()}}function l($){let J=G;G=null;try{return $()}finally{G=J}}function v$($){let J=p,z={cleanup:null};p=z;try{let X=$();if(typeof X==="function")a(z,X);let B=()=>R$(z);if(J)a(J,B);return B}finally{p=J}}function S($,J){K(k,$,J?.guard);let z={value:$,sinks:null,sinksTail:null,equals:J?.equals??s,guard:J?.guard};return{[Symbol.toStringTag]:k,get(){if(G)V(z,G);return z.value},set(X){K(k,X,z.guard),q$(z,X)},update(X){_(k,X);let B=X(z.value);K(k,B,z.guard),q$(z,B)}}}function M$($){return Y($,k)}function i($,J,z){if(Object.is($,J))return!0;if(typeof $!==typeof J)return!1;if($==null||typeof $!=="object"||J==null||typeof J!=="object")return!1;if(!z)z=new WeakSet;if(z.has($)||z.has(J))throw new J$("isEqual");z.add($),z.add(J);try{let X=Array.isArray($);if(X!==Array.isArray(J))return!1;if(X){let B=$,Q=J;if(B.length!==Q.length)return!1;for(let M=0;M<B.length;M++)if(!i(B[M],Q[M],z))return!1;return!0}if(O($)&&O(J)){let B=Object.keys($),Q=Object.keys(J);if(B.length!==Q.length)return!1;for(let M of B){if(!(M in J))return!1;if(!i($[M],J[M],z))return!1}return!0}return!1}finally{z.delete($),z.delete(J)}}function U$($,J){if($.length!==J.length)return!1;for(let z=0;z<$.length;z++)if($[z]!==J[z])return!1;return!0}function _$($){let J=0,z=typeof $==="function";return[typeof $==="string"?()=>`${$}${J++}`:z?(X)=>$(X)||String(J++):()=>String(J++),z]}function c$($,J,z,X,B){let Q=new WeakSet,M={},U={},F={},P=[],W=!1,Z=new Map;for(let D=0;D<$.length;D++){let H=z[D];if(H&&$[D])Z.set(H,$[D])}let x=new Set;for(let D=0;D<J.length;D++){let H=J[D];if(H===void 0)continue;let q=B?X(H):z[D]??X(H);if(x.has(q))throw new n(w,q,H);if(P.push(q),x.add(q),!Z.has(q))M[q]=H,W=!0;else{let j=Z.get(q);if(!i(j,H,Q))U[q]=H,W=!0}}for(let[D]of Z)if(!x.has(D))F[D]=null,W=!0;if(!W&&!U$(z,P))W=!0;return{add:M,change:U,remove:F,newKeys:P,changed:W}}function Z$($,J){K(w,$,Array.isArray);let z=new Map,X=[],[B,Q]=_$(J?.keyConfig),M=()=>X.map((H)=>z.get(H)?.get()).filter((H)=>H!==void 0),U={fn:M,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:i,error:void 0},F=(H)=>{let q={};for(let j=0;j<H.length;j++){let N=H[j];if(N===void 0)continue;let R=X[j];if(!R)R=B(N),X[j]=R;q[R]=N}return q},P=(H)=>{let q=!1;for(let j in H.add){let N=H.add[j];K(`${w} item for key "${j}"`,N),z.set(j,S(N)),q=!0}if(Object.keys(H.change).length)e(()=>{for(let j in H.change){let N=H.change[j];K(`${w} item for key "${j}"`,N);let R=z.get(j);if(R)R.set(N)}});for(let j in H.remove){z.delete(j);let N=X.indexOf(j);if(N!==-1)X.splice(N,1);q=!0}if(q)U.sources=null,U.sourcesTail=null;return H.changed},W=J?.watched,Z=W?()=>{if(G){if(!U.sinks)U.stop=W();V(U,G)}}:()=>{if(G)V(U,G)},x=F($);for(let H in x){let q=x[H];K(`${w} item for key "${H}"`,q),z.set(H,S(q))}U.value=$,U.flags=0;let D={[Symbol.toStringTag]:w,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let H of X){let q=z.get(H);if(q)yield q}},get length(){return Z(),X.length},get(){if(Z(),U.sources){if(U.flags)U.value=l(M),U.flags=b}else if(T(U),U.error)throw U.error;return U.value},set(H){let q=U.flags&m?M():U.value,j=c$(q,H,X,B,Q);if(j.changed){X=j.newKeys,P(j),U.flags|=m;for(let N=U.sinks;N;N=N.nextSink)f(N.sink);if(A===0)L()}},update(H){D.set(H(D.get()))},at(H){return z.get(X[H])},keys(){return Z(),X.values()},byKey(H){return z.get(H)},keyAt(H){return X[H]},indexOfKey(H){return X.indexOf(H)},add(H){let q=B(H);if(z.has(q))throw new n(w,q,H);if(!X.includes(q))X.push(q);K(`${w} item for key "${q}"`,H),z.set(q,S(H)),U.sources=null,U.sourcesTail=null,U.flags|=m;for(let j=U.sinks;j;j=j.nextSink)f(j.sink);if(A===0)L();return q},remove(H){let q=typeof H==="number"?X[H]:H;if(z.delete(q)){let N=typeof H==="number"?H:X.indexOf(q);if(N>=0)X.splice(N,1);U.sources=null,U.sourcesTail=null,U.flags|=m;for(let R=U.sinks;R;R=R.nextSink)f(R.sink);if(A===0)L()}},sort(H){let j=X.map((N)=>[N,z.get(N)?.get()]).sort(y(H)?(N,R)=>H(N[1],R[1]):(N,R)=>String(N[1]).localeCompare(String(R[1]))).map(([N])=>N);if(!U$(X,j)){X=j,U.flags|=m;for(let N=U.sinks;N;N=N.nextSink)f(N.sink);if(A===0)L()}},splice(H,q,...j){let N=X.length,R=H<0?Math.max(0,N+H):Math.min(H,N),$$=Math.max(0,Math.min(q??Math.max(0,N-Math.max(0,R)),N-R)),C={},I={};for(let E=0;E<$$;E++){let o=R+E,I$=X[o];if(I$){let E$=z.get(I$);if(E$)I[I$]=E$.get()}}let h=X.slice(0,R);for(let E of j){let o=B(E);if(z.has(o)&&!(o in I))throw new n(w,o,E);h.push(o),C[o]=E}h.push(...X.slice(R+$$));let x$=!!(Object.keys(C).length||Object.keys(I).length);if(x$){P({add:C,change:{},remove:I,changed:x$}),X=h,U.flags|=m;for(let E=U.sinks;E;E=E.nextSink)f(E.sink);if(A===0)L()}return Object.values(I)},deriveCollection(H){return K$(D,H)}};return D}function j$($){return Y($,w)}function W$($,J){if(_(v,$,G$),J?.value!==void 0)K(v,J.value,J?.guard);let z={fn:$,value:J?.value,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:J?.equals??s,error:void 0};return{[Symbol.toStringTag]:v,get(){if(G)V(z,G);if(T(z),z.error)throw z.error;return X$(v,z.value),z.value}}}function w$($){return Y($,v)}function H$($,J){if(_(c,$,t),J?.value!==void 0)K(c,J.value,J?.guard);let z={fn:$,value:J?.value,sources:null,sourcesTail:null,sinks:null,sinksTail:null,flags:m,equals:J?.equals??s,controller:void 0,error:void 0};return{[Symbol.toStringTag]:c,get(){if(G)V(z,G);if(T(z),z.error)throw z.error;return X$(c,z.value),z.value},isPending(){return!!z.controller},abort(){z.controller?.abort(),z.controller=void 0}}}function b$($){return Y($,c)}function K$($,J){if(_(g,J),!d$($))throw TypeError(`[${g}] Invalid collection source: expected a List or Collection`);let z=t(J),X=new Map,B=(W)=>{let Z=z?H$(async(x,D)=>{let H=$.byKey(W)?.get();if(H==null)return x;return J(H,D)}):W$(()=>{let x=$.byKey(W)?.get();if(x==null)return;return J(x)});X.set(W,Z)};function Q(){let W=Array.from($.keys()),Z=M.value;if(!U$(Z,W)){let x=new Set(Z),D=new Set(W);for(let H of Z)if(!D.has(H))X.delete(H);for(let H of W)if(!x.has(H))B(H)}return W}let M={fn:Q,value:[],flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:U$,error:void 0};function U(){if(M.sources){if(M.flags)M.value=l(Q),M.flags=b}else if(T(M),M.error)throw M.error;return M.value}let F=Array.from($.keys());for(let W of F)B(W);M.value=F;let P={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let W of M.value){let Z=X.get(W);if(Z)yield Z}},get length(){if(G)V(M,G);return U().length},keys(){if(G)V(M,G);return U().values()},get(){if(G)V(M,G);let W=U(),Z=[];for(let x of W)try{let D=X.get(x)?.get();if(D!=null)Z.push(D)}catch(D){if(!(D instanceof r))throw D}return Z},at(W){return X.get(M.value[W])},byKey(W){return X.get(W)},keyAt(W){return M.value[W]},indexOfKey(W){return M.value.indexOf(W)},deriveCollection(W){return K$(P,W)}};return P}function u$($,J){let z=J?.value??[];if(z.length)K(g,z,Array.isArray);_(g,$);let X=new Map,B=[],Q=new Map,[M,U]=_$(J?.keyConfig),F=(q)=>Q.get(q)??(U?M(q):void 0),P=J?.createItem??((q,j)=>S(j));function W(){let q=[];for(let j of B)try{let N=X.get(j)?.get();if(N!=null)q.push(N)}catch(N){if(!(N instanceof r))throw N}return q}let Z={fn:W,value:z,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:L$,error:void 0};function x(q){let{add:j,change:N,remove:R}=q;if(!j?.length&&!N?.length&&!R?.length)return;let $$=!1;e(()=>{if(j)for(let C of j){let I=M(C);if(X.set(I,P(I,C)),Q.set(C,I),!B.includes(I))B.push(I);$$=!0}if(N)for(let C of N){let I=F(C);if(!I)continue;let h=X.get(I);if(h&&M$(h)){let x$=h.get();Q.delete(x$),h.set(C),Q.set(C,I)}}if(R)for(let C of R){let I=F(C);if(!I)continue;Q.delete(C),X.delete(I);let h=B.indexOf(I);if(h!==-1)B.splice(h,1);$$=!0}if($$)Z.sources=null,Z.sourcesTail=null;Z.flags=m;for(let C=Z.sinks;C;C=C.nextSink)f(C.sink)})}for(let q of z){let j=M(q);X.set(j,P(j,q)),Q.set(q,j),B.push(j)}Z.value=z,Z.flags=m;function D(){if(G){if(!Z.sinks)Z.stop=$(x);V(Z,G)}}let H={[Symbol.toStringTag]:g,[Symbol.isConcatSpreadable]:!0,*[Symbol.iterator](){for(let q of B){let j=X.get(q);if(j)yield j}},get length(){return D(),B.length},keys(){return D(),B.values()},get(){if(D(),Z.sources){if(Z.flags)Z.value=l(W),Z.flags=b}else if(T(Z),Z.error)throw Z.error;return Z.value},at(q){return X.get(B[q])},byKey(q){return X.get(q)},keyAt(q){return B[q]},indexOfKey(q){return B.indexOf(q)},deriveCollection(q){return K$(H,q)}};return H}function S$($){return Y($,g)}function d$($){return j$($)||S$($)}function t$($){_("Effect",$);let J={fn:$,flags:m,sources:null,sourcesTail:null,cleanup:null},z=()=>{R$(J),J.fn=void 0,J.flags=b,J.sourcesTail=null,B$(J)};if(p)a(p,z);return O$(J),z}function r$($,J){if(!p)throw new m$("match");let{ok:z,err:X=console.error,nil:B}=J,Q,M=!1,U=Array($.length);for(let P=0;P<$.length;P++)try{U[P]=$[P].get()}catch(W){if(W instanceof r){M=!0;continue}if(!Q)Q=[];Q.push(W instanceof Error?W:Error(String(W)))}let F;try{if(M)F=B?.();else if(Q)F=X(Q);else F=z(U)}catch(P){X([P instanceof Error?P:Error(String(P))])}if(typeof F==="function")return F;if(F instanceof Promise){let P=p,W=new AbortController;a(P,()=>W.abort()),F.then((Z)=>{if(!W.signal.aborted&&typeof Z==="function")a(P,Z)}).catch((Z)=>{X([Z instanceof Error?Z:Error(String(Z))])})}}function s$($,J){if(_(u,$,G$),J?.value!==void 0)K(u,J.value,J?.guard);let z={value:J?.value,sinks:null,sinksTail:null,equals:J?.equals??s,guard:J?.guard,stop:void 0};return{[Symbol.toStringTag]:u,get(){if(G){if(!z.sinks)z.stop=$((X)=>{K(u,X,z.guard),q$(z,X)});V(z,G)}return X$(u,z.value),z.value}}}function l$($){return Y($,u)}function i$($,J){let z=O($)||Array.isArray($),X=O(J)||Array.isArray(J);if(!z||!X){let Z=!Object.is($,J);return{changed:Z,add:Z&&X?J:{},change:{},remove:Z&&z?$:{}}}let B=new WeakSet,Q={},M={},U={},F=!1,P=Object.keys($),W=Object.keys(J);for(let Z of W)if(Z in $){if(!i($[Z],J[Z],B))M[Z]=J[Z],F=!0}else Q[Z]=J[Z],F=!0;for(let Z of P)if(!(Z in J))U[Z]=void 0,F=!0;return{add:Q,change:M,remove:U,changed:F}}function N$($,J){K(d,$,O);let z=new Map,X=(W,Z)=>{if(K(`${d} for key "${W}"`,Z),Array.isArray(Z))z.set(W,Z$(Z));else if(O(Z))z.set(W,N$(Z));else z.set(W,S(Z))},B=()=>{let W={};return z.forEach((Z,x)=>{W[x]=Z.get()}),W},Q={fn:B,value:$,flags:m,sources:null,sourcesTail:null,sinks:null,sinksTail:null,equals:i,error:void 0},M=(W)=>{let Z=!1;for(let x in W.add)X(x,W.add[x]),Z=!0;if(Object.keys(W.change).length)e(()=>{for(let x in W.change){let D=W.change[x];K(`${d} for key "${x}"`,D);let H=z.get(x);if(H)if(O(D)!==C$(H))X(x,D),Z=!0;else H.set(D)}});for(let x in W.remove)z.delete(x),Z=!0;if(Z)Q.sources=null,Q.sourcesTail=null;return W.changed},U=J?.watched,F=U?()=>{if(G){if(!Q.sinks)Q.stop=U();V(Q,G)}}:()=>{if(G)V(Q,G)};for(let W of Object.keys($))X(W,$[W]);let P={[Symbol.toStringTag]:d,[Symbol.isConcatSpreadable]:!1,*[Symbol.iterator](){for(let W of Array.from(z.keys())){let Z=z.get(W);if(Z)yield[W,Z]}},keys(){return F(),z.keys()},byKey(W){return z.get(W)},get(){if(F(),Q.sources){if(Q.flags)Q.value=l(B),Q.flags=b}else if(T(Q),Q.error)throw Q.error;return Q.value},set(W){let Z=Q.flags&m?B():Q.value,x=i$(Z,W);if(M(x)){Q.flags|=m;for(let D=Q.sinks;D;D=D.nextSink)f(D.sink);if(A===0)L()}},update(W){P.set(W(P.get()))},add(W,Z){if(z.has(W))throw new n(d,W,Z);X(W,Z),Q.sources=null,Q.sourcesTail=null,Q.flags|=m;for(let x=Q.sinks;x;x=x.nextSink)f(x.sink);if(A===0)L();return W},remove(W){if(z.delete(W)){Q.sources=null,Q.sourcesTail=null,Q.flags|=m;for(let x=Q.sinks;x;x=x.nextSink)f(x.sink);if(A===0)L()}}};return new Proxy(P,{get(W,Z){if(Z in W)return Reflect.get(W,Z);if(typeof Z!=="symbol")return W.byKey(Z)},has(W,Z){if(Z in W)return!0;return W.byKey(String(Z))!==void 0},ownKeys(W){return Array.from(W.keys())},getOwnPropertyDescriptor(W,Z){if(Z in W)return Reflect.getOwnPropertyDescriptor(W,Z);if(typeof Z==="symbol")return;let x=W.byKey(String(Z));return x?{enumerable:!0,configurable:!0,writable:!0,value:x}:void 0}})}function C$($){return Y($,d)}function o$($,J){return t($)?H$($,J):W$($,J)}function n$($){if(T$($))return $;if($==null)throw new z$("createSignal",$);if(t($))return H$($);if(y($))return W$($);if(V$($))return Z$($);if(O($))return N$($);return S($)}function a$($){if(h$($))return $;if($==null||y($)||T$($))throw new z$("createMutableSignal",$);if(V$($))return Z$($);if(O($))return N$($);return S($)}function e$($){return w$($)||b$($)}function T$($){let J=[k,v,c,u,w,g,d],z=Object.prototype.toString.call($).slice(8,-1);return J.includes(z)}function h$($){return M$($)||C$($)||j$($)}export{D$ as valueString,l as untrack,r$ as match,b$ as isTask,C$ as isStore,M$ as isState,T$ as isSignal,l$ as isSensor,O as isRecord,Y as isObjectOfType,h$ as isMutableSignal,w$ as isMemo,j$ as isList,y as isFunction,i as isEqual,e$ as isComputed,S$ as isCollection,t as isAsyncFunction,H$ as createTask,N$ as createStore,S as createState,n$ as createSignal,s$ as createSensor,v$ as createScope,a$ as createMutableSignal,W$ as createMemo,Z$ as createList,t$ as createEffect,o$ as createComputed,u$ as createCollection,e as batch,r as UnsetSignalValueError,L$ as SKIP_EQUALITY,m$ as RequiredOwnerError,Y$ as NullishSignalValueError,z$ as InvalidSignalValueError,A$ as InvalidCallbackError,J$ as CircularDependencyError};
