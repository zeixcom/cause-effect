var r=($)=>typeof $==="string",l=($)=>typeof $==="number",S=($)=>typeof $==="symbol",Z=($)=>typeof $==="function",j=($)=>Z($)&&$.constructor.name==="AsyncFunction",W$=($)=>Z($)&&$.constructor.name!=="AsyncFunction",X$=($)=>$!=null&&typeof $==="object",I=($,x)=>Object.prototype.toString.call($)===`[object ${x}]`,U=($)=>I($,"Object"),a=($)=>U($)||Array.isArray($),Z$=($,x=(G)=>G!=null)=>Array.isArray($)&&$.every(x);var m=($)=>$ instanceof DOMException&&$.name==="AbortError",P=($)=>r($)?`"${$}"`:!!$&&typeof $==="object"?JSON.stringify($):String($);var N,T=new WeakMap,Y$=new WeakMap,P$=new WeakMap,e=new Set,B$=0,Q=Symbol(),w$="add",g$="change",E$="cleanup",O$="remove",y$="sort",k$="watch",C=($)=>{let x=new Set,G=$;return G.onCleanup=(H)=>{x.add(H)},G.stop=()=>{try{for(let H of x)H()}finally{x.clear()}},G},j$=($)=>{let x=N;N=void 0;try{$()}finally{N=x}},M=($,x,G)=>{if(Y$.set($,x),G)P$.set($,G)},q=($)=>{if(!N||T.get($)?.has(N))return!1;let x=N;if(!T.has($))T.set($,new Set);let G=T.get($);if(f$(G),!G.size){let H=Y$.get($);if(H)j$(()=>H($))}return G.add(x),x.onCleanup(()=>{if(G.delete(x),!G.size){let H=P$.get($);if(H)j$(()=>H($))}}),!0},V=($)=>{let x=T.get($);if(!x)return;for(let G of x)G.stop();x.clear()},X=($)=>{let x=T.get($);if(!x?.size)return!1;for(let G of x)if(B$)e.add(G);else G();return!0},h=()=>{while(e.size){let $=Array.from(e);e.clear();for(let x of $)x()}},q$=($)=>{B$++;try{$()}finally{h(),B$--}},w=($,x)=>{let G=N;N=$||void 0;try{x()}finally{N=G}},h$=($,x)=>{if(!$)return;let G=[],H=[],J=(K)=>{if(H.length){if(H.length===1)throw H[0];throw AggregateError(H,`Errors in hook ${K?"cleanup":"callback"}:`)}};for(let K of $)try{let z=K(x);if(Z(z))G.push(z)}catch(z){H.push(F(z))}if(J(),!G.length)return;if(G.length===1)return G[0];return()=>{for(let K of G)try{K()}catch(z){H.push(F(z))}J(!0)}},b$=($,x)=>x.includes($);var L=($,x,G)=>{if(Object.is($,x))return!0;if(typeof $!==typeof x)return!1;if(!X$($)||!X$(x))return!1;if(!G)G=new WeakSet;if(G.has($)||G.has(x))throw new R("isEqual");G.add($),G.add(x);try{if(Array.isArray($)&&Array.isArray(x)){if($.length!==x.length)return!1;for(let H=0;H<$.length;H++)if(!L($[H],x[H],G))return!1;return!0}if(Array.isArray($)!==Array.isArray(x))return!1;if(U($)&&U(x)){let H=Object.keys($),J=Object.keys(x);if(H.length!==J.length)return!1;for(let K of H){if(!(K in x))return!1;if(!L($[K],x[K],G))return!1}return!0}return!1}finally{G.delete($),G.delete(x)}},b=($,x)=>{let G=a($),H=a(x);if(!G||!H){let B=!Object.is($,x);return{changed:B,add:B&&H?x:{},change:{},remove:B&&G?$:{}}}let J=new WeakSet,K={},z={},D={},y=Object.keys($),c=Object.keys(x),W=new Set([...y,...c]);for(let B of W){let _=B in $,k=B in x;if(!_&&k){K[B]=x[B];continue}else if(_&&!k){D[B]=Q;continue}let V$=$[B],R$=x[B];if(!L(V$,R$,J))z[B]=R$}return{add:K,change:z,remove:D,changed:!!(Object.keys(K).length||Object.keys(z).length||Object.keys(D).length)}};var $$="Computed";class p{#x;#$;#G;#H=!0;#J=!1;#K;constructor($,x){Y(this.constructor.name,$,x$);let G=x?.initialValue??Q;if(A(this.constructor.name,G,x?.guard),this.#x=$,this.#$=G,x?.watched)M(this,x.watched,x.unwatched)}#z(){if(!this.#K)this.#K=C(()=>{if(this.#H=!0,!X(this))this.#K?.stop()}),this.#K.onCleanup(()=>{this.#K=void 0});return this.#K}get[Symbol.toStringTag](){return $$}get(){if(q(this),h(),this.#H){let $=this.#z();w($,()=>{if(this.#J)throw new R("memo");let x;this.#J=!0;try{x=this.#x(this.#$)}catch(G){this.#$=Q,this.#G=F(G),this.#J=!1;return}if(x==null||Q===x)this.#$=Q,this.#G=void 0;else this.#$=x,this.#G=void 0,this.#H=!1;this.#J=!1})}if(this.#G)throw this.#G;return this.#$}}class n{#x;#$;#G;#H=!0;#J=!1;#K=!1;#z;#Q;constructor($,x){Y(this.constructor.name,$,G$);let G=x?.initialValue??Q;if(A(this.constructor.name,G,x?.guard),this.#x=$,this.#$=G,x?.watched)M(this,x.watched,x.unwatched)}#X(){if(!this.#z)this.#z=C(()=>{if(this.#H=!0,this.#Q?.abort(),!X(this))this.#z?.stop()}),this.#z.onCleanup(()=>{this.#Q?.abort(),this.#Q=void 0,this.#z=void 0});return this.#z}get[Symbol.toStringTag](){return $$}get(){q(this),h();let $=(K)=>{if(!L(K,this.#$))this.#$=K,this.#K=!0;this.#G=void 0,this.#H=!1},x=()=>{this.#K=Q!==this.#$,this.#$=Q,this.#G=void 0},G=(K)=>{let z=F(K);this.#K=!this.#G||z.name!==this.#G.name||z.message!==this.#G.message,this.#$=Q,this.#G=z},H=(K)=>(z)=>{if(this.#J=!1,this.#Q=void 0,K(z),this.#K&&!X(this))this.#z?.stop()},J=()=>w(this.#X(),()=>{if(this.#J)throw new R("task");if(this.#K=!1,this.#Q)return this.#$;this.#Q=new AbortController,this.#Q.signal.addEventListener("abort",()=>{this.#J=!1,this.#Q=void 0,J()},{once:!0});let K;this.#J=!0;try{K=this.#x(this.#$,this.#Q.signal)}catch(z){if(m(z))x();else G(z);this.#J=!1;return}if(K instanceof Promise)K.then(H($),H(G));else if(K==null||Q===K)x();else $(K);this.#J=!1});if(this.#H)J();if(this.#G)throw this.#G;return this.#$}}var A$=($,x)=>j($)?new n($,x):new p($,x),D$=($)=>I($,$$),x$=($)=>W$($)&&$.length<2,G$=($)=>j($)&&$.length<3;class d{signals=new Map;#x;#$;constructor($,x,G){this.#x=x,this.#$=G,this.change({add:$,change:{},remove:{},changed:!0})}add($,x){if(!this.#x($,x))return!1;return this.signals.set($,this.#$(x)),!0}remove($){return this.signals.delete($)}change($){if(Object.keys($.add).length)for(let x in $.add)this.add(x,$.add[x]);if(Object.keys($.change).length)q$(()=>{for(let x in $.change){let G=$.change[x];if(!this.#x(x,G))continue;let H=this.signals.get(x);if(I$(`list item "${x}"`,G,H))H.set(G)}});if(Object.keys($.remove).length)for(let x in $.remove)this.remove(x);return $.changed}clear(){return this.signals.clear(),!0}}var g="State";class f{#x;constructor($,x){if(A(g,$,x?.guard),this.#x=$,x?.watched)M(this,x.watched,x.unwatched)}get[Symbol.toStringTag](){return g}get(){return q(this),this.#x}set($){if(A(g,$),L(this.#x,$))return;if(this.#x=$,X(this),Q===this.#x)V(this)}update($){Y(`${g} update`,$),this.set($(this.#x))}}var H$=($)=>I($,g);var v="List";class u{#x;#$=[];#G;constructor($,x){A(v,$,Array.isArray);let G=0,H=x?.keyConfig;if(this.#G=r(H)?()=>`${H}${G++}`:Z(H)?(J)=>H(J):()=>String(G++),this.#x=new d(this.#H($),(J,K)=>{return A(`${v} for key "${J}"`,K),!0},(J)=>new f(J)),x?.watched)M(this,x.watched,x.unwatched)}#H($){let x={};for(let G=0;G<$.length;G++){let H=$[G];if(H===void 0)continue;let J=this.#$[G];if(!J)J=this.#G(H),this.#$[G]=J;x[J]=H}return x}get#J(){return this.#$.map(($)=>this.#x.signals.get($)?.get()).filter(($)=>$!==void 0)}get[Symbol.toStringTag](){return v}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#$){let x=this.#x.signals.get($);if(x)yield x}}get length(){return q(this),this.#$.length}get(){return q(this),this.#J}set($){if(Q===$){this.#x.clear(),X(this),V(this);return}let x=this.#J,G=b(this.#H(x),this.#H($)),H=Object.keys(G.remove);if(this.#x.change(G)){for(let K of H){let z=this.#$.indexOf(K);if(z!==-1)this.#$.splice(z,1)}this.#$=this.#$.filter(()=>!0),X(this)}}update($){this.set($(this.get()))}at($){return this.#x.signals.get(this.#$[$])}keys(){return this.#$.values()}byKey($){return this.#x.signals.get($)}keyAt($){return this.#$[$]}indexOfKey($){return this.#$.indexOf($)}add($){let x=this.#G($);if(this.#x.signals.has(x))throw new E("store",x,$);if(!this.#$.includes(x))this.#$.push(x);if(this.#x.add(x,$))X(this);return x}remove($){let x=l($)?this.#$[$]:$;if(this.#x.remove(x)){let H=l($)?$:this.#$.indexOf(x);if(H>=0)this.#$.splice(H,1);this.#$=this.#$.filter(()=>!0),X(this)}}sort($){let G=this.#$.map((H)=>[H,this.#x.signals.get(H)?.get()]).sort(Z($)?(H,J)=>$(H[1],J[1]):(H,J)=>String(H[1]).localeCompare(String(J[1]))).map(([H])=>H);if(!L(this.#$,G))this.#$=G,X(this)}splice($,x,...G){let H=this.#$.length,J=$<0?Math.max(0,H+$):Math.min($,H),K=Math.max(0,Math.min(x??Math.max(0,H-Math.max(0,J)),H-J)),z={},D={};for(let W=0;W<K;W++){let B=J+W,_=this.#$[B];if(_){let k=this.#x.signals.get(_);if(k)D[_]=k.get()}}let y=this.#$.slice(0,J);for(let W of G){let B=this.#G(W);y.push(B),z[B]=W}y.push(...this.#$.slice(J+K));let c=!!(Object.keys(z).length||Object.keys(D).length);if(c)this.#x.change({add:z,change:{},remove:D,changed:c}),this.#$=y.filter(()=>!0),X(this);return Object.values(D)}deriveCollection($){return new s(this,$)}}var o=($)=>I($,v);var O="Store";class M${#x;constructor($,x){if(A(O,$,x?.guard??U),this.#x=new d($,(G,H)=>{return A(`${O} for key "${G}"`,H),!0},(G)=>_$(G)),x?.watched)M(this,x.watched,x.unwatched)}get#$(){let $={};for(let[x,G]of this.#x.signals.entries())$[x]=G.get();return $}get[Symbol.toStringTag](){return O}get[Symbol.isConcatSpreadable](){return!1}*[Symbol.iterator](){for(let[$,x]of this.#x.signals.entries())yield[$,x]}keys(){return this.#x.signals.keys()}byKey($){return this.#x.signals.get($)}get(){return q(this),this.#$}set($){if(Q===$){this.#x.clear(),X(this),V(this);return}let x=this.#$;if(this.#x.change(b(x,$)))X(this)}update($){this.set($(this.get()))}add($,x){if(this.#x.signals.has($))throw new E(O,$,x);if(this.#x.add($,x))X(this);return $}remove($){if(this.#x.remove($))X(this)}}var J$=($,x)=>{let G=new M$($,x);return new Proxy(G,{get(H,J){if(J in H){let K=Reflect.get(H,J);return Z(K)?K.bind(H):K}if(!S(J))return H.byKey(J)},has(H,J){if(J in H)return!0;return H.byKey(String(J))!==void 0},ownKeys(H){return Array.from(H.keys())},getOwnPropertyDescriptor(H,J){if(J in H)return Reflect.getOwnPropertyDescriptor(H,J);if(S(J))return;let K=H.byKey(String(J));return K?{enumerable:!0,configurable:!0,writable:!0,value:K}:void 0}})},K$=($)=>I($,O);var p$=($)=>H$($)||D$($)||K$($),F$=($)=>H$($)||K$($)||o($);function n$($){if(x$($))return new p($);if(G$($))return new n($);if(Z$($))return new u($);if(U($))return J$($);return new f($)}function _$($){if(Z$($))return new u($);if(U($))return J$($);return new f($)}class R extends Error{constructor($){super(`Circular dependency detected in ${$}`);this.name="CircularDependencyError"}}class E extends Error{constructor($,x,G){super(`Could not add ${$} key "${x}"${G?` with value ${P(G)}`:""} because it already exists`);this.name="DuplicateKeyError"}}class S$ extends Error{constructor($="unexpected condition"){super(`Assertion failed: ${$}`);this.name="FailedAssertionError"}}class i extends TypeError{constructor($,x){super(`Invalid ${$} callback ${P(x)}`);this.name="InvalidCallbackError"}}class z$ extends TypeError{constructor($,x){super(`Invalid ${$} source ${P(x)}`);this.name="InvalidCollectionSourceError"}}class m$ extends TypeError{constructor($,x){super(`Invalid hook "${x}" in  ${$}`);this.name="InvalidHookError"}}class U$ extends TypeError{constructor($,x){super(`Invalid signal value ${P(x)} in ${$}`);this.name="InvalidSignalValueError"}}class L$ extends TypeError{constructor($){super(`Nullish signal values are not allowed in ${$}`);this.name="NullishSignalValueError"}}class N$ extends Error{constructor($,x){super(`Could not set ${$} to ${P(x)} because signal is read-only`);this.name="ReadonlySignalError"}}function f$($,x){if(!$)throw new S$(x)}var F=($)=>$ instanceof Error?$:Error(String($)),Y=($,x,G=Z)=>{if(!G(x))throw new i($,x)},A=($,x,G=()=>!(S(x)&&x!==Q)||Z(x))=>{if(x==null)throw new L$($);if(!G(x))throw new U$($,x)},I$=($,x,G)=>{if(!F$(G))throw new N$($,x);return!0};var t="Collection";class s{#x;#$;#G=new Map;#H=[];constructor($,x,G){if(Y(t,x),Z($))$=$();if(!d$($))throw new z$(t,$);this.#x=$,this.#$=x;for(let H=0;H<this.#x.length;H++){let J=this.#x.keyAt(H);if(!J)continue;this.#J(J)}if(G?.watched)M(this,G.watched,G.unwatched)}#J($){let x=v$(this.#$)?async(H,J)=>{let K=this.#x.byKey($)?.get();if(K===Q)return Q;return this.#$(K,J)}:()=>{let H=this.#x.byKey($)?.get();if(H===Q)return Q;return this.#$(H)},G=A$(x);if(this.#G.set($,G),!this.#H.includes($))this.#H.push($);return!0}get[Symbol.toStringTag](){return t}get[Symbol.isConcatSpreadable](){return!0}*[Symbol.iterator](){for(let $ of this.#H){let x=this.#G.get($);if(x)yield x}}keys(){return this.#H.values()}get(){return q(this),this.#H.map(($)=>this.#G.get($)?.get()).filter(($)=>$!=null&&$!==Q)}at($){return this.#G.get(this.#H[$])}byKey($){return this.#G.get($)}keyAt($){return this.#H[$]}indexOfKey($){return this.#H.indexOf($)}deriveCollection($){return new s(this,$)}get length(){return q(this),this.#H.length}}var T$=($)=>I($,t),d$=($)=>o($)||T$($),v$=($)=>j($);var Q$="Ref";class C${#x;constructor($,x){if(A(Q$,$,x?.guard),this.#x=$,x?.watched)M(this,x.watched,x.unwatched)}get[Symbol.toStringTag](){return Q$}get(){return q(this),this.#x}notify(){X(this)}}var u$=($)=>I($,Q$);var o$=($)=>{if(!Z($)||$.length>1)throw new i("effect",$);let x=j($),G=!1,H,J=C(()=>w(J,()=>{if(G)throw new R("effect");G=!0,H?.abort(),H=void 0;let K;try{if(x){H=new AbortController;let z=H;$(H.signal).then((D)=>{if(Z(D)&&H===z)J.onCleanup(D)}).catch((D)=>{if(!m(D))console.error("Error in async effect callback:",D)})}else if(K=$(),Z(K))J.onCleanup(K)}catch(z){if(!m(z))console.error("Error in effect callback:",z)}G=!1}));return J(),()=>{H?.abort();try{J.stop()}catch(K){console.error("Error in effect cleanup:",K)}}};function s$($,x){try{if($.pending)x.nil?.();else if($.errors)x.err?.($.errors);else if($.ok)x.ok($.values)}catch(G){let H=F(G);if(x.err&&(!$.errors||!$.errors.includes(H)))x.err($.errors?[...$.errors,H]:[H]);else throw H}}function i$($){let x=[],G=!1,H={};for(let[J,K]of Object.entries($))try{let z=K.get();if(z===Q)G=!0;else H[J]=z}catch(z){x.push(F(z))}if(G)return{ok:!1,pending:!0};if(x.length>0)return{ok:!1,errors:x};return{ok:!0,values:H}}export{P as valueString,A as validateSignalValue,Y as validateCallback,h$ as triggerHook,w as trackSignalReads,q as subscribeTo,i$ as resolve,X as notifyOf,s$ as match,G$ as isTaskCallback,S as isSymbol,r as isString,K$ as isStore,H$ as isState,p$ as isSignal,u$ as isRef,a as isRecordOrArray,U as isRecord,I as isObjectOfType,l as isNumber,F$ as isMutableSignal,x$ as isMemoCallback,o as isList,b$ as isHandledHook,Z as isFunction,L as isEqual,D$ as isComputed,T$ as isCollection,j as isAsyncFunction,m as isAbortError,I$ as guardMutableSignal,h as flushPendingReactions,b as diff,C as createWatcher,J$ as createStore,n$ as createSignal,F as createError,o$ as createEffect,A$ as createComputed,q$ as batchSignalWrites,Q as UNSET,n as Task,O as TYPE_STORE,g as TYPE_STATE,Q$ as TYPE_REF,v as TYPE_LIST,$$ as TYPE_COMPUTED,t as TYPE_COLLECTION,f as State,C$ as Ref,N$ as ReadonlySignalError,L$ as NullishSignalValueError,p as Memo,u as List,U$ as InvalidSignalValueError,m$ as InvalidHookError,z$ as InvalidCollectionSourceError,i as InvalidCallbackError,k$ as HOOK_WATCH,y$ as HOOK_SORT,O$ as HOOK_REMOVE,E$ as HOOK_CLEANUP,g$ as HOOK_CHANGE,w$ as HOOK_ADD,E as DuplicateKeyError,s as DerivedCollection,R as CircularDependencyError,M$ as BaseStore};
